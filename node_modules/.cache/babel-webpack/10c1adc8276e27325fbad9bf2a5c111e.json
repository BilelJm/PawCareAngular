{"ast":null,"code":"import { Encoding, Save } from '@syncfusion/ej2-file-utils';\n/* eslint-disable */\n\nvar Utils =\n/** @__PURE__ @class */\nfunction () {\n  function Utils() {}\n\n  Utils.bitReverse = function (value) {\n    return Utils.reverseBits[value & 15] << 12 | Utils.reverseBits[value >> 4 & 15] << 8 | Utils.reverseBits[value >> 8 & 15] << 4 | Utils.reverseBits[value >> 12];\n  };\n\n  Utils.bitConverterToInt32 = function (value, index) {\n    return value[index] | value[index + 1] << 8 | value[index + 2] << 16 | value[index + 3] << 24;\n  };\n\n  Utils.bitConverterToInt16 = function (value, index) {\n    return value[index] | value[index + 1] << 8;\n  };\n\n  Utils.bitConverterToUInt32 = function (value) {\n    var uint = new Uint32Array(1);\n    uint[0] = value;\n    return uint[0];\n  };\n\n  Utils.bitConverterToUInt16 = function (value, index) {\n    var uint = new Uint16Array(1);\n    uint[0] = value[index] | value[index + 1] << 8;\n    return uint[0];\n  };\n\n  Utils.bitConverterUintToInt32 = function (value) {\n    var uint = new Int32Array(1);\n    uint[0] = value;\n    return uint[0];\n  };\n\n  Utils.bitConverterInt32ToUint = function (value) {\n    var uint = new Uint32Array(1);\n    uint[0] = value;\n    return uint[0];\n  };\n\n  Utils.bitConverterInt32ToInt16 = function (value) {\n    var uint = new Int16Array(1);\n    uint[0] = value;\n    return uint[0];\n  };\n\n  Utils.byteToString = function (value) {\n    var str = '';\n\n    for (var i = 0; i < value.length; i++) {\n      str += String.fromCharCode(value[i]);\n    }\n\n    return str;\n  };\n\n  Utils.byteIntToString = function (value) {\n    var str = '';\n\n    for (var i = 0; i < value.length; i++) {\n      str += String.fromCharCode(value[i]);\n    }\n\n    return str;\n  };\n\n  Utils.arrayCopy = function (source, sourceIndex, destination, destinationIndex, dataToCopy) {\n    var temp = new Uint8Array(source.buffer, sourceIndex);\n    var data = temp.subarray(0, dataToCopy);\n    destination.set(data, destinationIndex);\n  };\n\n  Utils.mergeArray = function (arrayOne, arrayTwo) {\n    var mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n    mergedArray.set(arrayOne);\n    mergedArray.set(arrayTwo, arrayOne.length);\n    return mergedArray;\n  };\n  /**\n   * @private\n   */\n\n\n  Utils.encodedString = function (input) {\n    var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var chr1;\n    var chr2;\n    var chr3;\n    var encode1;\n    var encode2;\n    var encode3;\n    var encode4;\n    var count = 0;\n    var resultIndex = 0;\n    /*let dataUrlPrefix: string = 'data:';*/\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n    var totalLength = input.length * 3 / 4;\n\n    if (input.charAt(input.length - 1) === keyStr.charAt(64)) {\n      totalLength--;\n    }\n\n    if (input.charAt(input.length - 2) === keyStr.charAt(64)) {\n      totalLength--;\n    }\n\n    if (totalLength % 1 !== 0) {\n      // totalLength is not an integer, the length does not match a valid\n      // base64 content. That can happen if:\n      // - the input is not a base64 content\n      // - the input is *almost* a base64 content, with a extra chars at the\n      // beginning or at the end\n      // - the input uses a base64 variant (base64url for example)\n      throw new Error('Invalid base64 input, bad content length.');\n    }\n\n    var output = new Uint8Array(totalLength | 0);\n\n    while (count < input.length) {\n      encode1 = keyStr.indexOf(input.charAt(count++));\n      encode2 = keyStr.indexOf(input.charAt(count++));\n      encode3 = keyStr.indexOf(input.charAt(count++));\n      encode4 = keyStr.indexOf(input.charAt(count++));\n      chr1 = encode1 << 2 | encode2 >> 4;\n      chr2 = (encode2 & 15) << 4 | encode3 >> 2;\n      chr3 = (encode3 & 3) << 6 | encode4;\n      output[resultIndex++] = chr1;\n\n      if (encode3 !== 64) {\n        output[resultIndex++] = chr2;\n      }\n\n      if (encode4 !== 64) {\n        output[resultIndex++] = chr3;\n      }\n    }\n\n    return output;\n  };\n\n  Utils.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n  Utils.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  return Utils;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n\n\nvar CRC32TABLE = []; /// <summary>\n/// Size of the int value in bytes.\n/// </summary>\n\nvar INT_SIZE = 4; /// <summary>\n/// Size of the short value in bytes.\n/// </summary>\n\nvar SHORT_SIZE = 2; /// <summary>\n/// End of central directory signature.\n/// </summary>\n\nvar CentralDirectoryEndSignature = 0x06054b50; /// <summary>\n/// Offset to the size field in the End of central directory record.\n/// </summary>\n\nvar CentralDirSizeOffset = 12; /// <summary>\n/// Central header signature.\n/// </summary>\n\nvar CentralHeaderSignature = 0x02014b50; /// <summary>\n/// Buffer size.\n/// </summary>\n\nvar BufferSize = 4096;\n/**\n * class provide compression library\n * ```typescript\n * let archive = new ZipArchive();\n * archive.compressionLevel = 'Normal';\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * archive.addItem(archiveItem);\n * archive.save(fileName.zip);\n * ```\n */\n\nvar ZipArchive =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * constructor for creating ZipArchive instance\n   */\n  function ZipArchive() {\n    if (CRC32TABLE.length === 0) {\n      ZipArchive.initCrc32Table();\n    }\n\n    this.files = [];\n    this.level = 'Normal';\n    Save.isMicrosoftBrowser = !!navigator.msSaveBlob;\n  }\n\n  Object.defineProperty(ZipArchive.prototype, \"items\", {\n    get: function () {\n      return this.files;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchive.prototype, \"compressionLevel\", {\n    /**\n     * gets compression level\n     */\n    get: function () {\n      return this.level;\n    },\n\n    /**\n     * sets compression level\n     */\n    set: function (level) {\n      this.level = level;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchive.prototype, \"length\", {\n    /**\n     * gets items count\n     */\n    get: function () {\n      if (this.files === undefined) {\n        return 0;\n      }\n\n      return this.files.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * add new item to archive\n   * @param {ZipArchiveItem} item - item to be added\n   * @returns {void}\n   */\n\n  ZipArchive.prototype.addItem = function (item) {\n    if (item === null || item === undefined) {\n      throw new Error('ArgumentException: item cannot be null or undefined');\n    }\n\n    for (var i = 0; i < this.files.length; i++) {\n      var file = this.files[i];\n\n      if (file instanceof ZipArchiveItem) {\n        if (file.name === item.name) {\n          throw new Error('item with same name already exist');\n        }\n      }\n    }\n\n    this.files.push(item);\n  };\n  /**\n   * add new directory to archive\n   * @param directoryName directoryName to be created\n   * @returns {void}\n   */\n\n\n  ZipArchive.prototype.addDirectory = function (directoryName) {\n    if (directoryName === null || directoryName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (directoryName.length === 0) {\n      throw new Error('ArgumentException: string cannot be empty');\n    }\n\n    if (directoryName.slice(-1) !== '/') {\n      directoryName += '/';\n    }\n\n    if (this.files.indexOf(directoryName) !== -1) {\n      throw new Error('item with same name already exist');\n    }\n\n    this.files.push(directoryName);\n  };\n  /**\n   * gets item at specified index\n   * @param {number} index - item index\n   * @returns {ZipArchiveItem}\n   */\n\n\n  ZipArchive.prototype.getItem = function (index) {\n    if (index >= 0 && index < this.files.length) {\n      return this.files[index];\n    }\n\n    return undefined;\n  };\n  /**\n   * determines whether an element is in the collection\n   * @param {string | ZipArchiveItem} item - item to search\n   * @returns {boolean}\n   */\n\n\n  ZipArchive.prototype.contains = function (item) {\n    return this.files.indexOf(item) !== -1 ? true : false;\n  };\n\n  ZipArchive.prototype.open = function (base64String) {\n    //return promise = new Promise((resolve: Function, reject: Function) => {\n    var zipByteArray = Utils.encodedString(base64String);\n    if (zipByteArray.length == 0) throw new DOMException(\"stream\");\n    var stream = new Stream(zipByteArray); //let lCentralDirEndPosition = this.findValueFromEnd( arrBuffer, Constants.CentralDirectoryEndSignature, 65557 );\n\n    var lCentralDirEndPosition = ZipArchive.findValueFromEnd(stream, CentralDirectoryEndSignature, 65557);\n    if (lCentralDirEndPosition < 0) throw new DOMException(\"Can't locate end of central directory record. Possible wrong file format or archive is corrupt.\"); // Step2. Locate central directory and iterate through all items\n\n    stream.position = lCentralDirEndPosition + CentralDirSizeOffset;\n    var iCentralDirSize = ZipArchive.ReadInt32(stream);\n    var lCentralDirPosition = lCentralDirEndPosition - iCentralDirSize; // verify that this is really central directory\n\n    stream.position = lCentralDirPosition;\n    this.readCentralDirectoryDataAndExtractItems(stream); //});\n    // let zipArchive: ZipArchive = this;\n    //let promise: Promise<ZipArchive>;\n    // return promise = new Promise((resolve: Function, reject: Function) => {\n    //     let reader: FileReader = new FileReader();\n    //     reader.onload = (e: Event) => {\n    //         let data: Uint8Array = new Uint8Array((e.target as any).result);\n    //         let zipReader: ZipReader = new ZipReader(data);\n    //         zipReader.readEntries().then((entries: ZipEntry[]) => {\n    //             for (let i: number = 0; i < entries.length; i++) {\n    //                 let entry: ZipEntry = entries[i];\n    //                 let item: ZipArchiveItem = new ZipArchiveItem(zipArchive, entry.fileName);\n    //                 item.data = entry.data;\n    //                 item.compressionMethod = entry.compressionMethod;\n    //                 item.crc = entry.crc;\n    //                 item.lastModified = entry.lastModified;\n    //                 item.lastModifiedDate = entry.lastModifiedDate;\n    //                 item.size = entry.size;\n    //                 item.uncompressedSize = entry.uncompressedSize;\n    //                 zipArchive.addItem(item);\n    //             }\n    //             resolve(zipArchive);\n    //         });\n    //     };\n    //     reader.readAsArrayBuffer(fileName);\n    // });\n  }; /// <summary>\n  /// Read central directory record from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read from.</param>\n\n\n  ZipArchive.prototype.readCentralDirectoryDataAndExtractItems = function (stream) {\n    if (stream == null) throw new DOMException(\"stream\");\n    var itemHelper;\n\n    while (ZipArchive.ReadInt32(stream) == CentralHeaderSignature) {\n      itemHelper = new ZipArchiveItemHelper();\n      itemHelper.readCentralDirectoryData(stream); // let item: ZipArchiveItem = new ZipArchiveItem(this);\n      // item.ReadCentralDirectoryData(stream);\n      // m_arrItems.Add(item);\n    }\n\n    itemHelper.readData(stream, itemHelper.checkCrc);\n    itemHelper.decompressData();\n    this.files.push(new ZipArchiveItem(itemHelper.unCompressedStream.buffer, itemHelper.name));\n  };\n  /**\n   * save archive with specified file name\n   * @param {string} fileName save archive with specified file name\n   * @returns {Promise<ZipArchive>}\n   */\n\n\n  ZipArchive.prototype.save = function (fileName) {\n    if (fileName === null || fileName === undefined || fileName.length === 0) {\n      throw new Error('ArgumentException: fileName cannot be null or undefined');\n    }\n\n    if (this.files.length === 0) {\n      throw new Error('InvalidOperation');\n    }\n\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal(fileName, false).then(function () {\n        resolve(zipArchive);\n      });\n    });\n  };\n  /**\n   * Save archive as blob\n   * @return {Promise<Blob>}\n   */\n\n\n  ZipArchive.prototype.saveAsBlob = function () {\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      zipArchive.saveInternal('', true).then(function (blob) {\n        resolve(blob);\n      });\n    });\n  };\n\n  ZipArchive.prototype.saveInternal = function (fileName, skipFileSave) {\n    var _this = this;\n\n    var zipArchive = this;\n    var promise;\n    return promise = new Promise(function (resolve, reject) {\n      var zipData = [];\n      var dirLength = 0;\n\n      for (var i = 0; i < zipArchive.files.length; i++) {\n        var compressedObject = _this.getCompressedData(_this.files[i]);\n\n        compressedObject.then(function (data) {\n          dirLength = zipArchive.constructZippedObject(zipData, data, dirLength, data.isDirectory);\n\n          if (zipData.length === zipArchive.files.length) {\n            var blob = zipArchive.writeZippedContent(fileName, zipData, dirLength, skipFileSave);\n            resolve(blob);\n          }\n        });\n      }\n    });\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  ZipArchive.prototype.destroy = function () {\n    if (this.files !== undefined && this.files.length > 0) {\n      for (var i = 0; i < this.files.length; i++) {\n        var file = this.files[i];\n\n        if (file instanceof ZipArchiveItem) {\n          file.destroy();\n        }\n\n        file = undefined;\n      }\n\n      this.files = [];\n    }\n\n    this.files = undefined;\n    this.level = undefined;\n  };\n\n  ZipArchive.prototype.getCompressedData = function (item) {\n    var zipArchive = this;\n    var promise = new Promise(function (resolve, reject) {\n      if (item instanceof ZipArchiveItem) {\n        var reader_1 = new FileReader();\n\n        reader_1.onload = function () {\n          var input = new Uint8Array(reader_1.result);\n          var data = {\n            fileName: item.name,\n            crc32Value: 0,\n            compressedData: [],\n            compressedSize: undefined,\n            uncompressedDataSize: input.length,\n            compressionType: undefined,\n            isDirectory: false\n          };\n\n          if (zipArchive.level === 'Normal') {\n            zipArchive.compressData(input, data, CRC32TABLE);\n            var length_1 = 0;\n\n            for (var i = 0; i < data.compressedData.length; i++) {\n              length_1 += data.compressedData[i].length;\n            }\n\n            data.compressedSize = length_1;\n            data.compressionType = '\\x08\\x00'; //Deflated = 8\n          } else {\n            data.compressedSize = input.length;\n            data.crc32Value = zipArchive.calculateCrc32Value(0, input, CRC32TABLE);\n            data.compressionType = '\\x00\\x00'; // Stored = 0\n\n            data.compressedData.push(input);\n          }\n\n          resolve(data);\n        };\n\n        reader_1.readAsArrayBuffer(item.data);\n      } else {\n        var data = {\n          fileName: item,\n          crc32Value: 0,\n          compressedData: '',\n          compressedSize: 0,\n          uncompressedDataSize: 0,\n          compressionType: '\\x00\\x00',\n          isDirectory: true\n        };\n        resolve(data);\n      }\n    });\n    return promise;\n  };\n\n  ZipArchive.prototype.compressData = function (input, data, crc32Table) {\n    var compressor = new CompressedStreamWriter(true);\n    var currentIndex = 0;\n    var nextIndex = 0;\n\n    do {\n      if (currentIndex >= input.length) {\n        compressor.close();\n        break;\n      }\n\n      nextIndex = Math.min(input.length, currentIndex + 16384);\n      var subArray = input.subarray(currentIndex, nextIndex);\n      data.crc32Value = this.calculateCrc32Value(data.crc32Value, subArray, crc32Table);\n      compressor.write(subArray, 0, nextIndex - currentIndex);\n      currentIndex = nextIndex;\n    } while (currentIndex <= input.length);\n\n    data.compressedData = compressor.compressedData;\n    compressor.destroy();\n  };\n\n  ZipArchive.prototype.constructZippedObject = function (zipParts, data, dirLength, isDirectory) {\n    var extFileAttr = 0;\n    var date = new Date();\n\n    if (isDirectory) {\n      extFileAttr = extFileAttr | 0x00010; // directory flag\n    }\n\n    extFileAttr = extFileAttr | 0 & 0x3F;\n    var header = this.writeHeader(data, date);\n    var localHeader = 'PK\\x03\\x04' + header + data.fileName;\n    var centralDir = this.writeCentralDirectory(data, header, dirLength, extFileAttr);\n    zipParts.push({\n      localHeader: localHeader,\n      centralDir: centralDir,\n      compressedData: data\n    });\n    return dirLength + localHeader.length + data.compressedSize;\n  };\n\n  ZipArchive.prototype.writeHeader = function (data, date) {\n    var zipHeader = '';\n    zipHeader += '\\x0A\\x00' + '\\x00\\x00'; // version needed to extract & general purpose bit flag\n\n    zipHeader += data.compressionType; // compression method Deflate=8,Stored=0\n\n    zipHeader += this.getBytes(this.getModifiedTime(date), 2); // last modified Time\n\n    zipHeader += this.getBytes(this.getModifiedDate(date), 2); // last modified date\n\n    zipHeader += this.getBytes(data.crc32Value, 4); // crc-32 value\n\n    zipHeader += this.getBytes(data.compressedSize, 4); // compressed file size\n\n    zipHeader += this.getBytes(data.uncompressedDataSize, 4); // uncompressed file size\n\n    zipHeader += this.getBytes(data.fileName.length, 2); // file name length\n\n    zipHeader += this.getBytes(0, 2); // extra field length\n\n    return zipHeader;\n  };\n\n  ZipArchive.prototype.writeZippedContent = function (fileName, zipData, localDirLen, skipFileSave) {\n    var cenDirLen = 0;\n    var buffer = [];\n\n    for (var i = 0; i < zipData.length; i++) {\n      var item = zipData[i];\n      cenDirLen += item.centralDir.length;\n      buffer.push(this.getArrayBuffer(item.localHeader));\n\n      while (item.compressedData.compressedData.length) {\n        buffer.push(item.compressedData.compressedData.shift().buffer);\n      }\n    }\n\n    for (var i = 0; i < zipData.length; i++) {\n      buffer.push(this.getArrayBuffer(zipData[i].centralDir));\n    }\n\n    buffer.push(this.getArrayBuffer(this.writeFooter(zipData, cenDirLen, localDirLen)));\n    var blob = new Blob(buffer, {\n      type: 'application/zip'\n    });\n\n    if (!skipFileSave) {\n      Save.save(fileName, blob);\n    }\n\n    return blob;\n  };\n\n  ZipArchive.prototype.writeCentralDirectory = function (data, localHeader, offset, externalFileAttribute) {\n    var directoryHeader = 'PK\\x01\\x02' + this.getBytes(0x0014, 2) + localHeader + // inherit from file header\n    this.getBytes(0, 2) + // comment length\n    '\\x00\\x00' + '\\x00\\x00' + // internal file attributes \n    this.getBytes(externalFileAttribute, 4) + // external file attributes\n    this.getBytes(offset, 4) + // local fileHeader relative offset\n    data.fileName;\n    return directoryHeader;\n  };\n\n  ZipArchive.prototype.writeFooter = function (zipData, centralLength, localLength) {\n    var dirEnd = 'PK\\x05\\x06' + '\\x00\\x00' + '\\x00\\x00' + this.getBytes(zipData.length, 2) + this.getBytes(zipData.length, 2) + this.getBytes(centralLength, 4) + this.getBytes(localLength, 4) + this.getBytes(0, 2);\n    return dirEnd;\n  };\n\n  ZipArchive.prototype.getArrayBuffer = function (input) {\n    var a = new Uint8Array(input.length);\n\n    for (var j = 0; j < input.length; ++j) {\n      a[j] = input.charCodeAt(j) & 0xFF;\n    }\n\n    return a.buffer;\n  };\n\n  ZipArchive.prototype.getBytes = function (value, offset) {\n    var bytes = '';\n\n    for (var i = 0; i < offset; i++) {\n      bytes += String.fromCharCode(value & 0xff);\n      value = value >>> 8;\n    }\n\n    return bytes;\n  };\n\n  ZipArchive.prototype.getModifiedTime = function (date) {\n    var modTime = date.getHours();\n    modTime = modTime << 6;\n    modTime = modTime | date.getMinutes();\n    modTime = modTime << 5;\n    return modTime = modTime | date.getSeconds() / 2;\n  };\n\n  ZipArchive.prototype.getModifiedDate = function (date) {\n    var modiDate = date.getFullYear() - 1980;\n    modiDate = modiDate << 4;\n    modiDate = modiDate | date.getMonth() + 1;\n    modiDate = modiDate << 5;\n    return modiDate = modiDate | date.getDate();\n  };\n\n  ZipArchive.prototype.calculateCrc32Value = function (crc32Value, input, crc32Table) {\n    crc32Value ^= -1;\n\n    for (var i = 0; i < input.length; i++) {\n      crc32Value = crc32Value >>> 8 ^ crc32Table[(crc32Value ^ input[i]) & 0xFF];\n    }\n\n    return crc32Value ^ -1;\n  };\n  /**\n   * construct cyclic redundancy code table\n   * @private\n   */\n\n\n  ZipArchive.initCrc32Table = function () {\n    var i;\n\n    for (var j = 0; j < 256; j++) {\n      i = j;\n\n      for (var k = 0; k < 8; k++) {\n        i = i & 1 ? 0xEDB88320 ^ i >>> 1 : i >>> 1;\n      }\n\n      CRC32TABLE[j] = i;\n    }\n  };\n\n  ZipArchive.findValueFromEnd = function (stream, value, maxCount) {\n    if (stream == null) throw new DOMException(\"stream\"); //   if( !stream.CanSeek || !stream.CanRead )\n    //     throw new ArgumentOutOfRangeException( \"We need to have seekable and readable stream.\" );\n    // read last 4 bytes and compare with required value\n\n    var lStreamSize = stream.inputStream.buffer.byteLength;\n    if (lStreamSize < 4) return -1;\n    var arrBuffer = new Uint8Array(4);\n    var lLastPos = Math.max(0, lStreamSize - maxCount);\n    var lCurrentPosition = lStreamSize - 1 - INT_SIZE;\n    stream.position = lCurrentPosition;\n    stream.read(arrBuffer, 0, INT_SIZE);\n    var uiCurValue = arrBuffer[0];\n    var bFound = uiCurValue == value;\n\n    if (!bFound) {\n      while (lCurrentPosition > lLastPos) {\n        // remove unnecessary byte and replace it with new value.\n        uiCurValue <<= 8;\n        lCurrentPosition--;\n        stream.position = lCurrentPosition;\n        uiCurValue += stream.readByte();\n\n        if (uiCurValue == value) {\n          bFound = true;\n          break;\n        }\n      }\n    }\n\n    return bFound ? lCurrentPosition : -1;\n  }; /// <summary>\n  /// Extracts Int32 value from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <returns>Extracted value.</returns>\n\n\n  ZipArchive.ReadInt32 = function (stream) {\n    var buffer = new Uint8Array(INT_SIZE);\n\n    if (stream.read(buffer, 0, INT_SIZE) != INT_SIZE) {\n      throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n    }\n\n    return Utils.bitConverterToInt32(buffer, 0);\n  }; /// <summary>\n  /// Extracts Int16 value from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <returns>Extracted value.</returns>\n\n\n  ZipArchive.ReadInt16 = function (stream) {\n    var buffer = new Uint8Array(SHORT_SIZE);\n\n    if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n      throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n    }\n\n    return Utils.bitConverterToInt16(buffer, 0);\n  }; /// <summary>\n  /// Extracts unsigned Int16 value from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <returns>Extracted value.</returns>\n\n\n  ZipArchive.ReadUInt16 = function (stream) {\n    {\n      var buffer = new Uint8Array(SHORT_SIZE);\n\n      if (stream.read(buffer, 0, SHORT_SIZE) != SHORT_SIZE) {\n        throw new DOMException(\"Unable to read value at the specified position - end of stream was reached.\");\n      }\n\n      return Utils.bitConverterToInt16(buffer, 0);\n    }\n  };\n\n  return ZipArchive;\n}();\n\nvar ZipArchiveItemHelper =\n/** @__PURE__ @class */\nfunction () {\n  function ZipArchiveItemHelper() {\n    /// <summary>\n    /// Zip header signature.\n    /// </summary>\n    this.headerSignature = 0x04034b50; /// <summary>\n    /// Indicates whether we should check Crc value when reading item's data. Check\n    /// is performed when user gets access to decompressed data for the first time.\n    /// </summary>\n\n    this.checkCrc = true; /// <summary>\n    /// Crc.\n    /// </summary>\n\n    this.crc32 = 0;\n  } /// <summary>\n  /// Read data from the stream based on the central directory.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from, stream.Position must point at just after correct file header.</param>\n\n\n  ZipArchiveItemHelper.prototype.readCentralDirectoryData = function (stream) {\n    // on the current moment we ignore \"version made by\" and \"version needed to extract\" fields.\n    stream.position += 4;\n    this.options = ZipArchive.ReadInt16(stream);\n    this.compressionMethod = ZipArchive.ReadInt16(stream);\n    this.checkCrc = this.compressionMethod != 99; //COmpression.Defalte != SecurityConstants.AES\n    //m_bCompressed = true;\n    // on the current moment we ignore \"last mod file time\" and \"last mod file date\" fields.\n\n    var lastModified = ZipArchive.ReadInt32(stream); //LastModified = ConvertToDateTime(lastModified);\n\n    this.crc32 = Utils.bitConverterToUInt32(ZipArchive.ReadInt32(stream));\n    this.compressedSize = ZipArchive.ReadInt32(stream);\n    this.originalSize = ZipArchive.ReadInt32(stream);\n    var iFileNameLength = ZipArchive.ReadInt16(stream);\n    var iExtraFieldLenth = ZipArchive.ReadInt16(stream);\n    var iCommentLength = ZipArchive.ReadInt16(stream); // on the current moment we ignore and \"disk number start\" (2 bytes),\n    // \"internal file attributes\" (2 bytes).\n\n    stream.position += 4;\n    this.externalAttributes = ZipArchive.ReadInt32(stream);\n    this.localHeaderOffset = ZipArchive.ReadInt32(stream);\n    var arrBuffer = new Uint8Array(iFileNameLength);\n    stream.read(arrBuffer, 0, iFileNameLength);\n    var m_strItemName = Utils.byteToString(arrBuffer);\n    m_strItemName = m_strItemName.replace(\"\\\\\", \"/\");\n    this.name = m_strItemName;\n    stream.position += iExtraFieldLenth + iCommentLength;\n    if (this.options != 0) this.options = 0;\n  }; /// <summary>\n  /// Reads zipped data from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n  /// <param name=\"checkCrc\">Indicates whether we should check crc value after data decompression.</param>\n\n\n  ZipArchiveItemHelper.prototype.readData = function (stream, checkCrc) {\n    if (stream.length == 0) throw new DOMException(\"stream\");\n    stream.position = this.localHeaderOffset;\n    this.checkCrc = checkCrc;\n    this.readLocalHeader(stream);\n    this.readCompressedData(stream);\n  };\n\n  ZipArchiveItemHelper.prototype.decompressData = function () {\n    if (this.compressionMethod == 8) {\n      if (this.originalSize > 0) {\n        this.decompressDataOld();\n      }\n    }\n  };\n\n  ZipArchiveItemHelper.prototype.decompressDataOld = function () {\n    var reader = new CompressedStreamReader(this.compressedStream, true);\n    var decompressedData;\n    if (this.originalSize > 0) decompressedData = new Stream(new Uint8Array(this.originalSize));\n    var arrBuffer = new Uint8Array(BufferSize);\n    var iReadBytes;\n\n    while ((iReadBytes = reader.read(arrBuffer, 0, BufferSize)) > 0) {\n      //             past = new Uint8Array(decompressedData.length);\n      // let currentBlock: Uint8Array = arrBuffer.subarray(0, iReadBytes);\n      decompressedData.write(arrBuffer.subarray(0, iReadBytes), 0, iReadBytes);\n    }\n\n    this.unCompressedStream = decompressedData.toByteArray(); //   this.originalSize = decompressedData.Length;\n    //   m_bControlStream = true;\n    //   m_streamData = decompressedData;\n    //   decompressedData.SetLength( m_lOriginalSize );\n    //   decompressedData.Capacity = ( int )m_lOriginalSize;\n\n    if (this.checkCrc) {//TODO: fix this\n      //CheckCrc(decompressedData.ToArray());\n    } //m_streamData.Position = 0;\n\n  }; /// <summary>\n  /// Extracts local header from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n\n\n  ZipArchiveItemHelper.prototype.readLocalHeader = function (stream) {\n    if (stream.length == 0) throw new DOMException(\"stream\");\n    if (ZipArchive.ReadInt32(stream) != this.headerSignature) throw new DOMException(\"Can't find local header signature - wrong file format or file is corrupt.\"); // TODO: it is good to verify data read from the central directory record,\n    // but on the current moment we simply skip it.\n\n    stream.position += 22;\n    var iNameLength = ZipArchive.ReadInt16(stream);\n    var iExtraLength = ZipArchive.ReadUInt16(stream);\n\n    if (this.compressionMethod == 99) //SecurityConstants.AES\n      {// stream.Position += iNameLength + 8;\n        // m_archive.EncryptionAlgorithm = (EncryptionAlgorithm)stream.ReadByte();\n        // m_actualCompression = new byte[2];\n        // stream.Read(m_actualCompression, 0, 2);\n      } else if (iExtraLength > 2) {\n      stream.position += iNameLength;\n      var headerVal = ZipArchive.ReadInt16(stream);\n      if (headerVal == 0x0017) //PKZipEncryptionHeader\n        throw new DOMException(\"UnSupported\");else stream.position += iExtraLength - 2;\n    } else stream.position += iNameLength + iExtraLength;\n  }; /// <summary>\n  /// Extracts compressed data from the stream.\n  /// </summary>\n  /// <param name=\"stream\">Stream to read data from.</param>\n\n\n  ZipArchiveItemHelper.prototype.readCompressedData = function (stream) {\n    var dataStream;\n\n    if (this.compressedSize > 0) {\n      var iBytesLeft = this.compressedSize;\n      dataStream = new Stream(new Uint8Array(iBytesLeft));\n      var arrBuffer = new Uint8Array(BufferSize);\n\n      while (iBytesLeft > 0) {\n        var iBytesToRead = Math.min(iBytesLeft, BufferSize);\n        if (stream.read(arrBuffer, 0, iBytesToRead) != iBytesToRead) throw new DOMException(\"End of file reached - wrong file format or file is corrupt.\");\n        dataStream.write(arrBuffer.subarray(0, iBytesToRead), 0, iBytesToRead);\n        iBytesLeft -= iBytesToRead;\n      } // if(m_archive.Password != null)\n      // {\n      //     byte[] dataBuffer = new byte[dataStream.Length];\n      //     dataBuffer = dataStream.ToArray();\n      //     dataStream=new MemoryStream( Decrypt(dataBuffer));\n      // }\n\n\n      this.compressedStream = new Uint8Array(dataStream.inputStream); // m_bControlStream = true;\n    } else if (this.compressedSize < 0) //If compression size is negative, then read until the next header signature reached.\n      {//   MemoryStream dataStream = new MemoryStream();\n        //   int bt = 0;\n        //   bool proceed=true;\n        //   while (proceed)\n        //   {\n        //       if ((bt = stream.ReadByte()) == Constants.HeaderSignatureStartByteValue)\n        //       {\n        //           stream.Position -= 1;\n        //           int headerSignature = ZipArchive.ReadInt32(stream);\n        //           if (headerSignature==Constants.CentralHeaderSignature || headerSignature==Constants.CentralHeaderSignature)\n        //           {\n        //               proceed = false;\n        //           }\n        //           stream.Position -= 3;\n        //       }\n        //       if (proceed)\n        //           dataStream.WriteByte((byte)bt);\n        //   }\n        //   m_streamData = dataStream;\n        //   m_lCompressedSize = m_streamData.Length;\n        //   m_bControlStream = true;\n      } else if (this.compressedSize == 0) {//  m_streamData = new MemoryStream();\n    }\n  };\n\n  return ZipArchiveItemHelper;\n}();\n/**\n * Class represent unique ZipArchive item\n * ```typescript\n * let archiveItem = new ZipArchiveItem(archive, 'directoryName\\fileName.txt');\n * ```\n */\n\n\nvar ZipArchiveItem =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * constructor for creating {ZipArchiveItem} instance\n   * @param {Blob|ArrayBuffer} data file data\n   * @param {itemName} itemName absolute file path\n   */\n  function ZipArchiveItem(data, itemName) {\n    if (data === null || data === undefined) {\n      throw new Error('ArgumentException: data cannot be null or undefined');\n    }\n\n    if (itemName === null || itemName === undefined) {\n      throw new Error('ArgumentException: string cannot be null or undefined');\n    }\n\n    if (itemName.length === 0) {\n      throw new Error('string cannot be empty');\n    }\n\n    this.data = data;\n    this.name = itemName;\n  }\n\n  Object.defineProperty(ZipArchiveItem.prototype, \"dataStream\", {\n    get: function () {\n      return this.decompressedStream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ZipArchiveItem.prototype, \"name\", {\n    /**\n     * Get the name of archive item\n     * @returns string\n     */\n    get: function () {\n      return this.fileName;\n    },\n\n    /**\n     * Set the name of archive item\n     * @param  {string} value\n     */\n    set: function (value) {\n      this.fileName = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n  ZipArchiveItem.prototype.destroy = function () {\n    this.fileName = undefined;\n    this.data = undefined;\n  };\n\n  return ZipArchiveItem;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n\n/**\n * array literal codes\n */\n\n\nvar ARR_LITERAL_CODES = new Int16Array(286);\nvar ARR_LITERAL_LENGTHS = new Uint8Array(286);\nvar ARR_DISTANCE_CODES = new Int16Array(30);\nvar ARR_DISTANCE_LENGTHS = new Uint8Array(30);\n/**\n * represent compression stream writer\n * ```typescript\n * let compressedWriter = new CompressedStreamWriter();\n * let text: string = 'Hello world!!!';\n * compressedWriter.write(text, 0, text.length);\n * compressedWriter.close();\n * ```\n */\n\nvar CompressedStreamWriter =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  function CompressedStreamWriter(noWrap) {\n    this.pendingBuffer = new Uint8Array(1 << 16);\n    this.pendingBufLength = 0;\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.currentHash = 0;\n    this.matchStart = 0;\n    this.matchLength = 0;\n    this.matchPrevAvail = false;\n    this.blockStart = 0;\n    this.stringStart = 0;\n    this.lookAhead = 0;\n    this.totalBytesIn = 0;\n    this.inputOffset = 0;\n    this.inputEnd = 0;\n    this.windowSize = 1 << 15;\n    this.windowMask = this.windowSize - 1;\n    this.hashSize = 1 << 15;\n    this.hashMask = this.hashSize - 1;\n    this.hashShift = Math.floor((15 + 3 - 1) / 3);\n    this.maxDist = this.windowSize - 262;\n    this.checkSum = 1;\n    this.noWrap = false;\n\n    if (!CompressedStreamWriter.isHuffmanTreeInitiated) {\n      CompressedStreamWriter.initHuffmanTree();\n      CompressedStreamWriter.isHuffmanTreeInitiated = true;\n    }\n\n    this.treeLiteral = new CompressorHuffmanTree(this, 286, 257, 15);\n    this.treeDistances = new CompressorHuffmanTree(this, 30, 1, 15);\n    this.treeCodeLengths = new CompressorHuffmanTree(this, 19, 4, 7);\n    this.arrDistances = new Uint16Array(1 << 14);\n    this.arrLiterals = new Uint8Array(1 << 14);\n    this.stream = [];\n    this.dataWindow = new Uint8Array(2 * this.windowSize);\n    this.hashHead = new Int16Array(this.hashSize);\n    this.hashPrevious = new Int16Array(this.windowSize);\n    this.blockStart = this.stringStart = 1;\n    this.noWrap = noWrap;\n\n    if (!noWrap) {\n      this.writeZLibHeader();\n    }\n  }\n\n  Object.defineProperty(CompressedStreamWriter.prototype, \"compressedData\", {\n    /**\n     * get compressed data\n     */\n    get: function () {\n      return this.stream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressedStreamWriter.prototype, \"getCompressedString\", {\n    get: function () {\n      var compressedString = '';\n\n      if (this.stream !== undefined) {\n        for (var i = 0; i < this.stream.length; i++) {\n          compressedString += String.fromCharCode.apply(null, this.stream[i]);\n        }\n      }\n\n      return compressedString;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Compresses data and writes it to the stream.\n   * @param {Uint8Array} data - data to compress\n   * @param {number} offset - offset in data\n   * @param {number} length - length of the data\n   * @returns {void}\n   */\n\n  CompressedStreamWriter.prototype.write = function (data, offset, length) {\n    if (data === undefined || data === null) {\n      throw new Error('ArgumentException: data cannot null or undefined');\n    }\n\n    var end = offset + length;\n\n    if (0 > offset || offset > end || end > data.length) {\n      throw new Error('ArgumentOutOfRangeException: Offset or length is incorrect');\n    }\n\n    if (typeof data === 'string') {\n      var encode = new Encoding(false);\n      encode.type = 'Utf8';\n      data = new Uint8Array(encode.getBytes(data, 0, data.length));\n      end = offset + data.length;\n    }\n\n    this.inputBuffer = data;\n    this.inputOffset = offset;\n    this.inputEnd = end;\n\n    if (!this.noWrap) {\n      this.checkSum = ChecksumCalculator.checksumUpdate(this.checkSum, this.inputBuffer, this.inputOffset, end);\n    }\n\n    while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0)) {\n      this.pendingBufferFlush();\n      this.compressData(false);\n    }\n  };\n  /**\n   * write ZLib header to the compressed data\n   * @return {void}\n   */\n\n\n  CompressedStreamWriter.prototype.writeZLibHeader = function () {\n    /* Initialize header.*/\n    var headerDate = 8 + (7 << 4) << 8;\n    /* Save compression level.*/\n\n    headerDate |= (5 >> 2 & 3) << 6;\n    /* Align header.*/\n\n    headerDate += 31 - headerDate % 31;\n    /* Write header to stream.*/\n\n    this.pendingBufferWriteShortBytes(headerDate);\n  };\n  /**\n   *  Write Most Significant Bytes in to stream\n   * @param {number} s - check sum value\n   */\n\n\n  CompressedStreamWriter.prototype.pendingBufferWriteShortBytes = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n    this.pendingBuffer[this.pendingBufLength++] = s;\n  };\n\n  CompressedStreamWriter.prototype.compressData = function (finish) {\n    var success;\n\n    do {\n      this.fillWindow();\n      var canFlush = finish && this.inputEnd === this.inputOffset;\n      success = this.compressSlow(canFlush, finish);\n    } while (this.pendingBufLength === 0 && success);\n\n    return success;\n  };\n\n  CompressedStreamWriter.prototype.compressSlow = function (flush, finish) {\n    if (this.lookAhead < 262 && !flush) {\n      return false;\n    }\n\n    while (this.lookAhead >= 262 || flush) {\n      if (this.lookAhead === 0) {\n        return this.lookAheadCompleted(finish);\n      }\n\n      if (this.stringStart >= 2 * this.windowSize - 262) {\n        this.slideWindow();\n      }\n\n      var prevMatch = this.matchStart;\n      var prevLen = this.matchLength;\n\n      if (this.lookAhead >= 3) {\n        this.discardMatch();\n      }\n\n      if (prevLen >= 3 && this.matchLength <= prevLen) {\n        prevLen = this.matchPreviousBest(prevMatch, prevLen);\n      } else {\n        this.matchPreviousAvailable();\n      }\n\n      if (this.bufferPosition >= 1 << 14) {\n        return this.huffmanIsFull(finish);\n      }\n    }\n\n    return true;\n  };\n\n  CompressedStreamWriter.prototype.discardMatch = function () {\n    var hashHead = this.insertString();\n\n    if (hashHead !== 0 && this.stringStart - hashHead <= this.maxDist && this.findLongestMatch(hashHead)) {\n      if (this.matchLength <= 5 && this.matchLength === 3 && this.stringStart - this.matchStart > 4096) {\n        this.matchLength = 3 - 1;\n      }\n    }\n  };\n\n  CompressedStreamWriter.prototype.matchPreviousAvailable = function () {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = true;\n    this.stringStart++;\n    this.lookAhead--;\n  };\n\n  CompressedStreamWriter.prototype.matchPreviousBest = function (prevMatch, prevLen) {\n    this.huffmanTallyDist(this.stringStart - 1 - prevMatch, prevLen);\n    prevLen -= 2;\n\n    do {\n      this.stringStart++;\n      this.lookAhead--;\n\n      if (this.lookAhead >= 3) {\n        this.insertString();\n      }\n    } while (--prevLen > 0);\n\n    this.stringStart++;\n    this.lookAhead--;\n    this.matchPrevAvail = false;\n    this.matchLength = 3 - 1;\n    return prevLen;\n  };\n\n  CompressedStreamWriter.prototype.lookAheadCompleted = function (finish) {\n    if (this.matchPrevAvail) {\n      this.huffmanTallyLit(this.dataWindow[this.stringStart - 1] & 0xff);\n    }\n\n    this.matchPrevAvail = false;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, this.stringStart - this.blockStart, finish);\n    this.blockStart = this.stringStart;\n    return false;\n  };\n\n  CompressedStreamWriter.prototype.huffmanIsFull = function (finish) {\n    var len = this.stringStart - this.blockStart;\n\n    if (this.matchPrevAvail) {\n      len--;\n    }\n\n    var lastBlock = finish && this.lookAhead === 0 && !this.matchPrevAvail;\n    this.huffmanFlushBlock(this.dataWindow, this.blockStart, len, lastBlock);\n    this.blockStart += len;\n    return !lastBlock;\n  };\n\n  CompressedStreamWriter.prototype.fillWindow = function () {\n    if (this.stringStart >= this.windowSize + this.maxDist) {\n      this.slideWindow();\n    }\n\n    while (this.lookAhead < 262 && this.inputOffset < this.inputEnd) {\n      var more = 2 * this.windowSize - this.lookAhead - this.stringStart;\n\n      if (more > this.inputEnd - this.inputOffset) {\n        more = this.inputEnd - this.inputOffset;\n      }\n\n      this.dataWindow.set(this.inputBuffer.subarray(this.inputOffset, this.inputOffset + more), this.stringStart + this.lookAhead);\n      this.inputOffset += more;\n      this.totalBytesIn += more;\n      this.lookAhead += more;\n    }\n\n    if (this.lookAhead >= 3) {\n      this.updateHash();\n    }\n  };\n\n  CompressedStreamWriter.prototype.slideWindow = function () {\n    this.dataWindow.set(this.dataWindow.subarray(this.windowSize, this.windowSize + this.windowSize), 0);\n    this.matchStart -= this.windowSize;\n    this.stringStart -= this.windowSize;\n    this.blockStart -= this.windowSize;\n\n    for (var i = 0; i < this.hashSize; ++i) {\n      var m = this.hashHead[i] & 0xffff;\n      this.hashHead[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n\n    for (var i = 0; i < this.windowSize; i++) {\n      var m = this.hashPrevious[i] & 0xffff;\n      this.hashPrevious[i] = m >= this.windowSize ? m - this.windowSize : 0;\n    }\n  };\n\n  CompressedStreamWriter.prototype.insertString = function () {\n    var match;\n    var hash = (this.currentHash << this.hashShift ^ this.dataWindow[this.stringStart + (3 - 1)]) & this.hashMask;\n    this.hashPrevious[this.stringStart & this.windowMask] = match = this.hashHead[hash];\n    this.hashHead[hash] = this.stringStart;\n    this.currentHash = hash;\n    return match & 0xffff;\n  };\n\n  CompressedStreamWriter.prototype.findLongestMatch = function (curMatch) {\n    var chainLen = 4096;\n    var niceLen = 258;\n    var scan = this.stringStart;\n    var match;\n    var bestEnd = this.stringStart + this.matchLength;\n    var bestLength = Math.max(this.matchLength, 3 - 1);\n    var limit = Math.max(this.stringStart - this.maxDist, 0);\n    var stringEnd = this.stringStart + 258 - 1;\n    var scanEnd1 = this.dataWindow[bestEnd - 1];\n    var scanEnd = this.dataWindow[bestEnd];\n    var data = this.dataWindow;\n\n    if (bestLength >= 32) {\n      chainLen >>= 2;\n    }\n\n    if (niceLen > this.lookAhead) {\n      niceLen = this.lookAhead;\n    }\n\n    do {\n      if (data[curMatch + bestLength] !== scanEnd || data[curMatch + bestLength - 1] !== scanEnd1 || data[curMatch] !== data[scan] || data[curMatch + 1] !== data[scan + 1]) {\n        continue;\n      }\n\n      match = curMatch + 2;\n      scan += 2;\n      /* tslint:disable */\n\n      while (data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && data[++scan] === data[++match] && scan < stringEnd) {\n        /* tslint:disable */\n      }\n\n      if (scan > bestEnd) {\n        this.matchStart = curMatch;\n        bestEnd = scan;\n        bestLength = scan - this.stringStart;\n\n        if (bestLength >= niceLen) {\n          break;\n        }\n\n        scanEnd1 = data[bestEnd - 1];\n        scanEnd = data[bestEnd];\n      }\n\n      scan = this.stringStart;\n    } while ((curMatch = this.hashPrevious[curMatch & this.windowMask] & 0xffff) > limit && --chainLen !== 0);\n\n    this.matchLength = Math.min(bestLength, this.lookAhead);\n    return this.matchLength >= 3;\n  };\n\n  CompressedStreamWriter.prototype.updateHash = function () {\n    this.currentHash = this.dataWindow[this.stringStart] << this.hashShift ^ this.dataWindow[this.stringStart + 1];\n  };\n\n  CompressedStreamWriter.prototype.huffmanTallyLit = function (literal) {\n    this.arrDistances[this.bufferPosition] = 0;\n    this.arrLiterals[this.bufferPosition++] = literal;\n    this.treeLiteral.codeFrequencies[literal]++;\n    return this.bufferPosition >= 1 << 14;\n  };\n\n  CompressedStreamWriter.prototype.huffmanTallyDist = function (dist, len) {\n    this.arrDistances[this.bufferPosition] = dist;\n    this.arrLiterals[this.bufferPosition++] = len - 3;\n    var lc = this.huffmanLengthCode(len - 3);\n    this.treeLiteral.codeFrequencies[lc]++;\n\n    if (lc >= 265 && lc < 285) {\n      this.extraBits += Math.floor((lc - 261) / 4);\n    }\n\n    var dc = this.huffmanDistanceCode(dist - 1);\n    this.treeDistances.codeFrequencies[dc]++;\n\n    if (dc >= 4) {\n      this.extraBits += Math.floor(dc / 2 - 1);\n    }\n\n    return this.bufferPosition >= 1 << 14;\n  };\n\n  CompressedStreamWriter.prototype.huffmanFlushBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.treeLiteral.codeFrequencies[256]++;\n    this.treeLiteral.buildTree();\n    this.treeDistances.buildTree();\n    this.treeLiteral.calculateBLFreq(this.treeCodeLengths);\n    this.treeDistances.calculateBLFreq(this.treeCodeLengths);\n    this.treeCodeLengths.buildTree();\n    var blTreeCodes = 4;\n\n    for (var i = 18; i > blTreeCodes; i--) {\n      if (this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[i]] > 0) {\n        blTreeCodes = i + 1;\n      }\n    }\n\n    var opt_len = 14 + blTreeCodes * 3 + this.treeCodeLengths.getEncodedLength() + this.treeLiteral.getEncodedLength() + this.treeDistances.getEncodedLength() + this.extraBits;\n    var static_len = this.extraBits;\n\n    for (var i = 0; i < 286; i++) {\n      static_len += this.treeLiteral.codeFrequencies[i] * ARR_LITERAL_LENGTHS[i];\n    }\n\n    for (var i = 0; i < 30; i++) {\n      static_len += this.treeDistances.codeFrequencies[i] * ARR_DISTANCE_LENGTHS[i];\n    }\n\n    if (opt_len >= static_len) {\n      // Force static trees.\n      opt_len = static_len;\n    }\n\n    if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {\n      this.huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);\n    } else if (opt_len == static_len) {\n      // Encode with static tree.\n      this.pendingBufferWriteBits((1 << 1) + (lastBlock ? 1 : 0), 3);\n      this.treeLiteral.setStaticCodes(ARR_LITERAL_CODES, ARR_LITERAL_LENGTHS);\n      this.treeDistances.setStaticCodes(ARR_DISTANCE_CODES, ARR_DISTANCE_LENGTHS);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    } else {\n      this.pendingBufferWriteBits((2 << 1) + (lastBlock ? 1 : 0), 3);\n      this.huffmanSendAllTrees(blTreeCodes);\n      this.huffmanCompressBlock();\n      this.huffmanReset();\n    }\n  };\n\n  CompressedStreamWriter.prototype.huffmanFlushStoredBlock = function (stored, storedOffset, storedLength, lastBlock) {\n    this.pendingBufferWriteBits((0 << 1) + (lastBlock ? 1 : 0), 3);\n    this.pendingBufferAlignToByte();\n    this.pendingBufferWriteShort(storedLength);\n    this.pendingBufferWriteShort(~storedLength);\n    this.pendingBufferWriteByteBlock(stored, storedOffset, storedLength);\n    this.huffmanReset();\n  };\n\n  CompressedStreamWriter.prototype.huffmanLengthCode = function (len) {\n    if (len === 255) {\n      return 285;\n    }\n\n    var code = 257;\n\n    while (len >= 8) {\n      code += 4;\n      len >>= 1;\n    }\n\n    return code + len;\n  };\n\n  CompressedStreamWriter.prototype.huffmanDistanceCode = function (distance) {\n    var code = 0;\n\n    while (distance >= 4) {\n      code += 2;\n      distance >>= 1;\n    }\n\n    return code + distance;\n  };\n\n  CompressedStreamWriter.prototype.huffmanSendAllTrees = function (blTreeCodes) {\n    this.treeCodeLengths.buildCodes();\n    this.treeLiteral.buildCodes();\n    this.treeDistances.buildCodes();\n    this.pendingBufferWriteBits(this.treeLiteral.treeLength - 257, 5);\n    this.pendingBufferWriteBits(this.treeDistances.treeLength - 1, 5);\n    this.pendingBufferWriteBits(blTreeCodes - 4, 4);\n\n    for (var rank = 0; rank < blTreeCodes; rank++) {\n      this.pendingBufferWriteBits(this.treeCodeLengths.codeLengths[CompressorHuffmanTree.huffCodeLengthOrders[rank]], 3);\n    }\n\n    this.treeLiteral.writeTree(this.treeCodeLengths);\n    this.treeDistances.writeTree(this.treeCodeLengths);\n  };\n\n  CompressedStreamWriter.prototype.huffmanReset = function () {\n    this.bufferPosition = 0;\n    this.extraBits = 0;\n    this.treeLiteral.reset();\n    this.treeDistances.reset();\n    this.treeCodeLengths.reset();\n  };\n\n  CompressedStreamWriter.prototype.huffmanCompressBlock = function () {\n    for (var i = 0; i < this.bufferPosition; i++) {\n      var literalLen = this.arrLiterals[i] & 255;\n      var dist = this.arrDistances[i];\n\n      if (dist-- !== 0) {\n        var lc = this.huffmanLengthCode(literalLen);\n        this.treeLiteral.writeCodeToStream(lc);\n        var bits = Math.floor((lc - 261) / 4);\n\n        if (bits > 0 && bits <= 5) {\n          this.pendingBufferWriteBits(literalLen & (1 << bits) - 1, bits);\n        }\n\n        var dc = this.huffmanDistanceCode(dist);\n        this.treeDistances.writeCodeToStream(dc);\n        bits = Math.floor(dc / 2 - 1);\n\n        if (bits > 0) {\n          this.pendingBufferWriteBits(dist & (1 << bits) - 1, bits);\n        }\n      } else {\n        this.treeLiteral.writeCodeToStream(literalLen);\n      }\n    }\n\n    this.treeLiteral.writeCodeToStream(256);\n  };\n  /**\n   * write bits in to internal buffer\n   * @param {number} b - source of bits\n   * @param {number} count - count of bits to write\n   */\n\n\n  CompressedStreamWriter.prototype.pendingBufferWriteBits = function (b, count) {\n    var uint = new Uint32Array(1);\n    uint[0] = this.pendingBufCache | b << this.pendingBufBitsInCache;\n    this.pendingBufCache = uint[0];\n    this.pendingBufBitsInCache += count;\n    this.pendingBufferFlushBits();\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferFlush = function (isClose) {\n    this.pendingBufferFlushBits();\n\n    if (this.pendingBufLength > 0) {\n      var array = new Uint8Array(this.pendingBufLength);\n      array.set(this.pendingBuffer.subarray(0, this.pendingBufLength), 0);\n      this.stream.push(array);\n    }\n\n    this.pendingBufLength = 0;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferFlushBits = function () {\n    var result = 0;\n\n    while (this.pendingBufBitsInCache >= 8 && this.pendingBufLength < 1 << 16) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n      this.pendingBufCache >>= 8;\n      this.pendingBufBitsInCache -= 8;\n      result++;\n    }\n\n    return result;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferWriteByteBlock = function (data, offset, length) {\n    var array = data.subarray(offset, offset + length);\n    this.pendingBuffer.set(array, this.pendingBufLength);\n    this.pendingBufLength += length;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferWriteShort = function (s) {\n    this.pendingBuffer[this.pendingBufLength++] = s;\n    this.pendingBuffer[this.pendingBufLength++] = s >> 8;\n  };\n\n  CompressedStreamWriter.prototype.pendingBufferAlignToByte = function () {\n    if (this.pendingBufBitsInCache > 0) {\n      this.pendingBuffer[this.pendingBufLength++] = this.pendingBufCache;\n    }\n\n    this.pendingBufCache = 0;\n    this.pendingBufBitsInCache = 0;\n  };\n  /**\n   * Huffman Tree literal calculation\n   * @private\n   */\n\n\n  CompressedStreamWriter.initHuffmanTree = function () {\n    var i = 0;\n\n    while (i < 144) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x030 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    while (i < 256) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x190 - 144 + i << 7);\n      ARR_LITERAL_LENGTHS[i++] = 9;\n    }\n\n    while (i < 280) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x000 - 256 + i << 9);\n      ARR_LITERAL_LENGTHS[i++] = 7;\n    }\n\n    while (i < 286) {\n      ARR_LITERAL_CODES[i] = CompressorHuffmanTree.bitReverse(0x0c0 - 280 + i << 8);\n      ARR_LITERAL_LENGTHS[i++] = 8;\n    }\n\n    for (i = 0; i < 30; i++) {\n      ARR_DISTANCE_CODES[i] = CompressorHuffmanTree.bitReverse(i << 11);\n      ARR_DISTANCE_LENGTHS[i] = 5;\n    }\n  };\n  /**\n   * close the stream and write all pending buffer in to stream\n   * @returns {void}\n   */\n\n\n  CompressedStreamWriter.prototype.close = function () {\n    do {\n      this.pendingBufferFlush(true);\n\n      if (!this.compressData(true)) {\n        this.pendingBufferFlush(true);\n        this.pendingBufferAlignToByte();\n\n        if (!this.noWrap) {\n          this.pendingBufferWriteShortBytes(this.checkSum >> 16);\n          this.pendingBufferWriteShortBytes(this.checkSum & 0xffff);\n        }\n\n        this.pendingBufferFlush(true);\n      }\n    } while (!(this.inputEnd === this.inputOffset) || !(this.pendingBufLength === 0));\n  };\n  /**\n   * release allocated un-managed resource\n   * @returns {void}\n   */\n\n\n  CompressedStreamWriter.prototype.destroy = function () {\n    this.stream = [];\n    this.stream = undefined;\n    this.pendingBuffer = undefined;\n    this.treeLiteral = undefined;\n    this.treeDistances = undefined;\n    this.treeCodeLengths = undefined;\n    this.arrLiterals = undefined;\n    this.arrDistances = undefined;\n    this.hashHead = undefined;\n    this.hashPrevious = undefined;\n    this.dataWindow = undefined;\n    this.inputBuffer = undefined;\n    this.pendingBufLength = undefined;\n    this.pendingBufCache = undefined;\n    this.pendingBufBitsInCache = undefined;\n    this.bufferPosition = undefined;\n    this.extraBits = undefined;\n    this.currentHash = undefined;\n    this.matchStart = undefined;\n    this.matchLength = undefined;\n    this.matchPrevAvail = undefined;\n    this.blockStart = undefined;\n    this.stringStart = undefined;\n    this.lookAhead = undefined;\n    this.totalBytesIn = undefined;\n    this.inputOffset = undefined;\n    this.inputEnd = undefined;\n    this.windowSize = undefined;\n    this.windowMask = undefined;\n    this.hashSize = undefined;\n    this.hashMask = undefined;\n    this.hashShift = undefined;\n    this.maxDist = undefined;\n    this.checkSum = undefined;\n    this.noWrap = undefined;\n  };\n\n  CompressedStreamWriter.isHuffmanTreeInitiated = false;\n  return CompressedStreamWriter;\n}();\n/**\n * represent the Huffman Tree\n */\n\n\nvar CompressorHuffmanTree =\n/** @__PURE__ @class */\nfunction () {\n  /**\n   * Create new Huffman Tree\n   * @param {CompressedStreamWriter} writer instance\n   * @param {number} elementCount - element count\n   * @param {number} minCodes - minimum count\n   * @param {number} maxLength - maximum count\n   */\n  function CompressorHuffmanTree(writer, elementCount, minCodes, maxLength) {\n    this.writer = writer;\n    this.codeMinCount = minCodes;\n    this.maxLength = maxLength;\n    this.codeFrequency = new Uint16Array(elementCount);\n    this.lengthCount = new Int32Array(maxLength);\n  }\n\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"treeLength\", {\n    get: function () {\n      return this.codeCount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeLengths\", {\n    get: function () {\n      return this.codeLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CompressorHuffmanTree.prototype, \"codeFrequencies\", {\n    get: function () {\n      return this.codeFrequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CompressorHuffmanTree.prototype.setStaticCodes = function (codes, lengths) {\n    var temp = new Int16Array(codes.length);\n    temp.set(codes, 0);\n    this.codes = temp;\n    var lengthTemp = new Uint8Array(lengths.length);\n    lengthTemp.set(lengths, 0);\n    this.codeLength = lengthTemp;\n  };\n  /**\n   * reset all code data in tree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.reset = function () {\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      this.codeFrequency[i] = 0;\n    }\n\n    this.codes = undefined;\n    this.codeLength = undefined;\n  };\n  /**\n   * write code to the compressor output stream\n   * @param {number} code - code to be written\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.writeCodeToStream = function (code) {\n    this.writer.pendingBufferWriteBits(this.codes[code] & 0xffff, this.codeLength[code]);\n  };\n  /**\n   * calculate code from their frequencies\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.buildCodes = function () {\n    var nextCode = new Int32Array(this.maxLength);\n    this.codes = new Int16Array(this.codeCount);\n    var code = 0;\n\n    for (var bitsCount = 0; bitsCount < this.maxLength; bitsCount++) {\n      nextCode[bitsCount] = code;\n      code += this.lengthCount[bitsCount] << 15 - bitsCount;\n    }\n\n    for (var i = 0; i < this.codeCount; i++) {\n      var bits = this.codeLength[i];\n\n      if (bits > 0) {\n        this.codes[i] = CompressorHuffmanTree.bitReverse(nextCode[bits - 1]);\n        nextCode[bits - 1] += 1 << 16 - bits;\n      }\n    }\n  };\n\n  CompressorHuffmanTree.bitReverse = function (value) {\n    return CompressorHuffmanTree.reverseBits[value & 15] << 12 | CompressorHuffmanTree.reverseBits[value >> 4 & 15] << 8 | CompressorHuffmanTree.reverseBits[value >> 8 & 15] << 4 | CompressorHuffmanTree.reverseBits[value >> 12];\n  };\n  /**\n   * calculate length of compressed data\n   * @returns {number}\n   */\n\n\n  CompressorHuffmanTree.prototype.getEncodedLength = function () {\n    var len = 0;\n\n    for (var i = 0; i < this.codeFrequency.length; i++) {\n      len += this.codeFrequency[i] * this.codeLength[i];\n    }\n\n    return len;\n  };\n  /**\n   * calculate code frequencies\n   * @param {CompressorHuffmanTree} blTree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.calculateBLFreq = function (blTree) {\n    var maxCount;\n    var minCount;\n    var count;\n    var curLen = -1;\n    var i = 0;\n\n    while (i < this.codeCount) {\n      count = 1;\n      var nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxCount = 138;\n        minCount = 3;\n      } else {\n        maxCount = 6;\n        minCount = 3;\n\n        if (curLen !== nextLen) {\n          blTree.codeFrequency[nextLen]++;\n          count = 0;\n        }\n      }\n\n      curLen = nextLen;\n      i++;\n\n      while (i < this.codeCount && curLen === this.codeLength[i]) {\n        i++;\n\n        if (++count >= maxCount) {\n          break;\n        }\n      }\n\n      if (count < minCount) {\n        blTree.codeFrequency[curLen] += count;\n      } else if (curLen !== 0) {\n        blTree.codeFrequency[16]++;\n      } else if (count <= 10) {\n        blTree.codeFrequency[17]++;\n      } else {\n        blTree.codeFrequency[18]++;\n      }\n    }\n  };\n  /**\n   * @param {CompressorHuffmanTree} blTree - write tree to output stream\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.writeTree = function (blTree) {\n    var maxRepeatCount;\n    var minRepeatCount;\n    var currentRepeatCount;\n    var currentCodeLength = -1;\n    var i = 0;\n\n    while (i < this.codeCount) {\n      currentRepeatCount = 1;\n      var nextLen = this.codeLength[i];\n\n      if (nextLen === 0) {\n        maxRepeatCount = 138;\n        minRepeatCount = 3;\n      } else {\n        maxRepeatCount = 6;\n        minRepeatCount = 3;\n\n        if (currentCodeLength !== nextLen) {\n          blTree.writeCodeToStream(nextLen);\n          currentRepeatCount = 0;\n        }\n      }\n\n      currentCodeLength = nextLen;\n      i++;\n\n      while (i < this.codeCount && currentCodeLength === this.codeLength[i]) {\n        i++;\n\n        if (++currentRepeatCount >= maxRepeatCount) {\n          break;\n        }\n      }\n\n      if (currentRepeatCount < minRepeatCount) {\n        while (currentRepeatCount-- > 0) {\n          blTree.writeCodeToStream(currentCodeLength);\n        }\n      } else if (currentCodeLength !== 0) {\n        blTree.writeCodeToStream(16);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 2);\n      } else if (currentRepeatCount <= 10) {\n        blTree.writeCodeToStream(17);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 3, 3);\n      } else {\n        blTree.writeCodeToStream(18);\n        this.writer.pendingBufferWriteBits(currentRepeatCount - 11, 7);\n      }\n    }\n  };\n  /**\n   * Build huffman tree\n   * @returns {void}\n   */\n\n\n  CompressorHuffmanTree.prototype.buildTree = function () {\n    var codesCount = this.codeFrequency.length;\n    var arrTree = new Int32Array(codesCount);\n    var treeLength = 0;\n    var maxCount = 0;\n\n    for (var n = 0; n < codesCount; n++) {\n      var freq = this.codeFrequency[n];\n\n      if (freq !== 0) {\n        var pos = treeLength++;\n        var pPos = 0;\n\n        while (pos > 0 && this.codeFrequency[arrTree[pPos = Math.floor((pos - 1) / 2)]] > freq) {\n          arrTree[pos] = arrTree[pPos];\n          pos = pPos;\n        }\n\n        arrTree[pos] = n;\n        maxCount = n;\n      }\n    }\n\n    while (treeLength < 2) {\n      arrTree[treeLength++] = maxCount < 2 ? ++maxCount : 0;\n    }\n\n    this.codeCount = Math.max(maxCount + 1, this.codeMinCount);\n    var leafsCount = treeLength;\n    var nodesCount = leafsCount;\n    var child = new Int32Array(4 * treeLength - 2);\n    var values = new Int32Array(2 * treeLength - 1);\n\n    for (var i = 0; i < treeLength; i++) {\n      var node = arrTree[i];\n      var iIndex = 2 * i;\n      child[iIndex] = node;\n      child[iIndex + 1] = -1;\n      values[i] = this.codeFrequency[node] << 8;\n      arrTree[i] = i;\n    }\n\n    this.constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);\n    this.buildLength(child);\n  };\n\n  CompressorHuffmanTree.prototype.constructHuffmanTree = function (arrTree, treeLength, values, nodesCount, child) {\n    do {\n      var first = arrTree[0];\n      var last = arrTree[--treeLength];\n      var lastVal = values[last];\n      var pPos = 0;\n      var path = 1;\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n      var second = arrTree[0];\n      last = nodesCount++;\n      child[2 * last] = first;\n      child[2 * last + 1] = second;\n      var minDepth = Math.min(values[first] & 0xff, values[second] & 0xff);\n      values[last] = lastVal = values[first] + values[second] - minDepth + 1;\n      pPos = 0;\n      path = 1;\n      /* tslint:disable */\n\n      while (path < treeLength) {\n        if (path + 1 < treeLength && values[arrTree[path]] > values[arrTree[path + 1]]) {\n          path++;\n        }\n\n        arrTree[pPos] = arrTree[path];\n        pPos = path;\n        path = pPos * 2 + 1;\n      }\n      /* tslint:disable */\n\n\n      while ((path = pPos) > 0 && values[arrTree[pPos = Math.floor((path - 1) / 2)]] > lastVal) {\n        arrTree[path] = arrTree[pPos];\n      }\n\n      arrTree[path] = last;\n    } while (treeLength > 1);\n  };\n\n  CompressorHuffmanTree.prototype.buildLength = function (child) {\n    this.codeLength = new Uint8Array(this.codeFrequency.length);\n    var numNodes = Math.floor(child.length / 2);\n    var numLeafs = Math.floor((numNodes + 1) / 2);\n    var overflow = 0;\n\n    for (var i = 0; i < this.maxLength; i++) {\n      this.lengthCount[i] = 0;\n    }\n\n    overflow = this.calculateOptimalCodeLength(child, overflow, numNodes);\n\n    if (overflow === 0) {\n      return;\n    }\n\n    var iIncreasableLength = this.maxLength - 1;\n\n    do {\n      while (this.lengthCount[--iIncreasableLength] === 0) {\n        /* tslint:disable */\n      }\n\n      do {\n        this.lengthCount[iIncreasableLength]--;\n        this.lengthCount[++iIncreasableLength]++;\n        overflow -= 1 << this.maxLength - 1 - iIncreasableLength;\n      } while (overflow > 0 && iIncreasableLength < this.maxLength - 1);\n    } while (overflow > 0);\n\n    this.recreateTree(child, overflow, numLeafs);\n  };\n\n  CompressorHuffmanTree.prototype.recreateTree = function (child, overflow, numLeafs) {\n    this.lengthCount[this.maxLength - 1] += overflow;\n    this.lengthCount[this.maxLength - 2] -= overflow;\n    var nodePtr = 2 * numLeafs;\n\n    for (var bits = this.maxLength; bits !== 0; bits--) {\n      var n = this.lengthCount[bits - 1];\n\n      while (n > 0) {\n        var childPtr = 2 * child[nodePtr++];\n\n        if (child[childPtr + 1] === -1) {\n          this.codeLength[child[childPtr]] = bits;\n          n--;\n        }\n      }\n    }\n  };\n\n  CompressorHuffmanTree.prototype.calculateOptimalCodeLength = function (child, overflow, numNodes) {\n    var lengths = new Int32Array(numNodes);\n    lengths[numNodes - 1] = 0;\n\n    for (var i = numNodes - 1; i >= 0; i--) {\n      var childIndex = 2 * i + 1;\n\n      if (child[childIndex] !== -1) {\n        var bitLength = lengths[i] + 1;\n\n        if (bitLength > this.maxLength) {\n          bitLength = this.maxLength;\n          overflow++;\n        }\n\n        lengths[child[childIndex - 1]] = lengths[child[childIndex]] = bitLength;\n      } else {\n        var bitLength = lengths[i];\n        this.lengthCount[bitLength - 1]++;\n        this.codeLength[child[childIndex - 1]] = lengths[i];\n      }\n    }\n\n    return overflow;\n  };\n\n  CompressorHuffmanTree.reverseBits = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15];\n  CompressorHuffmanTree.huffCodeLengthOrders = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n  return CompressorHuffmanTree;\n}();\n/**\n * Checksum calculator, based on Adler32 algorithm.\n */\n\n\nvar ChecksumCalculator =\n/** @__PURE__ @class */\nfunction () {\n  function ChecksumCalculator() {}\n  /**\n   * Updates checksum by calculating checksum of the\n   * given buffer and adding it to current value.\n   * @param {number} checksum - current checksum.\n   * @param {Uint8Array} buffer - data byte array.\n   * @param {number} offset - offset in the buffer.\n   * @param {number} length - length of data to be used from the stream.\n   * @returns {number}\n   */\n\n\n  ChecksumCalculator.checksumUpdate = function (checksum, buffer, offset, length) {\n    var uint = new Uint32Array(1);\n    uint[0] = checksum;\n    var checksum_uint = uint[0];\n    var s1 = uint[0] = checksum_uint & 65535;\n    var s2 = uint[0] = checksum_uint >> ChecksumCalculator.checkSumBitOffset;\n\n    while (length > 0) {\n      var steps = Math.min(length, ChecksumCalculator.checksumIterationCount);\n      length -= steps;\n\n      while (--steps >= 0) {\n        s1 = s1 + (uint[0] = buffer[offset++] & 255);\n        s2 = s2 + s1;\n      }\n\n      s1 %= ChecksumCalculator.checksumBase;\n      s2 %= ChecksumCalculator.checksumBase;\n    }\n\n    checksum_uint = s2 << ChecksumCalculator.checkSumBitOffset | s1;\n    return checksum_uint;\n  };\n\n  ChecksumCalculator.checkSumBitOffset = 16;\n  ChecksumCalculator.checksumBase = 65521;\n  ChecksumCalculator.checksumIterationCount = 3800;\n  return ChecksumCalculator;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n\n\nvar DecompressorHuffmanTree =\n/** @__PURE__ @class */\nfunction () {\n  function DecompressorHuffmanTree(lengths) {\n    this.buildTree(lengths);\n  }\n\n  DecompressorHuffmanTree.init = function () {\n    var lengths;\n    var index; // Generate huffman tree for lengths.\n\n    lengths = new Uint8Array(288);\n    index = 0;\n\n    while (index < 144) {\n      lengths[index++] = 8;\n    }\n\n    while (index < 256) {\n      lengths[index++] = 9;\n    }\n\n    while (index < 280) {\n      lengths[index++] = 7;\n    }\n\n    while (index < 288) {\n      lengths[index++] = 8;\n    }\n\n    DecompressorHuffmanTree.m_LengthTree = new DecompressorHuffmanTree(lengths); // Generate huffman tree for distances.\n\n    lengths = new Uint8Array(32);\n    index = 0;\n\n    while (index < 32) {\n      lengths[index++] = 5;\n    }\n\n    DecompressorHuffmanTree.m_DistanceTree = new DecompressorHuffmanTree(lengths);\n  }; /// <summary>\n  /// Prepares data for generating huffman tree.\n  /// </summary>\n  /// <param name=\"blCount\">Array of counts of each code length.</param>\n  /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n  /// <param name=\"lengths\">Array of code lengths.</param>\n  /// <param name=\"treeSize\">Calculated tree size.</param>\n  /// <returns>Code.</returns>\n\n\n  DecompressorHuffmanTree.prototype.prepareData = function (blCount, nextCode, lengths) {\n    var code = 0;\n    var treeSize = 512; // Count number of codes for each code length.\n\n    for (var i = 0; i < lengths.length; i++) {\n      var length_1 = lengths[i];\n\n      if (length_1 > 0) {\n        blCount[length_1]++;\n      }\n    }\n\n    for (var bits = 1; bits <= DecompressorHuffmanTree.MAX_BITLEN; bits++) {\n      nextCode[bits] = code;\n      code += blCount[bits] << 16 - bits;\n\n      if (bits >= 10) {\n        var start = nextCode[bits] & 0x1ff80;\n        var end = code & 0x1ff80;\n        treeSize += end - start >> 16 - bits;\n      }\n    }\n    /*      if( code != 65536 )\n      throw new ZipException( \"Code lengths don't add up properly.\" );*/\n\n\n    return {\n      'code': code,\n      'treeSize': treeSize\n    };\n  }; /// <summary>\n  /// Generates huffman tree.\n  /// </summary>\n  /// <param name=\"blCount\">Array of counts of each code length.</param>\n  /// <param name=\"nextCode\">Numerical values of the smallest code for each code length.</param>\n  /// <param name=\"code\">Precalculated code.</param>\n  /// <param name=\"lengths\">Array of code lengths.</param>\n  /// <param name=\"treeSize\">Calculated size of the tree.</param>\n  /// <returns>Generated tree.</returns>\n\n\n  DecompressorHuffmanTree.prototype.treeFromData = function (blCount, nextCode, lengths, code, treeSize) {\n    var tree = new Int16Array(treeSize);\n    var pointer = 512;\n    var increment = 1 << 7;\n\n    for (var bits = DecompressorHuffmanTree.MAX_BITLEN; bits >= 10; bits--) {\n      var end = code & 0x1ff80;\n      code -= blCount[bits] << 16 - bits;\n      var start = code & 0x1ff80;\n\n      for (var i = start; i < end; i += increment) {\n        tree[Utils.bitReverse(i)] = Utils.bitConverterInt32ToInt16(-pointer << 4 | bits);\n        pointer += 1 << bits - 9;\n      }\n    }\n\n    for (var i = 0; i < lengths.length; i++) {\n      var bits = lengths[i];\n\n      if (bits == 0) {\n        continue;\n      }\n\n      code = nextCode[bits];\n      var revcode = Utils.bitReverse(code);\n\n      if (bits <= 9) {\n        do {\n          tree[revcode] = Utils.bitConverterInt32ToInt16(i << 4 | bits);\n          revcode += 1 << bits;\n        } while (revcode < 512);\n      } else {\n        var subTree = tree[revcode & 511];\n        var treeLen = 1 << (subTree & 15);\n        subTree = -(subTree >> 4);\n\n        do {\n          tree[subTree | revcode >> 9] = Utils.bitConverterInt32ToInt16(i << 4 | bits);\n          revcode += 1 << bits;\n        } while (revcode < treeLen);\n      }\n\n      nextCode[bits] = code + (1 << 16 - bits);\n    }\n\n    return tree;\n  }; /// <summary>\n  /// Builds huffman tree from array of code lengths.\n  /// </summary>\n  /// <param name=\"lengths\">Array of code lengths.</param>\n\n\n  DecompressorHuffmanTree.prototype.buildTree = function (lengths) {\n    // Count of codes for each code length.\n    var blCount = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // Numerical value of the smallest code for each code length.\n\n    var nextCode = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var prepareData = this.prepareData(blCount, nextCode, lengths);\n    this.m_Tree = this.treeFromData(blCount, nextCode, lengths, prepareData.code, prepareData.treeSize);\n  }; /// <summary>\n  /// Reads and decompresses one symbol.\n  /// </summary>\n  /// <param name=\"input\"></param>\n  /// <returns></returns>\n\n\n  DecompressorHuffmanTree.prototype.unpackSymbol = function (input) {\n    var lookahead;\n    var symbol;\n\n    if ((lookahead = input.peekBits(9)) >= 0) {\n      if ((symbol = this.m_Tree[lookahead]) >= 0) {\n        input.skipBits(symbol & 15);\n        return symbol >> 4;\n      }\n\n      var subtree = -(symbol >> 4);\n      var bitlen = symbol & 15;\n\n      if ((lookahead = input.peekBits(bitlen)) >= 0) {\n        symbol = this.m_Tree[subtree | lookahead >> 9];\n        input.skipBits(symbol & 15);\n        return symbol >> 4;\n      } else {\n        var bits = input.availableBits;\n        lookahead = input.peekBits(bits);\n        symbol = this.m_Tree[subtree | lookahead >> 9];\n\n        if ((symbol & 15) <= bits) {\n          input.skipBits(symbol & 15);\n          return symbol >> 4;\n        } else {\n          return -1;\n        }\n      }\n    } else {\n      var bits = input.availableBits;\n      lookahead = input.peekBits(bits);\n      symbol = this.m_Tree[lookahead];\n\n      if (symbol >= 0 && (symbol & 15) <= bits) {\n        input.skipBits(symbol & 15);\n        return symbol >> 4;\n      } else {\n        return -1;\n      }\n    }\n  };\n\n  Object.defineProperty(DecompressorHuffmanTree, \"lengthTree\", {\n    /// <summary>\n    /// GET huffman tree for encoding and decoding lengths.\n    /// </summary>\n    get: function () {\n      return this.m_LengthTree;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DecompressorHuffmanTree, \"distanceTree\", {\n    /// <summary>\n    /// GET huffman tree for encoding and decoding distances.\n    /// </summary>\n    get: function () {\n      return this.m_DistanceTree;\n    },\n    enumerable: true,\n    configurable: true\n  }); /// <summary>\n  /// Maximum count of bits.\n  /// </summary>\n\n  DecompressorHuffmanTree.MAX_BITLEN = 15;\n  return DecompressorHuffmanTree;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n/// <summary>\n/// Checksum calculator, based on Adler32 algorithm.\n/// </summary>\n\n\nvar ChecksumCalculator$1 =\n/** @__PURE__ @class */\nfunction () {\n  function ChecksumCalculator() {} /// <summary>\n  /// Updates checksum by calculating checksum of the\n  /// given buffer and adding it to current value.\n  /// </summary>\n  /// <param name=\"checksum\">Current checksum.</param>\n  /// <param name=\"buffer\">Data byte array.</param>\n  /// <param name=\"offset\">Offset in the buffer.</param>\n  /// <param name=\"length\">Length of data to be used from the stream.</param>\n\n\n  ChecksumCalculator.ChecksumUpdate = function (checksum, buffer, offset, length) {\n    var checkSumUInt = checksum;\n    var s1 = checkSumUInt & 65535;\n    var s2 = checkSumUInt >> this.DEF_CHECKSUM_BIT_OFFSET;\n\n    while (length > 0) {\n      var steps = Math.min(length, this.DEF_CHECKSUM_ITERATIONSCOUNT);\n      length -= steps;\n\n      while (--steps >= 0) {\n        s1 = s1 + (buffer[offset++] & 255);\n        s2 = s2 + s1;\n      }\n\n      s1 %= this.DEF_CHECKSUM_BASE;\n      s2 %= this.DEF_CHECKSUM_BASE;\n    }\n\n    checkSumUInt = s2 << this.DEF_CHECKSUM_BIT_OFFSET | s1;\n    checksum = checkSumUInt;\n  }; /// <summary>\n  /// Generates checksum by calculating checksum of the\n  /// given buffer.\n  /// </summary>\n  /// <param name=\"buffer\">Data byte array.</param>\n  /// <param name=\"offset\">Offset in the buffer.</param>\n  /// <param name=\"length\">Length of data to be used from the stream.</param>\n\n\n  ChecksumCalculator.ChecksumGenerate = function (buffer, offset, length) {\n    var result = 1;\n    ChecksumCalculator.ChecksumUpdate(result, buffer, offset, length);\n    return result;\n  }; /// <summary>\n  /// Bits offset, used in adler checksum calculation.\n  /// </summary>\n\n\n  ChecksumCalculator.DEF_CHECKSUM_BIT_OFFSET = 16; /// <summary>\n  /// Lagrest prime, less than 65535\n  /// </summary>\n\n  ChecksumCalculator.DEF_CHECKSUM_BASE = 65521; /// <summary>\n  /// Count of iteration used in calculated of the adler checksumm.\n  /// </summary>\n\n  ChecksumCalculator.DEF_CHECKSUM_ITERATIONSCOUNT = 3800;\n  return ChecksumCalculator;\n}();\n/* eslint-enable */\n\n/* eslint-disable */\n\n\nvar CompressedStreamReader =\n/** @__PURE__ @class */\nfunction () {\n  function CompressedStreamReader(stream, bNoWrap) {\n    /// <summary>\n    /// Code lengths for the code length alphabet.\n    /// </summary>\n    this.defaultHuffmanDynamicTree = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; /// <summary>\n    /// Mask for compression method to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_METHOD_MASK = 15 << 8; /// <summary>\n    /// Mask for compression info to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_INFO_MASK = 240 << 8; /// <summary>\n    /// Mask for check bits to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_FLAGS_FCHECK = 31; /// <summary>\n    /// Mask for dictionary presence to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_FLAGS_FDICT = 32; /// <summary>\n    /// Mask for compression level to be decoded from 16-bit header.\n    /// </summary>\n\n    this.DEF_HEADER_FLAGS_FLEVEL = 192; /// <summary>\n    /// Maximum size of the data window.\n    /// </summary>\n\n    this.DEF_MAX_WINDOW_SIZE = 65535; /// <summary>\n    /// Maximum length of the repeatable block.\n    /// </summary>\n\n    this.DEF_HUFFMAN_REPEATE_MAX = 258; /// <summary>\n    /// End of the block sign.\n    /// </summary>\n\n    this.DEF_HUFFMAN_END_BLOCK = 256; /// <summary>\n    /// Minimal length code.\n    /// </summary>\n\n    this.DEF_HUFFMAN_LENGTH_MINIMUMCODE = 257; /// <summary>\n    /// Maximal length code.\n    /// </summary>\n\n    this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE = 285; /// <summary>\n    /// Maximal distance code.\n    /// </summary>\n\n    this.DEF_HUFFMAN_DISTANCE_MAXIMUMCODE = 29; /// <summary>\n    /// Currently calculated checksum,\n    /// based on Adler32 algorithm.\n    /// </summary>\n\n    this.mCheckSum = 1; /// <summary>\n    /// Currently read 4 bytes.\n    /// </summary>\n\n    this.tBuffer = 0; /// <summary>\n    /// Count of bits that are in buffer.\n    /// </summary>\n\n    this.mBufferedBits = 0; /// <summary>\n    /// Temporary buffer.\n    /// </summary>\n\n    this.mTempBuffer = new Uint8Array(4); /// <summary>\n    /// 32k buffer for unpacked data.\n    /// </summary>\n\n    this.mBlockBuffer = new Uint8Array(this.DEF_MAX_WINDOW_SIZE); /// <summary>\n    /// No wrap mode.\n    /// </summary>\n\n    this.mbNoWrap = false; /// <summary>\n    /// Window size, can not be larger than 32k.\n    /// </summary>\n\n    this.mWindowSize = 0; /// <summary>\n    /// Current position in output stream.\n    /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n    /// </summary>\n\n    this.mCurrentPosition = 0; /// <summary>\n    /// Data length.\n    /// Current in-block position can be extracted by applying Int16.MaxValue mask.\n    /// </summary>\n\n    this.mDataLength = 0; /// <summary>\n    /// Specifies wheather next block can to be read.\n    /// Reading can be denied because the header of the last block have been read.\n    /// </summary>\n\n    this.mbCanReadNextBlock = true; /// <summary>\n    /// Specifies wheather user can read more data from stream.\n    /// </summary>\n\n    this.mbCanReadMoreData = true; /// <summary>\n    /// Specifies wheather checksum has been read.\n    /// </summary>\n\n    this.mbCheckSumRead = false;\n\n    if (stream == null) {\n      throw new DOMException('stream');\n    }\n\n    if (stream.length === 0) {\n      throw new DOMException('stream - string can not be empty');\n    }\n\n    DecompressorHuffmanTree.init();\n    this.mInputStream = new Stream(stream);\n    this.mbNoWrap = bNoWrap;\n\n    if (!this.mbNoWrap) {\n      this.readZLibHeader();\n    }\n\n    this.decodeBlockHeader();\n  }\n\n  Object.defineProperty(CompressedStreamReader.prototype, \"mBuffer\", {\n    get: function () {\n      return this.tBuffer;\n    },\n    set: function (value) {\n      this.tBuffer = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initializes compressor and writes ZLib header if needed.\n   * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.\n   */\n  /// <summary>\n  /// Reads specified count of bits without adjusting position.\n  /// </summary>\n  /// <param name=\"count\">Count of bits to be read.</param>\n  /// <returns>Read value.</returns>\n\n  CompressedStreamReader.prototype.peekBits = function (count) {\n    if (count < 0) {\n      throw new DOMException('count', 'Bits count can not be less than zero.');\n    }\n\n    if (count > 32) {\n      throw new DOMException('count', 'Count of bits is too large.');\n    } // If buffered data is not enough to give result,\n    // fill buffer.\n\n\n    if (this.mBufferedBits < count) {\n      this.fillBuffer();\n    } // If you want to read 4 bytes and there is partial data in\n    // buffer, than you will fail.\n\n\n    if (this.mBufferedBits < count) {\n      return -1;\n    } // Create bitmask for reading of count bits\n\n\n    var bitMask = ~(4294967295 << count);\n    var result = Utils.bitConverterUintToInt32(this.mBuffer & bitMask); //Debug.WriteLine( /*new string( ' ', 32 - mBufferedBits + (int)( ( 32 - mBufferedBits ) / 8 ) ) + BitsToString( (int)mBuffer, mBufferedBits ) + \" \" + BitsToString( result, count ) +*/ \" \" + result.ToString() );\n\n    return result;\n  };\n\n  CompressedStreamReader.prototype.fillBuffer = function () {\n    var length = 4 - (this.mBufferedBits >> 3) - ((this.mBufferedBits & 7) !== 0 ? 1 : 0);\n\n    if (length === 0) {\n      return;\n    } //TODO: fix this\n\n\n    var bytesRead = this.mInputStream.read(this.mTempBuffer, 0, length);\n\n    for (var i = 0; i < bytesRead; i++) {\n      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer | Utils.bitConverterInt32ToUint(this.mTempBuffer[i] << this.mBufferedBits));\n      this.mBufferedBits += 8;\n    } //TODO: fix this\n\n  }; /// <summary>\n  /// Skips specified count of bits.\n  /// </summary>\n  /// <param name=\"count\">Count of bits to be skipped.</param>\n\n\n  CompressedStreamReader.prototype.skipBits = function (count) {\n    if (count < 0) {\n      throw new DOMException('count', 'Bits count can not be less than zero.');\n    }\n\n    if (count === 0) {\n      return;\n    }\n\n    if (count >= this.mBufferedBits) {\n      count -= this.mBufferedBits;\n      this.mBufferedBits = 0;\n      this.mBuffer = 0; // if something left, skip it.\n\n      if (count > 0) {\n        // Skip entire bytes.\n        this.mInputStream.position += count >> 3; //TODO: fix this\n\n        count &= 7; // Skip bits.\n\n        if (count > 0) {\n          this.fillBuffer();\n          this.mBufferedBits -= count;\n          this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n        }\n      }\n    } else {\n      this.mBufferedBits -= count;\n      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n    }\n  };\n\n  Object.defineProperty(CompressedStreamReader.prototype, \"availableBits\", {\n    get: function () {\n      return this.mBufferedBits;\n    },\n    enumerable: true,\n    configurable: true\n  }); /// <summary>\n  /// Reads ZLib header with compression method and flags.\n  /// </summary>\n\n  CompressedStreamReader.prototype.readZLibHeader = function () {\n    // first 8 bits - compression Method and flags\n    // 8 other - flags\n    var header = this.readInt16(); //Debug.WriteLine( BitsToString( header ) );\n\n    if (header === -1) {\n      throw new DOMException('Header of the stream can not be read.');\n    }\n\n    if (header % 31 !== 0) {\n      throw new DOMException('Header checksum illegal');\n    }\n\n    if ((header & this.DEF_HEADER_METHOD_MASK) !== 8 << 8) {\n      throw new DOMException('Unsupported compression method.');\n    }\n\n    this.mWindowSize = Math.pow(2, ((header & this.DEF_HEADER_INFO_MASK) >> 12) + 8);\n\n    if (this.mWindowSize > 65535) {\n      throw new DOMException('Unsupported window size for deflate compression method.');\n    }\n\n    if ((header & this.DEF_HEADER_FLAGS_FDICT) >> 5 === 1) {\n      // Get dictionary.\n      throw new DOMException('Custom dictionary is not supported at the moment.');\n    }\n  }; /// <summary>\n  /// TODO: place correct comment here\n  /// </summary>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n\n\n  CompressedStreamReader.prototype.readInt16 = function () {\n    var result = this.readBits(8) << 8;\n    result |= this.readBits(8);\n    return result;\n  }; /// <summary>\n  /// Reads specified count of bits from stream.\n  /// </summary>\n  /// <param name=\"count\">Count of bits to be read.</param>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n\n\n  CompressedStreamReader.prototype.readBits = function (count) {\n    var result = this.peekBits(count);\n\n    if (result === -1) {\n      return -1;\n    }\n\n    this.mBufferedBits -= count;\n    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> count);\n    return result;\n  }; /// <summary>\n  /// Reads and decodes block of data.\n  /// </summary>\n  /// <returns>True if buffer was empty and new data was read, otherwise - False.</returns>\n\n\n  CompressedStreamReader.prototype.decodeBlockHeader = function () {\n    if (!this.mbCanReadNextBlock) {\n      return false;\n    }\n\n    var bFinalBlock = this.readBits(1);\n\n    if (bFinalBlock === -1) {\n      return false;\n    }\n\n    var blockType = this.readBits(2);\n\n    if (blockType === -1) {\n      return false;\n    }\n\n    this.mbCanReadNextBlock = bFinalBlock === 0; //      ChecksumReset();\n\n    switch (blockType) {\n      case 0:\n        // Uncompressed data\n        this.mbReadingUncompressed = true;\n        this.skipToBoundary();\n        var length_1 = this.readInt16Inverted();\n        var lengthComplement = this.readInt16Inverted();\n\n        if (length_1 !== (lengthComplement ^ 0xffff)) {\n          throw new DOMException('Wrong block length.');\n        }\n\n        if (length_1 > 65535) {\n          throw new DOMException('Uncompressed block length can not be more than 65535.');\n        }\n\n        this.mUncompressedDataLength = length_1;\n        this.mCurrentLengthTree = null;\n        this.mCurrentDistanceTree = null;\n        break;\n\n      case 1:\n        // Compressed data with fixed huffman codes.\n        this.mbReadingUncompressed = false;\n        this.mUncompressedDataLength = -1;\n        this.mCurrentLengthTree = DecompressorHuffmanTree.lengthTree;\n        this.mCurrentDistanceTree = DecompressorHuffmanTree.distanceTree;\n        break;\n\n      case 2:\n        // Compressed data with dynamic huffman codes.\n        this.mbReadingUncompressed = false;\n        this.mUncompressedDataLength = -1;\n        var trees = this.decodeDynamicHeader(this.mCurrentLengthTree, this.mCurrentDistanceTree);\n        this.mCurrentLengthTree = trees.lengthTree;\n        this.mCurrentDistanceTree = trees.distanceTree;\n        break;\n\n      default:\n        throw new DOMException('Wrong block type.');\n    }\n\n    return true;\n  }; /// <summary>\n  /// Discards left-most partially used byte.\n  /// </summary>\n\n\n  CompressedStreamReader.prototype.skipToBoundary = function () {\n    this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> (this.mBufferedBits & 7));\n    this.mBufferedBits &= ~7;\n  }; /// <summary>\n  /// TODO: place correct comment here\n  /// </summary>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n\n\n  CompressedStreamReader.prototype.readInt16Inverted = function () {\n    var result = this.readBits(8);\n    result |= this.readBits(8) << 8;\n    return result;\n  }; /// <summary>\n  /// Reades dynamic huffman codes from block header.\n  /// </summary>\n  /// <param name=\"lengthTree\">Literals/Lengths tree.</param>\n  /// <param name=\"distanceTree\">Distances tree.</param>\n\n\n  CompressedStreamReader.prototype.decodeDynamicHeader = function (lengthTree, distanceTree) {\n    var bLastSymbol = 0;\n    var iLengthsCount = this.readBits(5);\n    var iDistancesCount = this.readBits(5);\n    var iCodeLengthsCount = this.readBits(4);\n\n    if (iLengthsCount < 0 || iDistancesCount < 0 || iCodeLengthsCount < 0) {\n      throw new DOMException('Wrong dynamic huffman codes.');\n    }\n\n    iLengthsCount += 257;\n    iDistancesCount += 1;\n    var iResultingCodeLengthsCount = iLengthsCount + iDistancesCount;\n    var arrResultingCodeLengths = new Uint8Array(iResultingCodeLengthsCount);\n    var arrDecoderCodeLengths = new Uint8Array(19);\n    iCodeLengthsCount += 4;\n    var iCurrentCode = 0;\n\n    while (iCurrentCode < iCodeLengthsCount) {\n      var len = this.readBits(3);\n\n      if (len < 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      arrDecoderCodeLengths[this.defaultHuffmanDynamicTree[iCurrentCode++]] = len;\n    }\n\n    var treeInternalDecoder = new DecompressorHuffmanTree(arrDecoderCodeLengths);\n    iCurrentCode = 0;\n\n    for (;;) {\n      var symbol = void 0;\n      var bNeedBreak = false;\n      symbol = treeInternalDecoder.unpackSymbol(this);\n\n      while ((symbol & ~15) === 0) {\n        arrResultingCodeLengths[iCurrentCode++] = bLastSymbol = symbol;\n\n        if (iCurrentCode === iResultingCodeLengthsCount) {\n          bNeedBreak = true;\n          break;\n        }\n\n        symbol = treeInternalDecoder.unpackSymbol(this);\n      }\n\n      if (bNeedBreak) {\n        break;\n      }\n\n      if (symbol < 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      if (symbol >= 17) {\n        bLastSymbol = 0;\n      } else if (iCurrentCode === 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      var miRepSymbol = symbol - 16;\n      var bits = CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS[miRepSymbol];\n      var count = this.readBits(bits);\n\n      if (count < 0) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      count += CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS[miRepSymbol];\n\n      if (iCurrentCode + count > iResultingCodeLengthsCount) {\n        throw new DOMException('Wrong dynamic huffman codes.');\n      }\n\n      while (count-- > 0) {\n        arrResultingCodeLengths[iCurrentCode++] = bLastSymbol;\n      }\n\n      if (iCurrentCode === iResultingCodeLengthsCount) {\n        break;\n      }\n    }\n\n    var tempArray = new Uint8Array(iLengthsCount);\n    tempArray.set(arrResultingCodeLengths.subarray(0, iLengthsCount), 0); //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n    //Array.copy( arrResultingCodeLengths, 0, tempArray, 0, iLengthsCount );\n\n    lengthTree = new DecompressorHuffmanTree(tempArray);\n    tempArray = arrResultingCodeLengths.slice(iLengthsCount, iLengthsCount + iDistancesCount); //Array.copy( arrResultingCodeLengths, iLengthsCount, tempArray, 0, iDistancesCount );\n\n    distanceTree = new DecompressorHuffmanTree(tempArray);\n    return {\n      'lengthTree': lengthTree,\n      'distanceTree': distanceTree\n    };\n  }; /// <summary>\n  /// Decodes huffman codes.\n  /// </summary>\n  /// <returns>True if some data was read.</returns>\n\n\n  CompressedStreamReader.prototype.readHuffman = function () {\n    var free = this.DEF_MAX_WINDOW_SIZE - (this.mDataLength - this.mCurrentPosition);\n    var dataRead = false; //long maxdistance = DEF_MAX_WINDOW_SIZE >> 1;\n\n    var readdata = {}; // DEF_HUFFMAN_REPEATE_MAX - longest repeatable block, we should always reserve space for it because\n    // if we should not, we will have buffer overrun.\n\n    while (free >= this.DEF_HUFFMAN_REPEATE_MAX) {\n      var symbol = void 0;\n      symbol = this.mCurrentLengthTree.unpackSymbol(this); // Only codes 0..255 are valid independent symbols.\n\n      while ((symbol & ~0xff) === 0) {\n        readdata[(this.mDataLength + 1) % this.DEF_MAX_WINDOW_SIZE] = symbol;\n        this.mBlockBuffer[this.mDataLength++ % this.DEF_MAX_WINDOW_SIZE] = symbol;\n        dataRead = true;\n\n        if (--free < this.DEF_HUFFMAN_REPEATE_MAX) {\n          return true;\n        } //if( (mDataLength - mCurrentPosition ) < maxdistance ) return true;\n\n\n        symbol = this.mCurrentLengthTree.unpackSymbol(this);\n      }\n\n      if (symbol < this.DEF_HUFFMAN_LENGTH_MINIMUMCODE) {\n        if (symbol < this.DEF_HUFFMAN_END_BLOCK) {\n          throw new DOMException('Illegal code.');\n        }\n\n        var numDataRead = dataRead ? 1 : 0;\n        this.mbCanReadMoreData = this.decodeBlockHeader();\n        var numReadMore = this.mbCanReadMoreData ? 1 : 0;\n        return numDataRead | numReadMore ? true : false;\n      }\n\n      if (symbol > this.DEF_HUFFMAN_LENGTH_MAXIMUMCODE) {\n        throw new DOMException('Illegal repeat code length.');\n      }\n\n      var iRepeatLength = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n      var iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION[symbol - this.DEF_HUFFMAN_LENGTH_MINIMUMCODE];\n\n      if (iRepeatExtraBits > 0) {\n        var extra = this.readBits(iRepeatExtraBits);\n\n        if (extra < 0) {\n          throw new DOMException('Wrong data.');\n        }\n\n        iRepeatLength += extra;\n      } // Unpack repeat distance.\n\n\n      symbol = this.mCurrentDistanceTree.unpackSymbol(this);\n\n      if (symbol < 0 || symbol > CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE.length) {\n        throw new DOMException('Wrong distance code.');\n      }\n\n      var iRepeatDistance = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE[symbol];\n      iRepeatExtraBits = CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION[symbol];\n\n      if (iRepeatExtraBits > 0) {\n        var extra = this.readBits(iRepeatExtraBits);\n\n        if (extra < 0) {\n          throw new DOMException('Wrong data.');\n        }\n\n        iRepeatDistance += extra;\n      } // Copy data in slow repeat mode\n\n\n      for (var i = 0; i < iRepeatLength; i++) {\n        this.mBlockBuffer[this.mDataLength % this.DEF_MAX_WINDOW_SIZE] = this.mBlockBuffer[(this.mDataLength - iRepeatDistance) % this.DEF_MAX_WINDOW_SIZE];\n        this.mDataLength++;\n        free--;\n      }\n\n      dataRead = true;\n    }\n\n    return dataRead;\n  }; /// <summary>\n  /// Reads data to buffer.\n  /// </summary>\n  /// <param name=\"buffer\">Output buffer for data.</param>\n  /// <param name=\"offset\">Offset in output data.</param>\n  /// <param name=\"length\">Length of the data to be read.</param>\n  /// <returns>Count of bytes actually read.</returns>\n\n\n  CompressedStreamReader.prototype.read = function (buffer, offset, length) {\n    if (buffer == null) {\n      throw new DOMException('buffer');\n    }\n\n    if (offset < 0 || offset > buffer.length - 1) {\n      throw new DOMException('offset', 'Offset does not belong to specified buffer.');\n    }\n\n    if (length < 0 || length > buffer.length - offset) {\n      throw new DOMException('length', 'Length is illegal.');\n    }\n\n    var initialLength = length;\n\n    while (length > 0) {\n      // Read from internal buffer.\n      if (this.mCurrentPosition < this.mDataLength) {\n        // Position in buffer array.\n        var inBlockPosition = this.mCurrentPosition % this.DEF_MAX_WINDOW_SIZE; // We can not read more than we have in buffer at once,\n        // and we not read more than till the array end.\n\n        var dataToCopy = Math.min(this.DEF_MAX_WINDOW_SIZE - inBlockPosition, this.mDataLength - this.mCurrentPosition); // Reading not more, than the rest of the buffer.\n\n        dataToCopy = Math.min(dataToCopy, length); //sourceArray, sourceIndex, destinationArray, destinationIndex, length\n        // Copy data.\n        //Array.Copy( mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy );\n        //buffer.set(this.mBlockBuffer.slice(inBlockPosition, dataToCopy), offset);\n\n        Utils.arrayCopy(this.mBlockBuffer, inBlockPosition, buffer, offset, dataToCopy); // Correct position, length,\n\n        this.mCurrentPosition += dataToCopy;\n        offset += dataToCopy;\n        length -= dataToCopy;\n      } else {\n        if (!this.mbCanReadMoreData) {\n          break;\n        }\n\n        var oldDataLength = this.mDataLength;\n\n        if (!this.mbReadingUncompressed) {\n          if (!this.readHuffman()) {\n            break;\n          }\n        } else {\n          if (this.mUncompressedDataLength === 0) {\n            // If there is no more data in stream, just exit.\n            this.mbCanReadMoreData = this.decodeBlockHeader();\n\n            if (!this.mbCanReadMoreData) {\n              break;\n            }\n          } else {\n            // Position of the data end in block buffer.\n            var inBlockPosition = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;\n            var dataToRead = Math.min(this.mUncompressedDataLength, this.DEF_MAX_WINDOW_SIZE - inBlockPosition);\n            var dataRead = this.readPackedBytes(this.mBlockBuffer, inBlockPosition, dataToRead);\n\n            if (dataToRead !== dataRead) {\n              throw new DOMException('Not enough data in stream.');\n            }\n\n            this.mUncompressedDataLength -= dataRead;\n            this.mDataLength += dataRead;\n          }\n        }\n\n        if (oldDataLength < this.mDataLength) {\n          var start = oldDataLength % this.DEF_MAX_WINDOW_SIZE;\n          var end = this.mDataLength % this.DEF_MAX_WINDOW_SIZE;\n\n          if (start < end) {\n            this.checksumUpdate(this.mBlockBuffer, start, end - start);\n          } else {\n            this.checksumUpdate(this.mBlockBuffer, start, this.DEF_MAX_WINDOW_SIZE - start);\n\n            if (end > 0) {\n              this.checksumUpdate(this.mBlockBuffer, 0, end);\n            }\n          }\n        }\n      }\n    }\n\n    if (!this.mbCanReadMoreData && !this.mbCheckSumRead && !this.mbNoWrap) {\n      this.skipToBoundary();\n      var checkSum = this.readInt32(); //Debug.Assert( checkSum == mCheckSum, \"\" );\n\n      if (checkSum !== this.mCheckSum) {\n        throw new DOMException('Checksum check failed.');\n      }\n\n      this.mbCheckSumRead = true;\n    }\n\n    return initialLength - length;\n  }; /// <summary>\n  /// Reads array of bytes.\n  /// </summary>\n  /// <param name=\"buffer\">Output buffer.</param>\n  /// <param name=\"offset\">Offset in output buffer.</param>\n  /// <param name=\"length\">Length of the data to be read.</param>\n  /// <returns>Count of bytes actually read to the buffer.</returns>\n\n\n  CompressedStreamReader.prototype.readPackedBytes = function (buffer, offset, length) {\n    if (buffer == null) {\n      throw new DOMException('buffer');\n    }\n\n    if (offset < 0 || offset > buffer.length - 1) {\n      throw new DOMException('offset\", \"Offset can not be less than zero or greater than buffer length - 1.');\n    }\n\n    if (length < 0) {\n      throw new DOMException('length\", \"Length can not be less than zero.');\n    }\n\n    if (length > buffer.length - offset) {\n      throw new DOMException('length\", \"Length is too large.');\n    }\n\n    if ((this.mBufferedBits & 7) !== 0) {\n      throw new DOMException('Reading of unalligned data is not supported.');\n    }\n\n    if (length === 0) {\n      return 0;\n    }\n\n    var result = 0;\n\n    while (this.mBufferedBits > 0 && length > 0) {\n      buffer[offset++] = this.mBuffer;\n      this.mBufferedBits -= 8;\n      this.mBuffer = Utils.bitConverterInt32ToUint(this.mBuffer >>> 8);\n      length--;\n      result++;\n    }\n\n    if (length > 0) {\n      //TODO: Fix this.\n      result += this.mInputStream.read(buffer, offset, length);\n    }\n\n    return result;\n  }; /// <summary>\n  /// TODO: place correct comment here\n  /// </summary>\n  /// <returns>\n  /// TODO: place correct comment here\n  /// </returns>\n\n\n  CompressedStreamReader.prototype.readInt32 = function () {\n    var result = this.readBits(8) << 24;\n    result |= this.readBits(8) << 16;\n    result |= this.readBits(8) << 8;\n    result |= this.readBits(8);\n    return result;\n  }; /// <summary>\n  /// Updates checksum by calculating checksum of the\n  /// given buffer and adding it to current value.\n  /// </summary>\n  /// <param name=\"buffer\">Data byte array.</param>\n  /// <param name=\"offset\">Offset in the buffer.</param>\n  /// <param name=\"length\">Length of data to be used from the stream.</param>\n\n\n  CompressedStreamReader.prototype.checksumUpdate = function (buffer, offset, length) {\n    ChecksumCalculator$1.ChecksumUpdate(this.mCheckSum, buffer, offset, length);\n  };\n\n  CompressedStreamReader.DEF_REVERSE_BITS = new Uint8Array([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]); /// <summary>\n  /// Minimum count of repetions.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_MINIMUMS = [3, 3, 11]; /// <summary>\n  /// Bits, that responds for different repetion modes.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_DYNTREE_REPEAT_BITS = [2, 3, 7]; /// <summary>\n  /// Length bases.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_BASE = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]; /// <summary>\n  /// Length extended bits count.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_LENGTH_EXTENSION = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]; /// <summary>\n  /// Distance bases.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_BASE = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]; /// <summary>\n  /// Distance extanded bits count.\n  /// </summary>\n\n  CompressedStreamReader.DEF_HUFFMAN_REPEAT_DISTANCE_EXTENSION = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n  return CompressedStreamReader;\n}();\n\nvar Stream =\n/** @__PURE__ @class */\nfunction () {\n  function Stream(input) {\n    this.position = 0;\n    this.inputStream = new Uint8Array(input.buffer);\n  }\n\n  Object.defineProperty(Stream.prototype, \"length\", {\n    get: function () {\n      return this.inputStream.buffer.byteLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Stream.prototype.read = function (buffer, start, length) {\n    var temp = new Uint8Array(this.inputStream.buffer, this.position + start);\n    var data = temp.subarray(0, length);\n    buffer.set(data, 0);\n    this.position += data.byteLength;\n    return data.byteLength;\n  };\n\n  Stream.prototype.readByte = function () {\n    return this.inputStream[this.position++];\n  };\n\n  Stream.prototype.write = function (inputBuffer, offset, count) {\n    Utils.arrayCopy(inputBuffer, 0, this.inputStream, this.position + offset, count); // this.inputStream = new Uint8Array(this.inputStream.buffer, this.position + offset);\n    // this.inputStream.set(inputBuffer, offset);\n\n    this.position += count;\n  };\n\n  Stream.prototype.toByteArray = function () {\n    return new Uint8Array(this.inputStream.buffer);\n  };\n\n  return Stream;\n}();\n/* eslint-enable */\n\n/**\n * export ZipArchive class\n */\n\n\nexport { ZipArchive, ZipArchiveItemHelper, ZipArchiveItem, CompressedStreamWriter, CompressorHuffmanTree, ChecksumCalculator, Utils, DecompressorHuffmanTree, CompressedStreamReader, Stream }; //# sourceMappingURL=ej2-compression.es5.js.map","map":null,"metadata":{},"sourceType":"module"}