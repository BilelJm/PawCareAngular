{"ast":null,"code":"/**\n * Angular Component Base Module\n */\nimport { getValue, isUndefined, setValue, isNullOrUndefined, attributes, createElement } from '@syncfusion/ej2-base';\nimport { EventEmitter } from '@angular/core';\nimport { clearTemplate, registerEvents } from './util';\nvar SVG_REG = /^svg|^path|^g/;\n\nvar ComponentBase =\n/** @class */\nfunction () {\n  function ComponentBase() {\n    this.isProtectedOnChange = true;\n    this.isFormInit = true;\n  }\n\n  ComponentBase.prototype.saveChanges = function (key, newValue, oldValue) {\n    if (this.isProtectedOnChange) {\n      return;\n    }\n\n    this.oldProperties[key] = oldValue;\n    this.changedProperties[key] = newValue;\n    this.finalUpdate(); // tslint:disable-next-line:no-any\n\n    var changeTime = setTimeout(this.dataBind.bind(this));\n\n    var clearUpdate = function () {\n      clearTimeout(changeTime);\n    };\n\n    this.finalUpdate = clearUpdate;\n  };\n\n  ; // tslint:disable-next-line:no-any\n\n  ComponentBase.prototype.ngOnInit = function (isTempRef) {\n    // tslint:disable-next-line:no-any\n    var tempOnThis = isTempRef || this;\n    tempOnThis.registeredTemplate = {};\n    tempOnThis.ngBoundedEvents = {};\n    tempOnThis.isAngular = true;\n    tempOnThis.isFormInit = true;\n    /* istanbul ignore next */\n\n    if (isTempRef) {\n      this.tags = isTempRef.tags;\n    }\n\n    tempOnThis.tags = this.tags || [];\n    tempOnThis.complexTemplate = this.complexTemplate || [];\n    tempOnThis.tagObjects = [];\n    tempOnThis.ngAttr = this.getAngularAttr(tempOnThis.element);\n    /* istanbul ignore next */\n\n    tempOnThis.createElement = function (tagName, prop) {\n      //tslint:disable-next-line\n      var ele = tempOnThis.srenderer ? tempOnThis.srenderer.createElement(tagName) : createElement(tagName);\n\n      if (typeof prop === 'undefined') {\n        return ele;\n      }\n\n      ele.innerHTML = prop.innerHTML ? prop.innerHTML : '';\n\n      if (prop.className !== undefined) {\n        ele.className = prop.className;\n      }\n\n      if (prop.id !== undefined) {\n        ele.id = prop.id;\n      }\n\n      if (prop.styles !== undefined) {\n        ele.setAttribute('style', prop.styles);\n      }\n\n      if (tempOnThis.ngAttr !== undefined) {\n        ele.setAttribute(tempOnThis.ngAttr, '');\n      }\n\n      if (prop.attrs !== undefined) {\n        attributes(ele, prop.attrs);\n      }\n\n      return ele;\n    };\n\n    for (var _i = 0, _a = tempOnThis.tags; _i < _a.length; _i++) {\n      var tag = _a[_i];\n      var tagObject = {\n        instance: getValue('child' + tag.substring(0, 1).toUpperCase() + tag.substring(1), tempOnThis),\n        name: tag\n      };\n      tempOnThis.tagObjects.push(tagObject);\n    }\n\n    var complexTemplates = Object.keys(tempOnThis);\n\n    for (var i = 0; i < complexTemplates.length; i++) {\n      var compProp = getValue(complexTemplates[i], tempOnThis);\n\n      if (typeof compProp === 'object' && compProp && compProp.elementRef) {\n        if (typeof compProp === 'object' && compProp && compProp.elementRef && complexTemplates[i].indexOf('_') !== -1 && complexTemplates[i].indexOf('Ref') === -1) {\n          setValue(complexTemplates[i] + 'Ref', compProp, tempOnThis);\n        }\n\n        if (tempOnThis.viewContainerRef && !getValue(\"_viewContainerRef\", compProp.elementRef.nativeElement) && !getValue(\"propName\", compProp.elementRef.nativeElement)) {\n          setValue(\"_viewContainerRef\", tempOnThis.viewContainerRef, compProp.elementRef.nativeElement);\n          setValue(\"propName\", complexTemplates[i].replace(\"Ref\", ''), compProp.elementRef.nativeElement);\n        }\n      }\n    }\n\n    complexTemplates = Object.keys(tempOnThis);\n    complexTemplates = complexTemplates.filter(function (val) {\n      return /Ref$/i.test(val) && /\\_/i.test(val);\n    });\n\n    for (var _b = 0, complexTemplates_1 = complexTemplates; _b < complexTemplates_1.length; _b++) {\n      var tempName = complexTemplates_1[_b];\n      var propName = tempName.replace('Ref', '');\n      var val = {};\n      setValue(propName.replace('_', '.'), getValue(propName, tempOnThis), val);\n      tempOnThis.setProperties(val, true);\n    }\n  };\n\n  ComponentBase.prototype.getAngularAttr = function (ele) {\n    var attributes = ele.attributes;\n    var length = attributes.length;\n    var ngAr;\n\n    for (var i = 0; i < length; i++) {\n      /* istanbul ignore next */\n      if (/_ngcontent/g.test(attributes[i].name)) {\n        ngAr = attributes[i].name;\n      }\n    }\n\n    return ngAr;\n  };\n\n  ; // tslint:disable-next-line:no-any\n\n  ComponentBase.prototype.ngAfterViewInit = function (isTempRef) {\n    // tslint:disable-next-line:no-any\n    var tempAfterViewThis = isTempRef || this;\n    var regExp = /ejs-tab|ejs-accordion/g;\n    /* istanbul ignore next */\n\n    if (regExp.test(tempAfterViewThis.ngEle.nativeElement.outerHTML)) {\n      tempAfterViewThis.ngEle.nativeElement.style.visibility = 'hidden';\n    }\n    /**\n     * Root level template properties are not getting rendered,\n     * Due to ngonchanges not get triggered.\n     * so that we have set template value for root level template properties,\n     * for example: refer below syntax\n     * ```html\n     * <ejs-grid>\n     * <e-column></e-column>\n     * <ng-template #editSettingsTemplate></ng-template>\n     * </ejs-grid>\n     * ```\n     */\n\n\n    var templateProperties = Object.keys(tempAfterViewThis);\n    templateProperties = templateProperties.filter(function (val) {\n      return /Ref$/i.test(val);\n    });\n    var ngtempRef = tempAfterViewThis.getModuleName() === 'DocumentEditor';\n\n    for (var _i = 0, templateProperties_1 = templateProperties; _i < templateProperties_1.length; _i++) {\n      var tempName = templateProperties_1[_i];\n      var propName = tempName.replace('Ref', '');\n      setValue(propName.replace('_', '.'), getValue(propName + 'Ref', tempAfterViewThis), tempAfterViewThis);\n    } // Used setTimeout for template binding\n    // Refer Link: https://github.com/angular/angular/issues/6005\n\n\n    var appendToComponent = function (tempAfterViewThis) {\n      /* istanbul ignore else  */\n      if (typeof window !== 'undefined' && tempAfterViewThis.element || tempAfterViewThis.getModuleName().includes('btn')) {\n        tempAfterViewThis.appendTo(tempAfterViewThis.element);\n        tempAfterViewThis.ngEle.nativeElement.style.visibility = '';\n      }\n    };\n\n    if (!ngtempRef) {\n      setTimeout(function () {\n        appendToComponent(tempAfterViewThis);\n      });\n    } else {\n      appendToComponent(tempAfterViewThis);\n    }\n  }; // tslint:disable-next-line:no-any\n\n\n  ComponentBase.prototype.ngOnDestroy = function (isTempRef) {\n    // tslint:disable-next-line:no-any\n    var tempOnDestroyThis = isTempRef || this;\n    /* istanbul ignore else  */\n\n    setTimeout(function () {\n      if (typeof window !== 'undefined' && tempOnDestroyThis.element.classList.contains('e-control')) {\n        tempOnDestroyThis.destroy();\n        tempOnDestroyThis.clearTemplate(null); // removing bounded events and tagobjects from component after destroy\n\n        setTimeout(function () {\n          for (var _i = 0, _a = Object.keys(tempOnDestroyThis); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var value = tempOnDestroyThis[key];\n\n            if (value && /object/.test(typeof value) && Object.keys(value).length !== 0) {\n              if (/properties|changedProperties|childChangedProperties|oldProperties|moduleLoader/.test(key)) {\n                for (var _b = 0, _c = Object.keys(tempOnDestroyThis[key]); _b < _c.length; _b++) {\n                  var propKey = _c[_b];\n                  var propValue = value[propKey];\n\n                  if (propValue && /object/.test(typeof propValue) && Object.keys(propValue).length !== 0 && (propValue.parent || propValue.parentObj)) {\n                    tempOnDestroyThis[key][propKey] = null;\n                  }\n                }\n              } else {\n                if (value.parent || value.parentObj) {\n                  tempOnDestroyThis[key] = null;\n                }\n              }\n            }\n          }\n        });\n      }\n    });\n  }; //tslint:disable-next-line\n\n\n  ComponentBase.prototype.clearTemplate = function (templateNames, index) {\n    clearTemplate(this, templateNames, index);\n  };\n\n  ; // tslint:disable-next-line:no-any\n\n  ComponentBase.prototype.ngAfterContentChecked = function (isTempRef) {\n    // tslint:disable-next-line:no-any\n    var tempAfterContentThis = isTempRef || this;\n\n    for (var _i = 0, _a = tempAfterContentThis.tagObjects; _i < _a.length; _i++) {\n      var tagObject = _a[_i];\n\n      if (!isUndefined(tagObject.instance) && (tagObject.instance.isInitChanges || tagObject.instance.hasChanges || tagObject.instance.hasNewChildren)) {\n        if (tagObject.instance.isInitChanges) {\n          var propObj = {}; // For angular 9 compatibility\n          // Not able to get complex directive properties reference ni Onint hook\n          // So we have constructed property here and used\n\n          var complexDirProps = void 0;\n          var list = getValue('instance.list', tagObject);\n\n          if (list && list.length) {\n            complexDirProps = list[0].directivePropList;\n          }\n\n          var skip = true;\n\n          if (tempAfterContentThis.getModuleName && tempAfterContentThis.getModuleName() === 'gantt') {\n            skip = false;\n          }\n\n          if (complexDirProps && skip && complexDirProps.indexOf(tagObject.instance.propertyName) === -1) {\n            var compDirPropList = Object.keys(tagObject.instance.list[0].propCollection);\n\n            for (var h = 0; h < tagObject.instance.list.length; h++) {\n              tagObject.instance.list[h].propCollection[tagObject.instance.propertyName] = [];\n              var obj = {};\n\n              for (var k = 0; k < compDirPropList.length; k++) {\n                var complexPropName = compDirPropList[k];\n                obj[complexPropName] = tagObject.instance.list[h].propCollection[complexPropName];\n              }\n\n              var _loop_1 = function (i) {\n                var tag = tagObject.instance.list[h].tags[i];\n                var childObj = getValue('child' + tag.substring(0, 1).toUpperCase() + tag.substring(1), tagObject.instance.list[h]);\n\n                if (childObj) {\n                  var innerchildObj = tagObject.instance.list[h]['child' + tag.substring(0, 1).toUpperCase() + tag.substring(1)]; // Update the inner child tag objects\n\n                  var updateChildTag_1 = function (innerchild) {\n                    var innerLevelTag = [];\n\n                    if (innerchild) {\n                      for (var j = 0; j < innerchild.list.length; j++) {\n                        var innerTag = innerchild.list[0].tags[0];\n\n                        if (innerTag) {\n                          var innerchildTag = getValue('child' + innerTag.substring(0, 1).toUpperCase() + innerTag.substring(1), innerchild.list[j]);\n\n                          if (innerchildTag) {\n                            innerchild.list[j].tagObjects.push({\n                              instance: innerchildTag,\n                              name: innerTag\n                            });\n                            innerLevelTag.push(innerchildTag);\n                          }\n                        }\n                      }\n                    } // check for inner level tag\n\n\n                    if (innerLevelTag.length !== 0) {\n                      for (var l = 0; l < innerLevelTag.length; l++) {\n                        updateChildTag_1(innerLevelTag[l]);\n                      }\n                    }\n\n                    ;\n                  };\n\n                  updateChildTag_1(innerchildObj);\n                  tagObject.instance.list[h].tagObjects.push({\n                    instance: childObj,\n                    name: tag\n                  });\n                }\n              };\n\n              for (var i = 0; i < tagObject.instance.list[h].tags.length; i++) {\n                _loop_1(i);\n              }\n\n              tagObject.instance.list[h].propCollection[tagObject.instance.propertyName].push(obj);\n            }\n          } // End angular 9 compatibility\n\n\n          propObj[tagObject.name] = tagObject.instance.getProperties();\n          tempAfterContentThis.setProperties(propObj, tagObject.instance.isInitChanges);\n        } else {\n          /* istanbul ignore next */\n          if (tempAfterContentThis[tagObject.name].length !== tagObject.instance.list.length || /diagram|tab|DashboardLayout/.test(tempAfterContentThis.getModuleName())) {\n            tempAfterContentThis[tagObject.name] = tagObject.instance.list;\n          }\n\n          for (var _b = 0, _c = tagObject.instance.list; _b < _c.length; _b++) {\n            var list = _c[_b];\n            var curIndex = tagObject.instance.list.indexOf(list);\n            var curChild = getValue(tagObject.name, tempAfterContentThis)[curIndex];\n            var complexTemplates = Object.keys(curChild);\n            complexTemplates = complexTemplates.filter(function (val) {\n              return /Ref$/i.test(val);\n            });\n\n            if (curChild.properties && Object.keys(curChild.properties).length !== 0) {\n              for (var _d = 0, complexTemplates_2 = complexTemplates; _d < complexTemplates_2.length; _d++) {\n                var complexPropName = complexTemplates_2[_d];\n                complexPropName = complexPropName.replace(/Ref/, '');\n                curChild.properties[complexPropName] = !curChild.properties[complexPropName] ? curChild.propCollection[complexPropName] : curChild.properties[complexPropName];\n              }\n            }\n\n            if (!isUndefined(curChild) && !isUndefined(curChild.setProperties)) {\n              if (/diagram|DashboardLayout/.test(tempAfterContentThis.getModuleName())) {\n                curChild.setProperties(list.getProperties(), true);\n              } else {\n                curChild.setProperties(list.getProperties());\n              }\n            }\n\n            list.isUpdated = true;\n          }\n        }\n      }\n    }\n  };\n\n  ComponentBase.prototype.registerEvents = function (eventList) {\n    registerEvents(eventList, this);\n  };\n\n  ComponentBase.prototype.twoWaySetter = function (newVal, prop) {\n    var oldVal = getValue(prop, this.properties);\n\n    if (oldVal === newVal) {\n      return;\n    }\n\n    this.saveChanges(prop, newVal, oldVal);\n    setValue(prop, isNullOrUndefined(newVal) ? null : newVal, this.properties);\n    getValue(prop + 'Change', this).emit(newVal);\n  };\n\n  ComponentBase.prototype.addTwoWay = function (propList) {\n    var _this = this;\n\n    var _loop_2 = function (prop) {\n      getValue(prop, this_1);\n      Object.defineProperty(this_1, prop, {\n        get: function () {\n          return getValue(prop, _this.properties);\n        },\n        set: function (newVal) {\n          return _this.twoWaySetter(newVal, prop);\n        }\n      });\n      setValue(prop + 'Change', new EventEmitter(), this_1);\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, propList_1 = propList; _i < propList_1.length; _i++) {\n      var prop = propList_1[_i];\n\n      _loop_2(prop);\n    }\n  };\n\n  ComponentBase.prototype.addEventListener = function (eventName, handler) {\n    var eventObj = getValue(eventName, this);\n\n    if (!isUndefined(eventObj)) {\n      if (!this.ngBoundedEvents[eventName]) {\n        this.ngBoundedEvents[eventName] = new Map();\n      }\n\n      this.ngBoundedEvents[eventName].set(handler, eventObj.subscribe(handler));\n    }\n  };\n\n  ComponentBase.prototype.removeEventListener = function (eventName, handler) {\n    var eventObj = getValue(eventName, this);\n\n    if (!isUndefined(eventObj)) {\n      this.ngBoundedEvents[eventName].get(handler).unsubscribe();\n    }\n  };\n\n  ComponentBase.prototype.trigger = function (eventName, eventArgs, success) {\n    var eventObj = getValue(eventName, this);\n    var prevDetection = this.isProtectedOnChange;\n    this.isProtectedOnChange = false;\n\n    if (eventArgs) {\n      eventArgs.name = eventName;\n    }\n\n    if (!isUndefined(eventObj)) {\n      eventObj.next(eventArgs);\n    }\n\n    var localEventObj = getValue('local' + eventName.charAt(0).toUpperCase() + eventName.slice(1), this);\n\n    if (!isUndefined(localEventObj)) {\n      localEventObj.call(this, eventArgs);\n    }\n\n    this.isProtectedOnChange = prevDetection;\n    /* istanbul ignore else  */\n\n    if (success) {\n      this.preventChange = this.isPreventChange;\n      success.call(this, eventArgs);\n    }\n\n    this.isPreventChange = false;\n  };\n\n  return ComponentBase;\n}();\n\nexport { ComponentBase };","map":null,"metadata":{},"sourceType":"module"}