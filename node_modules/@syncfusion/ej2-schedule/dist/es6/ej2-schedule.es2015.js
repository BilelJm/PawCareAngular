import { Animation, Browser, ChildProperty, Collection, Complex, Component, Draggable, Event, EventHandler, HijriParser, Internationalization, KeyboardEvents, L10n, NotifyPropertyChanges, Property, SanitizeHtmlHelper, Touch, addClass, append, classList, cldrData, closest, compile, createElement, detach, extend, formatUnit, getDefaultDateObject, getElement, getValue, isNullOrUndefined, prepend, print, remove, removeClass, setStyleAttribute } from '@syncfusion/ej2-base';
import { Dialog, Popup, Tooltip, createSpinner, hideSpinner, isCollide, showSpinner } from '@syncfusion/ej2-popups';
import { Toolbar, TreeView } from '@syncfusion/ej2-navigations';
import { Calendar, DatePicker, DateTimePicker } from '@syncfusion/ej2-calendars';
import { DataManager, Deferred, Predicate, Query } from '@syncfusion/ej2-data';
import { Button, CheckBox, RadioButton } from '@syncfusion/ej2-buttons';
import { FormValidator, Input, NumericTextBox } from '@syncfusion/ej2-inputs';
import { DropDownList, MultiSelect } from '@syncfusion/ej2-dropdowns';
import { ListBase } from '@syncfusion/ej2-lists';
import { Workbook } from '@syncfusion/ej2-excel-export';

/**
 * Constants
 */
/** @private */
const cellClick = 'cellClick';
/** @private */
const cellDoubleClick = 'cellDoubleClick';
/** @private */
const moreEventsClick = 'moreEventsClick';
/** @private */
const select = 'select';
/** @private */
const hover = 'hover';
/** @private */
const actionBegin = 'actionBegin';
/** @private */
const actionComplete = 'actionComplete';
/** @private */
const actionFailure = 'actionFailure';
/** @private */
const navigating = 'navigating';
/** @private */
const renderCell = 'renderCell';
/** @private */
const eventClick = 'eventClick';
/** @private */
const eventRendered = 'eventRendered';
/** @private */
const dataBinding = 'dataBinding';
/** @private */
const dataBound = 'dataBound';
/** @private */
const popupOpen = 'popupOpen';
/** @private */
const popupClose = 'popupClose';
/** @private */
const dragStart = 'dragStart';
/** @private */
const drag = 'drag';
/** @private */
const dragStop = 'dragStop';
/** @private */
const resizeStart = 'resizeStart';
/** @private */
const resizing = 'resizing';
/** @private */
const resizeStop = 'resizeStop';
/** @private */
const inlineClick = 'inlineClick';
/** @private */
const cellSelect = 'cellSelect';
/**
 * Specifies schedule internal events
 */
/** @private */
const initialLoad = 'initial-load';
/** @private */
const initialEnd = 'initial-end';
/** @private */
const print$1 = 'print';
/** @private */
const dataReady = 'data-ready';
/** @private */
const eventsLoaded = 'events-loaded';
/** @private */
const contentReady = 'content-ready';
/** @private */
const scroll = 'scroll';
/** @private */
const virtualScroll = 'virtual-scroll';
/** @private */
const scrollUiUpdate = 'scroll-ui-update';
/** @private */
const uiUpdate = 'ui-update';
/** @private */
const documentClick = 'document-click';
/** @private */
const cellMouseDown = 'cell-mouse-down';

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Schedule common utilities
 */
const WEEK_LENGTH = 7;
const DEFAULT_WEEKS = 6;
const MS_PER_DAY = 86400000;
const MS_PER_MINUTE = 60000;
/**
 * Method to get height from element
 *
 * @param {Element} container Accepts the DOM element
 * @param {string} elementClass Accepts the element class
 * @returns {number} Returns the height of the element
 */
function getElementHeightFromClass(container, elementClass) {
    let height = 0;
    const el = createElement('div', { className: elementClass }).cloneNode();
    el.style.visibility = 'hidden';
    el.style.position = 'absolute';
    container.appendChild(el);
    height = el.getBoundingClientRect().height;
    remove(el);
    return height;
}
/**
 * Method to get width from element
 *
 * @param {Element} container Accepts the DOM element
 * @param {string} elementClass Accepts the element class
 * @returns {number} Returns the width of the element
 */
function getElementWidthFromClass(container, elementClass) {
    let width = 0;
    const el = createElement('div', { className: elementClass }).cloneNode();
    el.style.visibility = 'hidden';
    el.style.position = 'absolute';
    container.appendChild(el);
    width = el.getBoundingClientRect().width;
    remove(el);
    return width;
}
/**
 * Method to get translateY value
 *
 * @param {HTMLElement | Element} element Accepts the DOM element
 * @returns {number} Returns the translateY value of given element
 */
function getTranslateY(element) {
    const style = getComputedStyle(element);
    return window.WebKitCSSMatrix ?
        new WebKitCSSMatrix(style.webkitTransform).m42 : 0;
}
/**
 * Method to get translateX value
 *
 * @param {HTMLElement | Element} element Accepts the DOM element
 * @returns {number} Returns the translateX value of given element
 */
function getTranslateX(element) {
    const style = getComputedStyle(element);
    return window.WebKitCSSMatrix ?
        new WebKitCSSMatrix(style.webkitTransform).m41 : 0;
}
/**
 * Method to get week first date
 *
 * @param {Date} date Accepts the date object
 * @param {number} firstDayOfWeek Accepts the first day of week number
 * @returns {Date} Returns the date object
 */
function getWeekFirstDate(date, firstDayOfWeek) {
    const date1 = new Date(date.getTime());
    firstDayOfWeek = (firstDayOfWeek - date1.getDay() + 7 * (-1)) % 7;
    return new Date(date1.setDate(date1.getDate() + firstDayOfWeek));
}
/**
 * Method to get week last date
 *
 * @param {Date} date Accepts the date object
 * @param {number} firstDayOfWeek Accepts the first day of week number
 * @returns {Date} Returns the date object
 */
function getWeekLastDate(date, firstDayOfWeek) {
    const weekFirst = getWeekFirstDate(date, firstDayOfWeek);
    const weekLast = new Date(weekFirst.getFullYear(), weekFirst.getMonth(), weekFirst.getDate() + 6);
    return new Date(weekLast.getTime());
}
/**
 * Method to get first date of month
 *
 * @param {Date} date Accepts the date object
 * @returns {Date} Returns the date object
 */
function firstDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
}
/**
 * Method to get last date of month
 *
 * @param {Date} date Accepts the date object
 * @returns {Date} Returns the date object
 */
function lastDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
}
/**
 * Method to get week number
 *
 * @param {Date} date Accepts the date object
 * @returns {number} Returns the week number
 */
function getWeekNumber(date) {
    const date1 = new Date(date.getFullYear(), 0, 1).valueOf();
    const currentDate = new Date(date.getFullYear(), date.getMonth(), date.getDate()).valueOf();
    const dayOfYear = ((currentDate - date1 + MS_PER_DAY) / MS_PER_DAY);
    return Math.ceil(dayOfYear / 7);
}
/**
 * Method to get week middle date
 *
 * @param {Date} weekFirst Accepts the week first date object
 * @param {Date} weekLast Accepts the week last date object
 * @returns {Date} Returns the date object
 */
function getWeekMiddleDate(weekFirst, weekLast) {
    return new Date(weekLast.valueOf() - ((weekLast.valueOf() - weekFirst.valueOf()) / 2));
}
/**
 * Method to set time to date object
 *
 * @param {Date} date Accepts the date object
 * @param {number} time Accepts the milliseconds
 * @returns {Date} Returns the date object
 */
function setTime(date, time) {
    const tzOffsetBefore = date.getTimezoneOffset();
    const d = new Date(date.getTime() + time);
    const tzOffsetDiff = d.getTimezoneOffset() - tzOffsetBefore;
    date.setTime(d.getTime() + tzOffsetDiff * MS_PER_MINUTE);
    return date;
}
/**
 * Method the reset hours in date object
 *
 * @param {Date} date Accepts the date object
 * @returns {Date} Returns the date object
 */
function resetTime(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}
/**
 * Method to get milliseconds from date object
 *
 * @param {Date} date Accepts the date object
 * @returns {number} Returns the milliseconds from date object
 */
function getDateInMs(date) {
    const localOffset = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0).getTimezoneOffset();
    const dateOffset = date.getTimezoneOffset();
    const timezoneOffset = dateOffset - localOffset;
    return ((date.getTime() - new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0).getTime())
        - (timezoneOffset * 60 * 1000));
}
/**
 * Method to get date count between two dates
 *
 * @param {Date} startDate Accepts the date object
 * @param {Date} endDate Accepts the date object
 * @returns {number} Returns the date count
 */
function getDateCount(startDate, endDate) {
    return Math.ceil((endDate.getTime() - startDate.getTime()) / MS_PER_DAY);
}
/**
 * Method to add no of days in date object
 *
 * @param {Date} date Accepts the date object
 * @param {number} noOfDays Accepts the number of days count
 * @returns {Date} Returns the date object
 */
function addDays(date, noOfDays) {
    date = new Date('' + date);
    return new Date(date.setDate(date.getDate() + noOfDays));
}
/**
 * Method to add no of months in date object
 *
 * @param {Date} date Accepts the date object
 * @param {number} noOfMonths Accepts the number of month count
 * @returns {Date} Returns the date object
 */
function addMonths(date, noOfMonths) {
    date = new Date('' + date);
    const day = date.getDate();
    date.setDate(1);
    date.setMonth(date.getMonth() + noOfMonths);
    date.setDate(Math.min(day, getMaxDays(date)));
    return date;
}
/**
 * Method to add no of years in date object
 *
 * @param {Date} date Accepts the date object
 * @param {number} noOfYears Accepts the number of month count
 * @returns {Date} Returns the date object
 */
function addYears(date, noOfYears) {
    date = new Date('' + date);
    const day = date.getDate();
    date.setDate(1);
    date.setFullYear(date.getFullYear() + noOfYears);
    date.setDate(Math.min(day, getMaxDays(date)));
    return date;
}
/**
 * Method to get start and end hours
 *
 * @param {Date} date Accepts the date object
 * @param {Date} startHour Accepts the start hour date object
 * @param {Date} endHour Accepts the end hour date object
 * @returns {Object} Returns the start and end hour date objects
 */
function getStartEndHours(date, startHour, endHour) {
    const date1 = new Date(date.getTime());
    date1.setHours(startHour.getHours());
    date1.setMinutes(startHour.getMinutes());
    date1.setSeconds(startHour.getSeconds());
    let date2 = new Date(date.getTime());
    if (endHour.getHours() === 0) {
        date2 = addDays(date2, 1);
    }
    else {
        date2.setHours(endHour.getHours());
        date2.setMinutes(endHour.getMinutes());
        date2.setSeconds(endHour.getSeconds());
    }
    return { startHour: date1, endHour: date2 };
}
/**
 * Method to get month last date
 *
 * @param {Date} date Accepts the date object
 * @returns {number} Returns the month last date
 */
function getMaxDays(date) {
    return lastDateOfMonth(date).getDate();
}
/**
 * Method to get days count between two dates
 *
 * @param {Date} startDate Accepts the date object
 * @param {Date} endDate Accepts the date object
 * @returns {number} Returns the days count
 */
function getDaysCount(startDate, endDate) {
    const strTime = resetTime(new Date(startDate));
    const endTime = resetTime(new Date(endDate));
    return Math.round((endTime.getTime() - strTime.getTime()) / MS_PER_DAY);
}
/**
 * Method to get date object from date string
 *
 * @param {string} date Accepts the date string
 * @returns {Date} Returns the date object
 */
function getDateFromString(date) {
    return date.indexOf('Date') !== -1 ? new Date(parseInt(date.match(/\d+/g).toString(), 10)) :
        date.indexOf('T') !== -1 ? new Date(date) : new Date(date.replace(/-/g, '/'));
}
/**
 * Method to get scrollbar width
 *
 * @returns {number} Returns the scrollbar width
 * @private
 */
function getScrollBarWidth() {
    const divNode = createElement('div');
    let value = 0;
    divNode.style.cssText = 'width:100px;height: 100px;overflow: scroll;position: absolute;top: -9999px;';
    document.body.appendChild(divNode);
    const ratio = (devicePixelRatio) ? (devicePixelRatio.toFixed(2) === '1.10' || devicePixelRatio <= 1) ?
        Math.ceil(devicePixelRatio % 1) : Math.floor(devicePixelRatio % 1) : 0;
    value = (divNode.offsetWidth - divNode.clientWidth - ratio) | 0;
    document.body.removeChild(divNode);
    return value;
}
/**
 * Method to find the index from data collection
 *
 * @param {Object} data Accepts the data as object
 * @param {string} field Accepts the field name
 * @param {string} value Accepts the value name
 * @param {Object} event Accepts the data as object
 * @param {Object[]} resourceCollection Accepts the data collections
 * @returns {number} Returns the index number
 */
// eslint-disable-next-line max-len
function findIndexInData(data, field, value, event, resourceCollection) {
    for (let i = 0, length = data.length; i < length; i++) {
        if (data[parseInt(i.toString(), 10)][`${field}`] === value) {
            if (event) {
                const field = resourceCollection.slice(-2)[0].field;
                const res = (event[`${field}`] instanceof Array ? event[`${field}`] : [event[`${field}`]]);
                const resData = res.join(',');
                if (resData.includes(data[parseInt(i.toString(), 10)][resourceCollection.slice(-1)[0].groupIDField])) {
                    return i;
                }
            }
            else {
                return i;
            }
        }
    }
    return -1;
}
/**
 * Method to get element outer height
 *
 * @param {HTMLElement} element Accepts the DOM element
 * @returns {number} Returns the outer height of the given element
 */
function getOuterHeight(element) {
    const style = getComputedStyle(element);
    return element.offsetHeight + (parseInt(style.marginTop, 10) || 0) + (parseInt(style.marginBottom, 10) || 0);
}
/**
 * Method to remove child elements
 *
 * @param {HTMLElement | Element} element Accepts the DOM element
 * @returns {void}
 */
function removeChildren(element) {
    const elementChildren = [].slice.call(element.children);
    for (const elementChild of elementChildren) {
        element.removeChild(elementChild);
    }
}
/**
 * Method to check DST is present or not in date object
 *
 * @param {Date} date Accepts the date object
 * @returns {boolean} Returns the boolean value for either DST is present or not
 */
function isDaylightSavingTime(date) {
    const jan = new Date(date.getFullYear(), 0, 1);
    const jul = new Date(date.getFullYear(), 6, 1);
    return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
}
/**
 * Method to get UTC time value from date
 *
 * @param {Date} date Accepts the date
 * @returns {number} Returns the UTC time value
 */
function getUniversalTime(date) {
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    const milliseconds = date.getMilliseconds();
    return Date.UTC(year, month, day, hours, minutes, seconds, milliseconds);
}
/**
 * Method to check the device
 *
 * @returns {boolean} Returns the boolean value for either device is present or not.
 */
function isMobile() {
    return window.navigator.userAgent.toLowerCase().indexOf('mobi') > -1;
}
/**
 * Method to check the IPad device
 *
 * @returns {boolean} Returns the boolean value for either IPad device is present or not.
 */
function isIPadDevice() {
    return window.navigator.userAgent.toLowerCase().indexOf('ipad') > -1;
}
/**
 * Method to capitalize the first word in string
 *
 * @param {string} inputString Accepts the string value
 * @param {string} type Accepts the string type
 * @returns {string} Returns the output string
 */
function capitalizeFirstWord(inputString, type) {
    if (type === 'multiple') {
        inputString = inputString.split(' ').map((e) => e.charAt(0).toLocaleUpperCase() + e.substring(1)).join(' ');
    }
    else if (type === 'single') {
        if (inputString[0] >= '0' && inputString[0] <= '9') {
            const array = inputString.match(/[a-zA-Z]/);
            inputString = isNullOrUndefined(array) ? inputString :
                inputString.slice(0, array.index) + inputString[array.index].toLocaleUpperCase() + inputString.slice(array.index + 1);
        }
        inputString = inputString[0].toLocaleUpperCase() + inputString.slice(1);
    }
    return inputString;
}

/**
 * CSS Constants
 */
/** @private */
const ROOT = 'e-schedule';
/** @private */
const RTL = 'e-rtl';
/** @private */
const DEVICE_CLASS = 'e-device';
/** @private */
const MULTI_DRAG = 'e-multi-drag';
/** @private */
const ICON = 'e-icons';
/** @private */
const ENABLE_CLASS = 'e-enable';
/** @private */
const DISABLE_CLASS = 'e-disable';
/** @private */
const TABLE_CONTAINER_CLASS = 'e-table-container';
/** @private */
const SCHEDULE_TABLE_CLASS = 'e-schedule-table';
/** @private */
const ALLDAY_CELLS_CLASS = 'e-all-day-cells';
/** @private */
const HEADER_POPUP_CLASS = 'e-header-popup';
/** @private */
const HEADER_CALENDAR_CLASS = 'e-header-calendar';
/** @private */
const ALLDAY_ROW_CLASS = 'e-all-day-row';
/** @private */
const CONTENT_TABLE_CLASS = 'e-content-table';
/** @private */
const WORK_CELLS_CLASS = 'e-work-cells';
/** @private */
const WORK_HOURS_CLASS = 'e-work-hours';
/** @private */
const POPUP_OPEN = 'e-popup-open';
/** @private */

/** @private */
const DATE_HEADER_WRAP_CLASS = 'e-date-header-wrap';
/** @private */
const DATE_HEADER_CONTAINER_CLASS = 'e-date-header-container';
/** @private */
const HEADER_CELLS_CLASS = 'e-header-cells';
/** @private */
const HEADER_WEEK_CELLS_CLASS = 'e-header-week-cell';
/** @private */
const HEADER_MONTH_CELLS_CLASS = 'e-header-month-cell';
/** @private */
const HEADER_YEAR_CELLS_CLASS = 'e-header-year-cell';
/** @private */
const WORKDAY_CLASS = 'e-work-days';
/** @private */
const OTHERMONTH_CLASS = 'e-other-month';
/** @private */
const CURRENT_DAY_CLASS = 'e-current-day';
/** @private */
const CURRENTDATE_CLASS = 'e-current-date';
/** @private */
const CURRENT_PANEL_CLASS = 'e-current-panel';
/** @private */
const PREVIOUS_PANEL_CLASS = 'e-previous-panel';
/** @private */
const NEXT_PANEL_CLASS = 'e-next-panel';
/** @private */
const PREVIOUS_DATE_CLASS = 'e-prev';
/** @private */
const NEXT_DATE_CLASS = 'e-next';
/** @private */
const TRANSLATE_CLASS = 'e-translate';
/** @private */
const LEFT_INDENT_CLASS = 'e-left-indent';
/** @private */
const LEFT_INDENT_WRAP_CLASS = 'e-left-indent-wrap';
/** @private */
const EVENT_TABLE_CLASS = 'e-event-table';
/** @private */
const RESOURCE_LEFT_TD_CLASS = 'e-resource-left-td';
/** @private */
const RESOURCE_GROUP_CELLS_CLASS = 'e-resource-group-cells';
/** @private */
const RESOURCE_TEXT_CLASS = 'e-resource-text';
/** @private */
const RESOURCE_COLUMN_WRAP_CLASS = 'e-resource-column-wrap';
/** @private */
const RESOURCE_COLUMN_TABLE_CLASS = 'e-resource-column-table';
/** @private */
const RESOURCE_CHILD_CLASS = 'e-child-node';
/** @private */
const RESOURCE_PARENT_CLASS = 'e-parent-node';
/** @private */
const RESOURCE_EXPAND_CLASS = 'e-resource-expand';
/** @private */
const RESOURCE_COLLAPSE_CLASS = 'e-resource-collapse';
/** @private */
const RESOURCE_TREE_ICON_CLASS = 'e-resource-tree-icon';
/** @private */
const RESOURCE_CELLS_CLASS = 'e-resource-cells';
/** @private */
const TIME_CELLS_WRAP_CLASS = 'e-time-cells-wrap';
/** @private */
const TIME_CELLS_CLASS = 'e-time-cells';
/** @private */
const TIME_SLOT_CLASS = 'e-time-slots';
/** @private */
const ALTERNATE_CELLS_CLASS = 'e-alternate-cells';
/** @private */
const CURRENT_TIME_CLASS = 'e-current-time';
/** @private */
const CURRENT_TIMELINE_CLASS = 'e-current-timeline';
/** @private */
const PREVIOUS_TIMELINE_CLASS = 'e-previous-timeline';
/** @private */
const HIDE_CHILDS_CLASS = 'e-hide-childs';
/** @private */
const SCROLL_CONTAINER_CLASS = 'e-scroll-container';
/** @private */

/** @private */
const TIMELINE_WRAPPER_CLASS = 'e-timeline-wrapper';
/** @private */
const APPOINTMENT_WRAPPER_CLASS = 'e-appointment-wrapper';
/** @private */
const DAY_WRAPPER_CLASS = 'e-day-wrapper';
/** @private */
const TOOLBAR_CONTAINER = 'e-schedule-toolbar-container';
/** @private */
const RESOURCE_TOOLBAR_CONTAINER = 'e-schedule-resource-toolbar-container';
/** @private */
const HEADER_TOOLBAR = 'e-schedule-toolbar';
/** @private */
const RESOURCE_HEADER_TOOLBAR = 'e-schedule-resource-toolbar';
/** @private */
const SELECTED_CELL_CLASS = 'e-selected-cell';
/** @private */
const WEEK_NUMBER_WRAPPER_CLASS = 'e-week-number-wrapper';
/** @private */
const WEEK_NUMBER_CLASS = 'e-week-number';
/** @private */
const APPOINTMENT_WRAP_CLASS = 'e-appointment-wrap';
/** @private */
const WRAPPER_CONTAINER_CLASS = 'e-wrapper-container';
/** @private */
const APPOINTMENT_CONTAINER_CLASS = 'e-appointment-container';
/** @private */
const APPOINTMENT_CLASS = 'e-appointment';
/** @private */
const BLOCK_APPOINTMENT_CLASS = 'e-block-appointment';
/** @private */
const BLOCK_INDICATOR_CLASS = 'e-block-indicator';
/** @private */
const APPOINTMENT_BORDER = 'e-appointment-border';
/** @private */
const APPOINTMENT_DETAILS = 'e-appointment-details';
/** @private */
const SUBJECT_WRAP = 'e-subject-wrap';
/** @private */
const RESOURCE_NAME = 'e-resource-name';
/** @private */
const APPOINTMENT_TIME = 'e-time';
/** @private */
const TABLE_WRAP_CLASS = 'e-table-wrap';
/** @private */
const OUTER_TABLE_CLASS = 'e-outer-table';
/** @private */
const CONTENT_WRAP_CLASS = 'e-content-wrap';
/** @private */
const VIRTUAL_TRACK_CLASS = 'e-virtual-track';
/** @private */
const AGENDA_CELLS_CLASS = 'e-agenda-cells';
/** @private */
const AGENDA_CURRENT_DAY_CLASS = 'e-current-day';
/** @private */
const AGENDA_SELECTED_CELL = 'e-active-appointment-agenda';
/** @private */
const MONTH_HEADER_CLASS = 'e-month-header';
/** @private */
const AGENDA_HEADER_CLASS = 'e-day-date-header';
/** @private */
const AGENDA_RESOURCE_CLASS = 'e-resource-column';
/** @private */
const AGENDA_DATE_CLASS = 'e-date-column';
/** @private */
const NAVIGATE_CLASS = 'e-navigate';
/** @private */
const DATE_HEADER_CLASS = 'e-date-header';
/** @private */
const AGENDA_DAY_BORDER_CLASS = 'e-day-border';
/** @private */
const DATE_BORDER_CLASS = 'e-date-border';
/** @private */
const AGENDA_DAY_PADDING_CLASS = 'e-day-padding';
/** @private */
const DATE_TIME_CLASS = 'e-date-time';
/** @private */
const DATE_TIME_WRAPPER_CLASS = 'e-date-time-wrapper';
/** @private */
const AGENDA_EMPTY_EVENT_CLASS = 'e-empty-event';
/** @private */
const AGENDA_NO_EVENT_CLASS = 'e-no-event';
/** @private */
const APPOINTMENT_INDICATOR_CLASS = 'e-appointment-indicator';
/** @private */
const EVENT_INDICATOR_CLASS = 'e-indicator';
/** @private */
const EVENT_ICON_UP_CLASS = 'e-up-icon';
/** @private */
const EVENT_ICON_DOWN_CLASS = 'e-down-icon';
/** @private */
const EVENT_ICON_LEFT_CLASS = 'e-left-icon';
/** @private */
const EVENT_ICON_RIGHT_CLASS = 'e-right-icon';
/** @private */
const EVENT_ACTION_CLASS = 'e-event-action';
/** @private */
const NEW_EVENT_CLASS = 'e-new-event';
/** @private */
const CLONE_ELEMENT_CLASS = 'e-schedule-event-clone';
/** @private */
const MONTH_CLONE_ELEMENT_CLASS = 'e-month-event';
/** @private */
const CLONE_TIME_INDICATOR_CLASS = 'e-clone-time-indicator';
/** @private */
const DRAG_CLONE_CLASS = 'e-drag-clone';
/** @private */
const EVENT_RESIZE_CLASS = 'e-event-resize';
/** @private */
const RESIZE_CLONE_CLASS = 'e-resize-clone';
/** @private */
const LEFT_RESIZE_HANDLER = 'e-left-handler';
/** @private */
const RIGHT_RESIZE_HANDLER = 'e-right-handler';
/** @private */
const TOP_RESIZE_HANDLER = 'e-top-handler';
/** @private */
const BOTTOM_RESIZE_HANDLER = 'e-bottom-handler';
/** @private */
const EVENT_RECURRENCE_ICON_CLASS = 'e-recurrence-icon';
/** @private */
const EVENT_RECURRENCE_EDIT_ICON_CLASS = 'e-recurrence-edit-icon';
/** @private */
const HEADER_ROW_CLASS = 'e-header-row';
/** @private */
const ALLDAY_APPOINTMENT_WRAPPER_CLASS = 'e-all-day-appointment-wrapper';
/** @private */
const ALLDAY_APPOINTMENT_CLASS = 'e-all-day-appointment';
/** @private */
const EVENT_COUNT_CLASS = 'e-appointment-hide';
/** @private */
const ROW_COUNT_WRAPPER_CLASS = 'e-row-count-wrapper';
/** @private */
const ALLDAY_APPOINTMENT_SECTION_CLASS = 'e-all-day-appointment-section';
/** @private */
const APPOINTMENT_ROW_EXPAND_CLASS = 'e-appointment-expand';
/** @private */
const APPOINTMENT_ROW_COLLAPSE_CLASS = 'e-appointment-collapse';
/** @private */
const MORE_INDICATOR_CLASS = 'e-more-indicator';
/** @private */
const CELL_POPUP_CLASS = 'e-cell-popup';
/** @private */
const EVENT_POPUP_CLASS = 'e-event-popup';
/** @private */
const MULTIPLE_EVENT_POPUP_CLASS = 'e-multiple-event-popup';
/** @private */
const POPUP_HEADER_CLASS = 'e-popup-header';
/** @private */
const POPUP_HEADER_ICON_WRAPPER = 'e-header-icon-wrapper';
/** @private */
const POPUP_CONTENT_CLASS = 'e-popup-content';
/** @private */
const POPUP_FOOTER_CLASS = 'e-popup-footer';
/** @private */
const DATE_TIME_DETAILS_CLASS = 'e-date-time-details';
/** @private */
const RECURRENCE_SUMMARY_CLASS = 'e-recurrence-summary';
/** @private */
const QUICK_POPUP_EVENT_DETAILS_CLASS = 'e-event-details';
/** @private */
const EVENT_CREATE_CLASS = 'e-event-create';
/** @private */
const EDIT_EVENT_CLASS = 'e-event-edit';
/** @private */
const DELETE_EVENT_CLASS = 'e-event-delete';
/** @private */
const TEXT_ELLIPSIS = 'e-text-ellipsis';
/** @private */
const MORE_POPUP_WRAPPER_CLASS = 'e-more-popup-wrapper';
/** @private */
const MORE_EVENT_POPUP_CLASS = 'e-more-event-popup';
/** @private */
const MORE_EVENT_HEADER_CLASS = 'e-more-event-header';
/** @private */
const MORE_EVENT_DATE_HEADER_CLASS = 'e-more-event-date-header';
/** @private */
const MORE_EVENT_HEADER_DAY_CLASS = 'e-header-day';
/** @private */
const MORE_EVENT_HEADER_DATE_CLASS = 'e-header-date';
/** @private */
const MORE_EVENT_CLOSE_CLASS = 'e-more-event-close';
/** @private */
const MORE_EVENT_CONTENT_CLASS = 'e-more-event-content';
/** @private */
const MORE_EVENT_WRAPPER_CLASS = 'e-more-appointment-wrapper';
/** @private */
const QUICK_DIALOG_CLASS = 'e-quick-dialog';
/** @private */
const QUICK_DIALOG_OCCURRENCE_CLASS = 'e-quick-dialog-occurrence-event';
/** @private */
const QUICK_DIALOG_SERIES_CLASS = 'e-quick-dialog-series-event';
/** @private */
const QUICK_DIALOG_FOLLOWING_EVENTS_CLASS = 'e-quick-dialog-following-events';
/** @private */
const FOLLOWING_EVENTS_DIALOG = 'e-following-events-dialog';
/** @private */
const QUICK_DIALOG_DELETE_CLASS = 'e-quick-dialog-delete';
/** @private */
const QUICK_DIALOG_CANCEL_CLASS = 'e-quick-dialog-cancel';
/** @private */
const QUICK_DIALOG_ALERT_OK = 'e-quick-alertok';
/** @private */
const QUICK_DIALOG_ALERT_CANCEL = 'e-quick-alertcancel';
/** @private */
const QUICK_DIALOG_ALERT_FOLLOWING = 'e-quick-alertfollowing';
/** @private */
const QUICK_DIALOG_ALERT_BTN_CLASS = 'e-quick-dialog-alert-btn';
/** @private */
const EVENT_WINDOW_DIALOG_CLASS = 'e-schedule-dialog';
/** @private */
const FORM_CONTAINER_CLASS = 'e-form-container';
/** @private */
const FORM_CLASS = 'e-schedule-form';
/** @private */
const EVENT_WINDOW_ALLDAY_TZ_DIV_CLASS = 'e-all-day-time-zone-row';
/** @private */
const EVENT_WINDOW_ALL_DAY_CLASS = 'e-all-day';
/** @private */
const TIME_ZONE_CLASS = 'e-time-zone';
/** @private */
const TIME_ZONE_ICON_CLASS = 'e-time-zone-icon';
/** @private */
const TIME_ZONE_DETAILS_CLASS = 'e-time-zone-details';
/** @private */
const EVENT_WINDOW_REPEAT_DIV_CLASS = 'e-repeat-parent-row';
/** @private */
const EVENT_WINDOW_REPEAT_CLASS = 'e-repeat';
/** @private */
const EVENT_WINDOW_TITLE_LOCATION_DIV_CLASS = 'e-title-location-row';
/** @private */
const SUBJECT_CLASS = 'e-subject';
/** @private */
const LOCATION_CLASS = 'e-location';
/** @private */
const LOCATION_ICON_CLASS = 'e-location-icon';
/** @private */
const LOCATION_DETAILS_CLASS = 'e-location-details';
/** @private */
const EVENT_WINDOW_START_END_DIV_CLASS = 'e-start-end-row';
/** @private */
const EVENT_WINDOW_START_CLASS = 'e-start';
/** @private */
const EVENT_WINDOW_END_CLASS = 'e-end';
/** @private */
const EVENT_WINDOW_RESOURCES_DIV_CLASS = 'e-resources-row';
/** @private */
const DESCRIPTION_CLASS = 'e-description';
/** @private */
const DESCRIPTION_ICON_CLASS = 'e-description-icon';
/** @private */
const DESCRIPTION_DETAILS_CLASS = 'e-description-details';
/** @private */
const EVENT_WINDOW_TIME_ZONE_DIV_CLASS = 'e-time-zone-row';
/** @private */
const EVENT_WINDOW_START_TZ_CLASS = 'e-start-time-zone';
/** @private */
const EVENT_WINDOW_END_TZ_CLASS = 'e-end-time-zone';
/** @private */
const EVENT_WINDOW_BACK_ICON_CLASS = 'e-back-icon';
/** @private */
const EVENT_WINDOW_SAVE_ICON_CLASS = 'e-save-icon';
/** @private */
const EVENT_WINDOW_CANCEL_BUTTON_CLASS = 'e-event-cancel';
/** @private */
const EVENT_WINDOW_SAVE_BUTTON_CLASS = 'e-event-save';
/** @private */
const EVENT_WINDOW_DIALOG_PARENT_CLASS = 'e-dialog-parent';
/** @private */
const EVENT_WINDOW_TITLE_TEXT_CLASS = 'e-title-text';
/** @private */
const EVENT_WINDOW_ICON_DISABLE_CLASS = 'e-icon-disable';
/** @private */
const EDIT_CLASS = 'e-edit';
/** @private */
const EDIT_ICON_CLASS = 'e-edit-icon';
/** @private */
const DELETE_CLASS = 'e-delete';
/** @private */
const DELETE_ICON_CLASS = 'e-delete-icon';
/** @private */
const CLOSE_CLASS = 'e-close';
/** @private */
const CLOSE_ICON_CLASS = 'e-close-icon';
/** @private */
const ERROR_VALIDATION_CLASS = 'e-schedule-error';
/** @private */
const EVENT_TOOLTIP_ROOT_CLASS = 'e-schedule-event-tooltip';
/** @private */
const ALLDAY_ROW_ANIMATE_CLASS = 'e-animate';
/** @private */
const TIMESCALE_DISABLE = 'e-timescale-disable';
/** @private */
const DISABLE_DATE = 'e-disable-date';
/** @private */
const HIDDEN_CLASS = 'e-hidden';
/** @private */
const DISABLE_DATES = 'e-disable-dates';
/** @private */
const POPUP_WRAPPER_CLASS = 'e-quick-popup-wrapper';
/** @private */
const POPUP_TABLE_CLASS = 'e-popup-table';
/** @private */
const RESOURCE_MENU = 'e-resource-menu';
/** @private */
const RESOURCE_MENU_ICON = 'e-icon-menu';
/** @private */
const RESOURCE_LEVEL_TITLE = 'e-resource-level-title';
/** @private */
const RESOURCE_TREE = 'e-resource-tree';
/** @private */
const RESOURCE_TREE_POPUP_OVERLAY = 'e-resource-tree-popup-overlay';
/** @private */
const RESOURCE_TREE_POPUP = 'e-resource-tree-popup';
/** @private */
const RESOURCE_CLASS = 'e-resource';
/** @private */
const RESOURCE_ICON_CLASS = 'e-resource-icon';
/** @private */
const RESOURCE_DETAILS_CLASS = 'e-resource-details';
/** @private */
const DATE_TIME_ICON_CLASS = 'e-date-time-icon';
/** @private */
const VIRTUAL_SCROLL_CLASS = 'e-virtual-scroll';
/** @private */
const ICON_DISABLE_CLASS = 'e-icon-disable';
/** @private */
const AUTO_HEIGHT = 'e-auto-height';
/** @private */
const IGNORE_WHITESPACE = 'e-ignore-whitespace';
/** @private */
const EVENT_TEMPLATE = 'e-template';
/** @private */
const READ_ONLY = 'e-read-only';
/** @private */
const MONTH_HEADER_WRAPPER = 'e-month-header-wrapper';
/** @private */
const INLINE_SUBJECT_CLASS = 'e-inline-subject';
/** @private */
const INLINE_APPOINTMENT_CLASS = 'e-inline-appointment';
/** @hidden */
const SCROLL_HIDDEN = 'e-scroll-hidden';
/** @private */
const ALLDAY_APPOINTMENT_SCROLL = 'e-all-day-scroll';
/** @private */
const ALLDAY_APPOINTMENT_AUTO = 'e-all-day-auto';

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Header module
 */
class HeaderRenderer {
    constructor(parent) {
        this.parent = parent;
        this.l10n = this.parent.localeObj;
        this.renderHeader();
        this.addEventListener();
    }
    addEventListener() {
        this.parent.on(documentClick, this.closeHeaderPopup, this);
    }
    removeEventListener() {
        this.parent.off(documentClick, this.closeHeaderPopup);
    }
    closeHeaderPopup(e) {
        const closestEle = closest(e.event.target, '.e-date-range,.e-header-popup,.e-day,.e-selected');
        const closestPop = closest(e.event.target, '.e-hor-nav,.e-toolbar-pop');
        const contentWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        if (this.parent.isAdaptive) {
            if (!isNullOrUndefined(closestPop) && (closestPop.classList.contains('e-toolbar-pop') ||
                closestPop.classList.contains('e-hor-nav')) && !(closestPop.classList.contains('e-hor-nav') &&
                this.element.querySelector('.e-toolbar-pop').classList.contains(POPUP_OPEN))) {
                addClass([contentWrap], SCROLL_HIDDEN);
            }
            else {
                removeClass([contentWrap], SCROLL_HIDDEN);
                const popupEle = this.element.querySelector('.e-toolbar-pop');
                if (!isNullOrUndefined(popupEle)) {
                    const popupObj = popupEle.ej2_instances[0];
                    if (popupObj && !(!isNullOrUndefined(closestPop) && closestPop.classList.contains('e-hor-nav') &&
                        popupEle.classList.contains(POPUP_OPEN))) {
                        popupObj.hide();
                    }
                }
            }
        }
        if (!isNullOrUndefined(closestEle)) {
            return;
        }
        this.hideHeaderPopup();
    }
    hideHeaderPopup() {
        if (this.headerPopup) {
            this.headerPopup.hide();
        }
    }
    renderHeader() {
        this.element = createElement('div', { className: TOOLBAR_CONTAINER });
        const toolbarEle = createElement('div', { className: HEADER_TOOLBAR });
        this.element.appendChild(toolbarEle);
        this.parent.element.insertBefore(this.element, this.parent.element.firstElementChild);
        this.renderToolbar();
    }
    renderToolbar() {
        const items = this.getItems();
        this.parent.trigger(actionBegin, { requestType: 'toolbarItemRendering', items: items }, (args) => {
            this.toolbarObj = new Toolbar({
                items: args.items,
                overflowMode: 'Popup',
                clicked: this.toolbarClickHandler.bind(this),
                enableRtl: this.parent.enableRtl,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                locale: this.parent.locale
            });
            this.toolbarObj.appendTo(this.parent.element.querySelector('.' + HEADER_TOOLBAR));
            const prevNavEle = this.toolbarObj.element.querySelector('.e-prev');
            if (prevNavEle) {
                prevNavEle.firstElementChild.setAttribute('title', this.l10n.getConstant('previous'));
            }
            const nextNavEle = this.toolbarObj.element.querySelector('.e-next');
            if (nextNavEle) {
                nextNavEle.firstElementChild.setAttribute('title', this.l10n.getConstant('next'));
            }
            this.updateAddIcon();
            this.updateActiveView();
            this.parent.trigger(actionComplete, { requestType: 'toolBarItemRendered', items: this.toolbarObj.items });
        });
    }
    updateItems() {
        if (this.toolbarObj) {
            const items = this.getItems();
            this.parent.trigger(actionBegin, { requestType: 'toolbarItemRendering', items: items }, (args) => {
                this.toolbarObj.items = args.items;
                this.toolbarObj.dataBind();
                this.parent.trigger(actionComplete, { requestType: 'toolBarItemRendered', items: this.toolbarObj.items });
            });
        }
    }
    getPopUpRelativeElement() {
        if (this.parent.isAdaptive) {
            return this.toolbarObj.element;
        }
        return this.element.querySelector('.e-date-range');
    }
    setDayOfWeek(index) {
        if (this.headerCalendar) {
            this.headerCalendar.firstDayOfWeek = index;
            this.headerCalendar.dataBind();
        }
    }
    setCalendarDate(date) {
        if (this.headerCalendar) {
            this.headerCalendar.value = date;
            this.headerCalendar.dataBind();
        }
    }
    setCalendarMinMaxDate() {
        if (this.headerCalendar) {
            this.headerCalendar.min = this.parent.minDate;
            this.headerCalendar.max = this.parent.maxDate;
            this.headerCalendar.dataBind();
        }
    }
    getCalendarView() {
        if (['Month', 'MonthAgenda', 'TimelineMonth'].indexOf(this.parent.currentView) > -1) {
            return 'Year';
        }
        else if (['Year', 'TimelineYear'].indexOf(this.parent.currentView) > -1) {
            return 'Decade';
        }
        else {
            return 'Month';
        }
    }
    setCalendarView() {
        if (this.headerCalendar) {
            const calendarView = this.getCalendarView();
            this.headerCalendar.depth = calendarView;
            this.headerCalendar.start = calendarView;
            this.headerCalendar.refresh();
        }
    }
    updateActiveView() {
        const selEle = [].slice.call(this.toolbarObj.element.querySelectorAll('.e-views'));
        removeClass(selEle, ['e-active-view']);
        if (selEle.length > 0 && selEle[this.parent.viewIndex]) {
            addClass([selEle[this.parent.viewIndex]], ['e-active-view']);
        }
    }
    updateDateRange(date) {
        const selEle = this.toolbarObj.element.querySelector('.e-date-range');
        if (!selEle) {
            return;
        }
        const textEle = selEle.querySelector('.e-tbar-btn-text');
        if (this.parent.activeViewOptions.dateRangeTemplate) {
            textEle.textContent = '';
            const args = {
                startDate: this.parent.activeView.getStartDate(),
                endDate: this.parent.activeView.getEndDate(), currentView: this.parent.currentView
            };
            const viewName = this.parent.activeViewOptions.dateRangeTemplateName;
            const templateId = this.parent.element.id + '_' + viewName + 'dateRangeTemplate';
            const dateTemplate = [].slice.call(this.parent.getDateRangeTemplate()(args, this.parent, 'dateRangeTemplate', templateId, false));
            append(dateTemplate, textEle);
        }
        else {
            const text = this.parent.activeView.getDateRangeText(date);
            selEle.setAttribute('aria-label', text);
            textEle.textContent = text;
        }
        this.refresh();
    }
    refresh() {
        if (this.toolbarObj) {
            this.toolbarObj.refreshOverflow();
        }
    }
    updateAddIcon() {
        const addEle = this.toolbarObj.element.querySelector('.e-add');
        if (addEle) {
            if (!this.parent.eventSettings.allowAdding) {
                addClass([addEle], HIDDEN_CLASS);
            }
            else {
                removeClass([addEle], HIDDEN_CLASS);
            }
        }
    }
    getDateRangeText() {
        const dateString = this.parent.globalize.formatDate(this.parent.selectedDate, {
            format: 'MMMM y', calendar: this.parent.getCalendarMode()
        });
        return capitalizeFirstWord(dateString, 'single');
    }
    getItems() {
        const items = [];
        items.push({
            align: 'Left', prefixIcon: 'e-icon-prev', tooltipText: 'Previous', overflow: 'Show',
            cssClass: 'e-prev', htmlAttributes: { 'aria-label': 'previous period', 'role': 'navigation' }
        });
        items.push({
            align: 'Left', prefixIcon: 'e-icon-next', tooltipText: 'Next', overflow: 'Show',
            cssClass: 'e-next', htmlAttributes: { 'aria-label': 'next period', 'role': 'navigation' }
        });
        items.push({
            align: 'Left', text: this.getDateRangeText(), suffixIcon: 'e-icon-down-arrow', cssClass: 'e-date-range',
            overflow: 'Show',
            htmlAttributes: { 'aria-atomic': 'true', 'aria-live': 'assertive', 'aria-label': 'title', 'role': 'navigation' }
        });
        if (this.parent.isAdaptive || this.parent.enableAdaptiveUI) {
            items.push({
                align: 'Right', showAlwaysInPopup: (this.parent.isAdaptive || this.parent.enableAdaptiveUI), prefixIcon: 'e-icon-add',
                text: this.l10n.getConstant('newEvent'), cssClass: 'e-add', overflow: 'Show'
            });
            items.push({
                align: 'Right', showAlwaysInPopup: (this.parent.isAdaptive || this.parent.enableAdaptiveUI), prefixIcon: 'e-icon-today',
                text: this.l10n.getConstant('today'), cssClass: 'e-today', overflow: 'Show'
            });
        }
        else {
            items.push({
                align: 'Right', showAlwaysInPopup: (this.parent.isAdaptive || this.parent.enableAdaptiveUI), prefixIcon: 'e-icon-day',
                text: this.l10n.getConstant('today'), cssClass: 'e-today', overflow: 'Show'
            });
            if (this.parent.views.length > 1) {
                items.push({ align: 'Right', type: 'Separator', cssClass: 'e-schedule-seperator' });
            }
        }
        if (this.parent.views.length > 1) {
            for (const item of this.parent.views) {
                items.push(this.getItemObject(item));
            }
        }
        return items;
    }
    getItemObject(item) {
        let viewName;
        let displayName;
        if (typeof (item) === 'string') {
            viewName = item.toLowerCase();
            displayName = null;
        }
        else {
            viewName = item.option.toLowerCase();
            displayName = item.displayName;
        }
        let view;
        let orientationClass;
        const isItemInsidePopup = this.parent.isAdaptive || this.parent.enableAdaptiveUI;
        switch (viewName) {
            case 'day':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-day',
                    text: displayName || this.l10n.getConstant('day'), cssClass: 'e-views e-day'
                };
                break;
            case 'week':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-week',
                    text: displayName || this.l10n.getConstant('week'), cssClass: 'e-views e-week'
                };
                break;
            case 'workweek':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-workweek',
                    text: displayName || this.l10n.getConstant('workWeek'), cssClass: 'e-views e-work-week'
                };
                break;
            case 'month':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-month',
                    text: displayName || this.l10n.getConstant('month'), cssClass: 'e-views e-month'
                };
                break;
            case 'year':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-year',
                    text: displayName || this.l10n.getConstant('year'), cssClass: 'e-views e-year'
                };
                break;
            case 'agenda':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-agenda',
                    text: displayName || this.l10n.getConstant('agenda'), cssClass: 'e-views e-agenda'
                };
                break;
            case 'monthagenda':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-month-agenda',
                    text: displayName || this.l10n.getConstant('monthAgenda'), cssClass: 'e-views e-month-agenda'
                };
                break;
            case 'timelineday':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-timeline-day',
                    text: displayName || this.l10n.getConstant('timelineDay'), cssClass: 'e-views e-timeline-day'
                };
                break;
            case 'timelineweek':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-timeline-week',
                    text: displayName || this.l10n.getConstant('timelineWeek'), cssClass: 'e-views e-timeline-week'
                };
                break;
            case 'timelineworkweek':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-timeline-workweek',
                    text: displayName || this.l10n.getConstant('timelineWorkWeek'), cssClass: 'e-views e-timeline-work-week'
                };
                break;
            case 'timelinemonth':
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-timeline-month',
                    text: displayName || this.l10n.getConstant('timelineMonth'), cssClass: 'e-views e-timeline-month'
                };
                break;
            case 'timelineyear':
                orientationClass = (item.orientation === 'Vertical') ? 'vertical' : 'horizontal';
                view = {
                    align: 'Right', showAlwaysInPopup: isItemInsidePopup, prefixIcon: 'e-icon-timeline-year-' + orientationClass,
                    text: displayName || this.l10n.getConstant('timelineYear'), cssClass: 'e-views e-timeline-year'
                };
                break;
        }
        return view;
    }
    renderHeaderPopup() {
        const headerPopupEle = createElement('div', { className: HEADER_POPUP_CLASS });
        const headerCalendarEle = createElement('div', { className: HEADER_CALENDAR_CLASS });
        headerPopupEle.appendChild(headerCalendarEle);
        this.element.appendChild(headerPopupEle);
        this.headerPopup = new Popup(headerPopupEle, {
            actionOnScroll: 'hide',
            targetType: 'relative',
            relateTo: this.getPopUpRelativeElement(),
            position: { X: 'left', Y: 'bottom' },
            enableRtl: this.parent.enableRtl
        });
        const calendarView = this.getCalendarView();
        const isDisplayDate = this.parent.currentView === 'Month' &&
            !isNullOrUndefined(this.parent.activeViewOptions.displayDate) && !this.hasSelectedDate();
        this.headerCalendar = new Calendar({
            value: isDisplayDate ? this.parent.activeViewOptions.displayDate : this.parent.selectedDate,
            min: this.parent.minDate,
            max: this.parent.maxDate,
            firstDayOfWeek: this.parent.activeViewOptions.firstDayOfWeek,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            depth: calendarView,
            start: calendarView,
            calendarMode: this.parent.calendarMode,
            change: this.calendarChange.bind(this)
        });
        this.setCalendarTimezone();
        this.headerCalendar.appendTo(headerCalendarEle);
        this.headerPopup.hide();
    }
    calendarChange(args) {
        if (args.value.getTime() !== this.parent.selectedDate.getTime()) {
            const calendarDate = resetTime(new Date(args.value));
            this.parent.changeDate(calendarDate);
        }
        this.headerPopup.hide();
    }
    setCalendarTimezone() {
        if (this.headerCalendar) {
            this.headerCalendar.timezone = this.parent.timezone || this.parent.tzModule.getLocalTimezoneName();
        }
    }
    calculateViewIndex(args) {
        const target = closest(args.originalEvent.target, '.e-views');
        const views = [].slice.call(this.element.querySelectorAll('.e-views'));
        return views.indexOf(target);
    }
    toolbarClickHandler(args) {
        if (!args.item) {
            return;
        }
        const strClass = args.item.cssClass.replace('e-views ', '');
        let data;
        let isSameTime;
        let currentTime;
        switch (strClass) {
            case 'e-date-range':
                if (!this.headerPopup) {
                    this.renderHeaderPopup();
                }
                if (this.headerPopup.element.classList.contains(POPUP_OPEN)) {
                    this.headerPopup.hide();
                }
                else {
                    this.headerPopup.show();
                }
                break;
            case 'e-day':
                this.parent.changeView('Day', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-week':
                this.parent.changeView('Week', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-work-week':
                this.parent.changeView('WorkWeek', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-month':
                this.parent.changeView('Month', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-year':
                this.parent.changeView('Year', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-agenda':
                this.parent.changeView('Agenda', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-month-agenda':
                this.parent.changeView('MonthAgenda', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-timeline-day':
                this.parent.changeView('TimelineDay', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-timeline-week':
                this.parent.changeView('TimelineWeek', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-timeline-work-week':
                this.parent.changeView('TimelineWorkWeek', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-timeline-month':
                this.parent.changeView('TimelineMonth', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-timeline-year':
                this.parent.changeView('TimelineYear', args.originalEvent, undefined, this.calculateViewIndex(args));
                break;
            case 'e-today':
                currentTime = resetTime(this.parent.getCurrentTime());
                if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda' || !this.parent.isSelectedDate(currentTime) ||
                    this.parent.currentView === 'Month' && this.parent.activeViewOptions.displayDate && !this.hasSelectedDate() &&
                        resetTime(this.parent.activeViewOptions.displayDate) !== currentTime || this.parent.currentView === 'Month' &&
                    this.parent.activeViewOptions.numberOfWeeks > 0 && !this.hasSelectedDate()
                    && resetTime(firstDateOfMonth(this.parent.selectedDate)) !== currentTime) {
                    this.parent.changeDate(currentTime, args.originalEvent);
                }
                break;
            case 'e-prev':
                this.parent.changeDate(this.parent.activeView.getNextPreviousDate('previous'), args.originalEvent);
                break;
            case 'e-next':
                this.parent.changeDate(this.parent.activeView.getNextPreviousDate('next'), args.originalEvent);
                break;
            case 'e-add':
                isSameTime = this.parent.activeCellsData.startTime.getTime() === this.parent.activeCellsData.endTime.getTime();
                if (this.parent.activeCellsData && !isSameTime) {
                    data = this.parent.activeCellsData;
                }
                else {
                    const interval = this.parent.activeViewOptions.timeScale.interval;
                    const slotCount = this.parent.activeViewOptions.timeScale.slotCount;
                    const msInterval = (interval * MS_PER_MINUTE) / slotCount;
                    const startTime = new Date(this.parent.selectedDate.getTime());
                    const currentTime = this.parent.getCurrentTime();
                    startTime.setHours(currentTime.getHours(), (Math.round(startTime.getMinutes() / msInterval) * msInterval), 0);
                    const endTime = new Date(new Date(startTime.getTime()).setMilliseconds(startTime.getMilliseconds() + msInterval));
                    data = { startTime: startTime, endTime: endTime, isAllDay: false };
                }
                this.parent.eventWindow.openEditor(extend(data, { cancel: false, event: args.originalEvent }), 'Add');
                break;
        }
        if (isNullOrUndefined(this.toolbarObj)) {
            return;
        }
        const toolbarPopUp = this.toolbarObj.element.querySelector('.e-toolbar-pop');
        if (toolbarPopUp && args.item.type !== 'Input') {
            toolbarPopUp.ej2_instances[0].hide({ name: 'SlideUp', duration: 100 });
        }
    }
    hasSelectedDate() {
        const selectedTime = resetTime(this.parent.selectedDate).getTime();
        return selectedTime >= this.parent.activeView.getStartDate().getTime() &&
            selectedTime <= this.parent.activeView.getEndDate().getTime();
    }
    getHeaderElement() {
        return this.toolbarObj.element;
    }
    updateHeaderItems(classType) {
        const prevNavEle = this.toolbarObj.element.querySelector('.e-prev');
        const nextNavEle = this.toolbarObj.element.querySelector('.e-next');
        const dateRangeEle = this.toolbarObj.element.querySelector('.e-date-range');
        if (prevNavEle) {
            if (classType === 'add') {
                addClass([prevNavEle], HIDDEN_CLASS);
            }
            else {
                removeClass([prevNavEle], HIDDEN_CLASS);
            }
        }
        if (nextNavEle) {
            if (classType === 'add') {
                addClass([nextNavEle], HIDDEN_CLASS);
            }
            else {
                removeClass([nextNavEle], HIDDEN_CLASS);
            }
        }
        if (dateRangeEle) {
            if (classType === 'add') {
                addClass([dateRangeEle], TEXT_ELLIPSIS);
            }
            else {
                removeClass([dateRangeEle], TEXT_ELLIPSIS);
            }
        }
    }
    previousNextIconHandler() {
        const dates = (this.parent.currentView === 'Agenda' ?
            [this.parent.getCurrentViewDates()[0]] : this.parent.getCurrentViewDates());
        const prevNavEle = this.toolbarObj.element.querySelector('.' + PREVIOUS_DATE_CLASS);
        const nextNavEle = this.toolbarObj.element.querySelector('.' + NEXT_DATE_CLASS);
        let firstDate = new Date(dates[0].getTime());
        let lastDate = new Date(dates[dates.length - 1].getTime());
        if (this.parent.currentView === 'WorkWeek' || this.parent.currentView === 'TimelineWorkWeek') {
            firstDate = getWeekFirstDate(resetTime(this.parent.selectedDate), this.parent.firstDayOfWeek);
            lastDate = addDays(firstDate, 7 * this.parent.activeViewOptions.interval);
        }
        else if (this.parent.currentView === 'Month') {
            const isCustomMonth = !isNullOrUndefined(this.parent.activeViewOptions.displayDate) ||
                this.parent.activeViewOptions.numberOfWeeks > 0;
            firstDate = isCustomMonth ? this.parent.activeView.getStartDate() : firstDateOfMonth(this.parent.selectedDate);
            lastDate = isCustomMonth ? this.parent.activeView.getEndDate() :
                lastDateOfMonth(addMonths(firstDate, this.parent.activeViewOptions.interval - 1));
        }
        if (!isNullOrUndefined(prevNavEle)) {
            this.toolbarObj.enableItems(prevNavEle, firstDate > resetTime(this.parent.minDate));
        }
        if (!isNullOrUndefined(nextNavEle)) {
            this.toolbarObj.enableItems(nextNavEle, lastDate < resetTime(this.parent.maxDate));
        }
        this.setCalendarMinMaxDate();
    }
    getModuleName() {
        return 'headerbar';
    }
    destroy() {
        if (this.headerPopup && !this.headerPopup.isDestroyed) {
            this.headerPopup.destroy();
            this.headerPopup = null;
        }
        if (this.headerCalendar && !this.headerCalendar.isDestroyed) {
            this.headerCalendar.destroy();
            this.headerCalendar = null;
        }
        if (this.toolbarObj && !this.toolbarObj.isDestroyed) {
            this.toolbarObj.destroy();
            this.removeEventListener();
            remove(this.element);
            this.toolbarObj = null;
        }
        this.element = null;
        this.parent = null;
        this.l10n = null;
    }
}

/**
 * `Scroll` module
 */
class Scroll {
    /**
     * Constructor for the scrolling.
     *
     * @param {Schedule} parent Accepts the Schedule instance
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} Returns the module name.
     * @private
     */
    getModuleName() {
        return 'scroll';
    }
    /**
     * Internal method to set the element width
     *
     * @returns {void}
     * @private
     */
    setWidth() {
        this.parent.element.style.width = formatUnit(this.parent.width);
    }
    /**
     * Internal method to set the element height
     *
     * @returns {void}
     * @private
     */
    setHeight() {
        this.parent.element.style.height = formatUnit(this.parent.height);
    }
    /**
     * Internal method to bind events
     *
     * @returns {void}
     * @private
     */
    addEventListener() {
        this.parent.on(contentReady, this.setDimensions, this);
        this.parent.on(uiUpdate, this.onPropertyChanged, this);
    }
    /**
     * Internal method to unbind events
     *
     * @returns {void}
     * @private
     */
    removeEventListener() {
        this.parent.off(contentReady, this.setDimensions);
        this.parent.off(uiUpdate, this.onPropertyChanged);
    }
    /**
     * Internal method to set the dimensions
     *
     * @returns {void}
     * @private
     */
    setDimensions() {
        this.setWidth();
        this.setHeight();
        const data = { cssProperties: this.parent.getCssProperties(), module: this.getModuleName() };
        this.parent.notify(scrollUiUpdate, data);
    }
    /**
     * Internal method to set the dimensions dynamically
     *
     * @returns {void}
     * @private
     */
    onPropertyChanged() {
        this.setDimensions();
    }
    /**
     * Destroy the scroll module
     *
     * @returns {void}
     * @private
     */
    destroy() {
        this.removeEventListener();
    }
}

/**
 * `touch` module is used to handle touch interactions.
 */
class ScheduleTouch {
    constructor(parent) {
        this.parent = parent;
        this.element = this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS);
        this.touchObj = new Touch(this.element, {
            scroll: this.scrollHandler.bind(this),
            swipe: this.swipeHandler.bind(this),
            tapHold: this.tapHoldHandler.bind(this),
            swipeSettings: { swipeThresholdDistance: 1 }
        });
        EventHandler.add(this.element, 'transitionend', this.onTransitionEnd, this);
        this.touchLeftDirection = this.parent.enableRtl ? 'Right' : 'Left';
        this.touchRightDirection = this.parent.enableRtl ? 'Left' : 'Right';
    }
    scrollHandler(e) {
        if (this.parent.currentView === 'Agenda' || this.parent.uiStateValues.action || !this.parent.allowSwiping ||
            (e.originalEvent && e.originalEvent.target &&
                (e.originalEvent.target.classList.contains(APPOINTMENT_CLASS) ||
                    closest(e.originalEvent.target, '.' + APPOINTMENT_CLASS)) && !this.parent.isAdaptive)) {
            return;
        }
        if (!this.timeStampStart) {
            this.timeStampStart = Date.now();
        }
        if (this.element.classList.contains(TRANSLATE_CLASS)) {
            this.onTransitionEnd();
        }
        if (e.scrollDirection === 'Left' || e.scrollDirection === 'Right') {
            const args = { requestType: 'dateNavigate', cancel: false, event: e.originalEvent };
            this.parent.trigger(actionBegin, args);
            if (args.cancel) {
                return;
            }
            const scrollDiv = this.element.querySelector('.' + CONTENT_WRAP_CLASS);
            if (scrollDiv && scrollDiv.scrollWidth > scrollDiv.clientWidth) {
                return;
            }
            else {
                this.isScrollTriggered = true;
                e.originalEvent.preventDefault();
                e.originalEvent.stopPropagation();
            }
        }
        if (e.scrollDirection === this.touchLeftDirection) {
            if (!this.nextPanel) {
                this.renderPanel(NEXT_PANEL_CLASS, 'next');
                this.nextPanel = {
                    element: this.parent.activeView.getPanel(),
                    selectedDate: new Date(this.parent.selectedDate.getTime()),
                    renderDates: this.parent.activeView.renderDates,
                    colLevels: this.parent.activeView.colLevels
                };
                this.setDimensions(this.nextPanel.element);
            }
            const x = this.parent.enableRtl ? e.distanceX : -e.distanceX;
            this.element.style.transform = 'translatex(' + (this.getTranslateX(this.element) + x) + 'px)';
        }
        else if (e.scrollDirection === this.touchRightDirection) {
            let prevWidth = 0;
            if (!this.previousPanel) {
                this.renderPanel(PREVIOUS_PANEL_CLASS, 'previous');
                this.previousPanel = {
                    element: this.parent.activeView.getPanel(),
                    selectedDate: new Date(this.parent.selectedDate.getTime()),
                    renderDates: this.parent.activeView.renderDates,
                    colLevels: this.parent.activeView.colLevels
                };
                this.setDimensions(this.previousPanel.element);
                prevWidth = this.previousPanel.element.offsetWidth;
            }
            const x = this.parent.enableRtl ? prevWidth - e.distanceX : -prevWidth + e.distanceX;
            this.element.style.transform = 'translatex(' + (this.getTranslateX(this.element) + x) + 'px)';
        }
    }
    swipeHandler(e) {
        if (!this.isScrollTriggered || this.parent.uiStateValues.action || !this.parent.allowSwiping) {
            return;
        }
        this.isScrollTriggered = false;
        const swipeDate = e.swipeDirection === 'Left' ?
            this.parent.activeView.renderDates[0] : this.parent.activeView.renderDates.slice(-1)[0];
        if ((e.swipeDirection === 'Left' && swipeDate < this.parent.maxDate) ||
            (e.swipeDirection === 'Right' && swipeDate >= this.parent.minDate)) {
            const time = Date.now() - this.timeStampStart;
            const offsetDist = (e.distanceX * (Browser.isDevice ? 6 : 1.66));
            if (offsetDist > time || (e.distanceX > (this.parent.element.offsetWidth / 2))) {
                this.swapPanels(e.swipeDirection);
                if (offsetDist > time && (e.distanceX > (this.parent.element.offsetWidth / 2))) {
                    this.element.style.transitionDuration = (((Browser.isDevice ? e.distanceX : offsetDist) / time) / 10) + 's';
                }
                this.confirmSwipe(e.swipeDirection);
            }
            else {
                this.cancelSwipe();
            }
            const args = { requestType: 'dateNavigate', cancel: false, event: e.originalEvent };
            this.parent.trigger(actionComplete, args);
        }
        else {
            this.cancelSwipe();
        }
        this.timeStampStart = null;
    }
    tapHoldHandler(e) {
        const target = closest(e.originalEvent.target, '.' + APPOINTMENT_CLASS);
        if (!isNullOrUndefined(target) && this.parent.isAdaptive) {
            this.parent.quickPopup.tapHoldEventPopup(e.originalEvent);
            return;
        }
    }
    renderPanel(clsName, nextPrevType) {
        if (!this.currentPanel) {
            this.currentPanel = {
                element: this.parent.activeView.getPanel(),
                selectedDate: new Date(this.parent.selectedDate.getTime()),
                renderDates: this.parent.activeView.renderDates,
                colLevels: this.parent.activeView.colLevels
            };
            this.setDimensions(this.currentPanel.element);
        }
        else {
            this.parent.setProperties({ selectedDate: this.currentPanel.selectedDate }, true);
        }
        this.parent.setProperties({ selectedDate: this.parent.activeView.getNextPreviousDate(nextPrevType) }, true);
        if (this.parent.headerModule) {
            this.parent.headerModule.setCalendarDate(this.parent.selectedDate);
        }
        this.parent.activeView.getRenderDates();
        this.parent.activeView.renderLayout(clsName);
    }
    swapPanels(direction) {
        if (direction === this.touchLeftDirection) {
            const temp = this.nextPanel;
            this.nextPanel = this.currentPanel;
            this.currentPanel = temp;
        }
        else {
            const temp = this.previousPanel;
            this.previousPanel = this.currentPanel;
            this.currentPanel = temp;
        }
    }
    confirmSwipe(swipeDirection) {
        const previousDate = swipeDirection === this.touchLeftDirection ?
            this.nextPanel.selectedDate : this.previousPanel.selectedDate;
        const args = {
            action: 'date', cancel: false, previousDate: previousDate, currentDate: this.currentPanel.selectedDate
        };
        this.parent.trigger(navigating, args, (navArgs) => {
            if (navArgs.cancel) {
                this.swapPanels(swipeDirection);
                this.cancelSwipe();
            }
            else {
                this.parent.activeView.setPanel(this.currentPanel.element);
                this.parent.setProperties({ selectedDate: this.currentPanel.selectedDate }, true);
                let translateX;
                if (this.parent.enableRtl) {
                    translateX = swipeDirection === this.touchLeftDirection ?
                        (this.previousPanel ? this.previousPanel.element.offsetLeft : this.currentPanel.element.offsetWidth) : 0;
                }
                else {
                    translateX = swipeDirection === this.touchLeftDirection ? -this.currentPanel.element.offsetLeft : 0;
                }
                this.parent.activeView.renderDates = this.currentPanel.renderDates;
                this.parent.activeView.colLevels = this.currentPanel.colLevels;
                addClass([this.element], TRANSLATE_CLASS);
                this.element.style.transform = 'translatex(' + translateX + 'px)';
                if (this.parent.headerModule) {
                    this.parent.headerModule.updateDateRange();
                }
                this.parent.renderTemplates();
                this.parent.crudModule.refreshDataManager();
            }
        });
    }
    cancelSwipe() {
        this.parent.activeView.setPanel(this.currentPanel.element);
        this.parent.setProperties({ selectedDate: this.currentPanel.selectedDate }, true);
        this.parent.activeView.renderDates = this.currentPanel.renderDates;
        this.parent.activeView.colLevels = this.currentPanel.colLevels;
        addClass([this.element], TRANSLATE_CLASS);
        const prevWidth = this.previousPanel ? this.previousPanel.element.offsetWidth : 0;
        this.element.style.transform = 'translatex(' + (this.parent.enableRtl ? prevWidth : -this.currentPanel.element.offsetLeft) + 'px)';
    }
    onTransitionEnd() {
        removeClass([this.element], TRANSLATE_CLASS);
        this.element.style.transitionDuration = '';
        this.element.style.transform = '';
        if (this.previousPanel) {
            remove(this.previousPanel.element);
            this.previousPanel = null;
            removeClass([this.currentPanel.element], PREVIOUS_PANEL_CLASS);
            addClass([this.currentPanel.element], CURRENT_PANEL_CLASS);
        }
        if (this.nextPanel) {
            remove(this.nextPanel.element);
            this.nextPanel = null;
            removeClass([this.currentPanel.element], NEXT_PANEL_CLASS);
            addClass([this.currentPanel.element], CURRENT_PANEL_CLASS);
        }
        this.currentPanel = null;
        this.parent.activeView.getPanel().style.width = '';
    }
    getTranslateX(element) {
        const style = window.getComputedStyle(element);
        return new WebKitCSSMatrix(style.webkitTransform).m41;
    }
    setDimensions(element) {
        element.style.width = (this.parent.element.clientWidth) + 'px';
    }
    resetValues() {
        this.currentPanel = null;
        this.previousPanel = null;
        this.nextPanel = null;
        this.timeStampStart = null;
        this.element.style.transform = '';
        this.element.style.transitionDuration = '';
        removeChildren(this.element);
        removeClass([this.element], TRANSLATE_CLASS);
    }
    destroy() {
        if (this.touchObj) {
            this.touchObj.destroy();
            this.touchObj = null;
        }
        EventHandler.remove(this.element, 'transitionend', this.onTransitionEnd);
        this.resetValues();
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Keyboard interaction
 */
class KeyboardInteraction {
    constructor(parent) {
        this.selectedCells = [];
        this.keyConfigs = {
            downArrow: 'downarrow',
            upArrow: 'uparrow',
            rightArrow: 'rightarrow',
            leftArrow: 'leftarrow',
            shiftDownArrow: 'shift+downarrow',
            shiftUpArrow: 'shift+uparrow',
            shiftRightArrow: 'shift+rightarrow',
            shiftLeftArrow: 'shift+leftarrow',
            ctrlLeftArrow: 'ctrl+leftarrow',
            ctrlRightArrow: 'ctrl+rightarrow',
            altOne: 'alt+1',
            altTwo: 'alt+2',
            altThree: 'alt+3',
            altFour: 'alt+4',
            altFive: 'alt+5',
            altSix: 'alt+6',
            altSeven: 'alt+7',
            altEight: 'alt+8',
            altNine: 'alt+9',
            enter: 'enter',
            escape: 'escape',
            delete: 'delete',
            backspace: 'backspace',
            home: 'home',
            pageUp: 'pageup',
            pageDown: 'pagedown',
            tab: 'tab',
            shiftTab: 'shift+tab',
            ctrlShiftUpArrow: 'ctrl+shift+uparrow',
            ctrlShiftDownArrow: 'ctrl+shift+downarrow',
            ctrlShiftLeftArrow: 'ctrl+shift+leftarrow',
            ctrlShiftRightArrow: 'ctrl+shift+rightarrow'
        };
        this.parent = parent;
        this.parent.element.tabIndex = this.parent.element.tabIndex === -1 ? 0 : this.parent.element.tabIndex;
        this.keyboardModule = new KeyboardEvents(this.parent.element, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: this.keyConfigs,
            eventName: 'keydown'
        });
        this.addEventListener();
    }
    keyActionHandler(e) {
        switch (e.action) {
            case 'downArrow':
            case 'shiftDownArrow':
                this.processDown(e, e.shiftKey);
                break;
            case 'upArrow':
            case 'shiftUpArrow':
                this.processUp(e, e.shiftKey);
                break;
            case 'leftArrow':
            case 'shiftLeftArrow':
                this.processLeft(e, e.shiftKey);
                break;
            case 'rightArrow':
            case 'shiftRightArrow':
                this.processRight(e, e.shiftKey);
                break;
            case 'ctrlLeftArrow':
                this.parent.changeDate(this.parent.activeView.getNextPreviousDate('previous'), e);
                if (this.parent.headerModule) {
                    this.parent.headerModule.element.querySelector('.e-prev button').focus();
                }
                break;
            case 'ctrlRightArrow':
                this.parent.changeDate(this.parent.activeView.getNextPreviousDate('next'), e);
                if (this.parent.headerModule) {
                    this.parent.headerModule.element.querySelector('.e-next button').focus();
                }
                break;
            case 'altOne':
            case 'altTwo':
            case 'altThree':
            case 'altFour':
            case 'altFive':
            case 'altSix':
            case 'altSeven':
            case 'altEight':
            case 'altNine':
                this.processViewNavigation(e);
                break;
            case 'enter':
                this.processEnter(e);
                break;
            case 'home':
                this.focusFirstCell();
                break;
            case 'tab':
            case 'shiftTab':
                this.processTab(e, e.shiftKey);
                break;
            case 'delete':
            case 'backspace':
                this.processDelete(e);
                break;
            case 'ctrlShiftUpArrow':
            case 'ctrlShiftDownArrow':
            case 'ctrlShiftLeftArrow':
            case 'ctrlShiftRightArrow':
                this.processCtrlShiftNavigationArrows(e);
                break;
            case 'escape':
                this.processEscape(e);
                break;
            case 'fTwelve':
                if (this.parent.allowInline && this.parent.inlineModule) {
                    e.preventDefault();
                    this.processFTwelve(e);
                }
                break;
        }
    }
    processFTwelve(e) {
        const target = e.target;
        if (target.classList.contains(WORK_CELLS_CLASS) || target.classList.contains(ALLDAY_CELLS_CLASS)) {
            this.parent.activeCellsData = this.getSelectedElements(target);
            const args = extend(this.parent.activeCellsData, { cancel: false, event: e });
            const inlineArgs = {
                element: args.element,
                groupIndex: args.groupIndex, type: 'Cell'
            };
            this.parent.notify(inlineClick, inlineArgs);
        }
        if (target.classList.contains(APPOINTMENT_CLASS)) {
            target.click();
            return;
        }
    }
    addEventListener() {
        this.parent.on(cellMouseDown, this.onCellMouseDown, this);
    }
    removeEventListener() {
        this.parent.off(cellMouseDown, this.onCellMouseDown);
    }
    onCellMouseDown(e) {
        if (e.event.shiftKey) {
            return;
        }
        this.initialTarget = this.getClosestCell(e.event);
        if (this.parent.activeViewOptions.readonly || this.parent.currentView === 'MonthAgenda' || !this.initialTarget) {
            return;
        }
        if (e.event.target.classList.contains(WORK_CELLS_CLASS) && e.event.which !== 3) {
            this.parent.removeSelectedClass();
            EventHandler.add(this.parent.getContentTable(), 'mousemove', this.onMouseSelection, this);
            EventHandler.add(this.parent.getContentTable(), 'mouseup', this.onMoveUp, this);
        }
        if (e.event.target.classList.contains(ALLDAY_CELLS_CLASS) && e.event.which !== 3) {
            this.parent.removeSelectedClass();
            const allDayRow = this.parent.getAllDayRow();
            EventHandler.add(allDayRow, 'mousemove', this.onMouseSelection, this);
            EventHandler.add(allDayRow, 'mouseup', this.onMoveUp, this);
        }
    }
    onMouseSelection(e) {
        const appointments = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));
        addClass(appointments, 'e-allow-select');
        const selectionEdges = this.parent.boundaryValidation(e.pageY, e.pageX);
        if (selectionEdges.bottom || selectionEdges.top || selectionEdges.left || selectionEdges.right) {
            const parent = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
            const yInBounds = parent.offsetHeight <= parent.scrollHeight && parent.scrollTop >= 0 &&
                parent.scrollTop + parent.offsetHeight <= parent.scrollHeight;
            const xInBounds = parent.offsetWidth <= parent.scrollWidth && parent.scrollLeft >= 0 &&
                parent.scrollLeft + parent.offsetWidth <= parent.scrollWidth;
            if (yInBounds && (selectionEdges.top || selectionEdges.bottom)) {
                parent.scrollTop += selectionEdges.top ? -e.target.offsetHeight : e.target.offsetHeight;
            }
            if (xInBounds && (selectionEdges.left || selectionEdges.right)) {
                parent.scrollLeft += selectionEdges.left ? -e.target.offsetWidth : e.target.offsetWidth;
            }
        }
        const target = this.getClosestCell(e);
        if (target) {
            this.selectCells(true, target);
        }
    }
    getClosestCell(e) {
        return closest(e.target, '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS);
    }
    onMoveUp(e) {
        const appointments = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));
        removeClass(appointments, 'e-allow-select');
        if (e.target.classList.contains(WORK_CELLS_CLASS)) {
            EventHandler.remove(this.parent.getContentTable(), 'mousemove', this.onMouseSelection);
            EventHandler.remove(this.parent.getContentTable(), 'mouseup', this.onMoveUp);
        }
        if (e.target.classList.contains(ALLDAY_CELLS_CLASS)) {
            const allDayRow = this.parent.getAllDayRow();
            EventHandler.remove(allDayRow, 'mousemove', this.onMouseSelection);
            EventHandler.remove(allDayRow, 'mouseup', this.onMoveUp);
        }
        if (this.isPreventAction(e)) {
            return;
        }
        const queryStr = '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' + HEADER_CELLS_CLASS;
        const target = closest(e.target, queryStr);
        if (this.parent.currentView === 'TimelineYear' && target.classList.contains(OTHERMONTH_CLASS)) {
            return;
        }
        this.parent.activeCellsData = this.getSelectedElements(target);
        const cellData = {};
        if (this.parent.eventWindow) {
            this.parent.eventWindow.convertToEventData(this.parent.activeCellsData, cellData);
        }
        const selectedCells = this.parent.getSelectedCells();
        const args = {
            data: cellData, element: this.parent.activeCellsData.element, event: e,
            requestType: cellSelect, showQuickPopup: false
        };
        this.parent.trigger(select, args, (selectArgs) => {
            const isPopupShow = selectArgs.showQuickPopup || this.parent.quickInfoOnSelectionEnd;
            if (isPopupShow && selectedCells.length > 1) {
                const cellArgs = extend(this.parent.activeCellsData, { cancel: false, event: e, name: 'cellClick' });
                this.parent.notify(cellClick, cellArgs);
            }
        });
    }
    processEnter(e) {
        if ((this.parent.activeViewOptions.readonly && !e.target.classList.contains(APPOINTMENT_CLASS))
            || this.isPreventAction(e)) {
            return;
        }
        if (this.parent.currentView === 'TimelineYear' && e.target.classList.contains(OTHERMONTH_CLASS)) {
            return;
        }
        const target = e.target;
        if (closest(target, '.' + POPUP_WRAPPER_CLASS)) {
            if (target.classList.contains(QUICK_POPUP_EVENT_DETAILS_CLASS) ||
                target.classList.contains(EVENT_CREATE_CLASS) ||
                target.classList.contains(EDIT_EVENT_CLASS) ||
                target.classList.contains(DELETE_EVENT_CLASS) ||
                target.classList.contains(CLOSE_CLASS)) {
                target.click();
                e.preventDefault();
            }
            else if (target.classList.contains(SUBJECT_CLASS)) {
                this.parent.element.querySelector('.' + EVENT_CREATE_CLASS).click();
                e.preventDefault();
            }
            return;
        }
        if (target.classList.contains(RESOURCE_CELLS_CLASS) && target.classList.contains(RESOURCE_PARENT_CLASS)) {
            const resourceIcon = target.querySelector('.' + RESOURCE_TREE_ICON_CLASS);
            if (resourceIcon) {
                resourceIcon.click();
            }
            return;
        }
        if (target.classList.contains(WORK_CELLS_CLASS) || target.classList.contains(ALLDAY_CELLS_CLASS)) {
            this.parent.activeCellsData = this.getSelectedElements(target);
            const args = extend(this.parent.activeCellsData, { cancel: false, event: e });
            if (this.parent.allowInline) {
                const inlineArgs = {
                    element: args.element,
                    groupIndex: args.groupIndex, type: 'Cell'
                };
                this.parent.notify(inlineClick, inlineArgs);
            }
            else {
                if (this.parent.currentView === 'Year') {
                    target.click();
                }
                else {
                    this.parent.notify(cellClick, args);
                }
            }
            return;
        }
        if (target.classList.contains(INLINE_SUBJECT_CLASS) && this.parent.inlineModule) {
            this.parent.inlineModule.inlineCrudActions(target);
            return;
        }
        if (target.classList.contains(APPOINTMENT_CLASS) || target.classList.contains(MORE_EVENT_CLOSE_CLASS) ||
            target.classList.contains(ALLDAY_APPOINTMENT_SECTION_CLASS) || target.classList.contains(MORE_INDICATOR_CLASS)) {
            target.click();
            return;
        }
        if (target.classList.contains(MORE_EVENT_HEADER_DATE_CLASS)) {
            this.parent.setProperties({ selectedDate: this.parent.getDateFromElement(target) }, true);
            this.parent.changeView(this.parent.getNavigateView(), e);
            this.processEscape(e);
            return;
        }
    }
    getSelectedElements(target) {
        let cellDetails;
        if (this.selectedCells.length > 1 && target.classList.contains(SELECTED_CELL_CLASS)) {
            const start = this.parent.getCellDetails(this.selectedCells[0]);
            const end = this.parent.getCellDetails(this.selectedCells.slice(-1)[0]);
            start.endTime = end.endTime;
            start.element = target;
            cellDetails = start;
        }
        else {
            cellDetails = this.parent.getCellDetails(target);
        }
        return cellDetails;
    }
    getCells(isInverseTable, start, end) {
        const tableEle = this.parent.getContentTable();
        const isTimelineYear = this.parent.currentView === 'TimelineYear';
        const query = isTimelineYear && !isInverseTable ? '.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')' : 'td';
        let cells = [].slice.call(tableEle.querySelectorAll(query));
        let maxRow = tableEle.rows.length;
        let maxColumn = tableEle.rows[0].cells.length;
        if (start && start.classList.contains(ALLDAY_CELLS_CLASS)) {
            const allDayRow = this.parent.getAllDayRow();
            cells = [].slice.call(allDayRow.cells);
            maxRow = 1;
            maxColumn = allDayRow.cells.length;
        }
        let startIndex = cells.indexOf(start);
        let endIndex = cells.indexOf(end);
        const inverseCells = [];
        if (isInverseTable) {
            for (let i = 0; i < maxColumn; i++) {
                for (let j = 0; j < maxRow; j++) {
                    const cell = cells[maxColumn * j + i];
                    if (isTimelineYear && cell.classList.contains(OTHERMONTH_CLASS)) {
                        continue;
                    }
                    inverseCells.push(cell);
                }
            }
            startIndex = inverseCells.indexOf(start);
            endIndex = inverseCells.indexOf(end);
        }
        if (startIndex > endIndex) {
            const temp = startIndex;
            startIndex = endIndex;
            endIndex = temp;
        }
        const sCells = isInverseTable ? inverseCells : cells;
        return sCells.slice(startIndex, endIndex + 1);
    }
    focusFirstCell() {
        if (this.parent.currentView === 'Agenda') {
            const focusCell = this.parent.getContentTable().querySelector('.' + AGENDA_CELLS_CLASS);
            focusCell.setAttribute('tabindex', '0');
            focusCell.focus();
            return;
        }
        this.parent.eventBase.removeSelectedAppointmentClass();
        if (this.parent.activeView.isTimelineView() && this.parent.currentView !== 'TimelineYear') {
            const cell = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS +
                ' tr:not(.' + HIDDEN_CLASS + ') .' + WORK_CELLS_CLASS + ':not(.' + RESOURCE_GROUP_CELLS_CLASS + ')');
            this.selectCells(false, cell);
        }
        else if (this.parent.currentView.indexOf('Year') > -1) {
            let query = '.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')' + ':not(.' + RESOURCE_GROUP_CELLS_CLASS + ')';
            const isVerticalYear = this.parent.currentView === 'TimelineYear' && this.parent.activeViewOptions.orientation === 'Vertical';
            query += isVerticalYear ? '[data-date="' + this.parent.activeView.startDate().getTime() + '"]' : '';
            this.selectCells(false, this.parent.element.querySelector(query));
        }
        else {
            this.selectCells(false, this.parent.getWorkCellElements()[0]);
        }
    }
    isInverseTableSelect() {
        return this.parent.activeView.isInverseTableSelect;
    }
    /**
     * Internal method to select cells
     *
     * @param {boolean} isMultiple Accepts to select multiple cells or not
     * @param {HTMLTableCellElement} targetCell Accepts the target cells
     * @returns {void}
     * @private
     */
    selectCells(isMultiple, targetCell) {
        this.parent.removeSelectedClass();
        let target = (targetCell instanceof Array) ? targetCell.slice(-1)[0] : targetCell;
        if (isMultiple) {
            let initialId;
            const views = ['Day', 'Week', 'WorkWeek', 'TimelineDay', 'TimelineWeek', 'TimelineWorkWeek', 'TimelineMonth', 'TimelineYear'];
            const args = { element: targetCell, requestType: 'mousemove', allowMultipleRow: true };
            this.parent.inlineModule.removeInlineAppointmentElement();
            this.parent.trigger(select, args, (selectArgs) => {
                const allowMultipleRow = (!selectArgs.allowMultipleRow) || (!this.parent.allowMultiRowSelection);
                if (allowMultipleRow) {
                    const isTimelineYear = this.parent.currentView === 'TimelineYear';
                    if (isTimelineYear && this.parent.activeViewOptions.orientation === 'Horizontal' || this.parent.currentView === 'Month') {
                        const isGroupYear = isTimelineYear && this.parent.activeViewOptions.group.resources.length > 0;
                        target = isGroupYear ? this.initialTarget :
                            this.initialTarget.parentElement.children[target.cellIndex];
                    }
                    else if (views.indexOf(this.parent.currentView) > -1) {
                        target = target.parentElement.children[this.initialTarget.cellIndex];
                    }
                }
                let selectedCells = this.getCells(this.isInverseTableSelect(), this.initialTarget, target);
                if (this.parent.activeViewOptions.group.resources.length > 0) {
                    initialId = this.initialTarget.getAttribute('data-group-index');
                    const resourceSelectedCells = [];
                    for (const cell of selectedCells) {
                        if (cell.getAttribute('data-group-index') === initialId) {
                            resourceSelectedCells.push(cell);
                        }
                    }
                    selectedCells = resourceSelectedCells;
                }
                if (!this.parent.allowMultiCellSelection) {
                    selectedCells = [this.initialTarget];
                }
                this.selectedCells = selectedCells;
                if (selectedCells.length > 2 && !target.classList.contains(ALLDAY_CELLS_CLASS)) {
                    let allDayCells = this.getAllDayCells(selectedCells);
                    if (this.parent.activeViewOptions.group.resources.length > 0) {
                        const resourceAllDayCells = [];
                        for (const cell of allDayCells) {
                            if (cell.getAttribute('data-group-index') === initialId) {
                                resourceAllDayCells.push(cell);
                            }
                        }
                        allDayCells = resourceAllDayCells;
                    }
                    selectedCells = selectedCells.concat(allDayCells);
                }
                if ((target.getAttribute('data-group-index') !== initialId) && this.parent.activeViewOptions.group.resources.length > 0) {
                    target = this.selectedCells[this.selectedCells.length - 1];
                }
                this.parent.addSelectedClass(selectedCells, target);
            });
        }
        else {
            const args = {
                element: target, requestType: cellSelect
            };
            // activeCellsData is not reset on schedule property changed(group properties)
            // const cellData: Record<string, any> = {};
            // const cellDetails: CellClickEventArgs = this.parent.getCellDetails(target);
            // if (this.parent.eventWindow && cellDetails) {
            //     if (this.parent.activeCellsData.element !== cellDetails.element) {
            //         this.parent.activeCellsData = cellDetails;
            //     }
            //     this.parent.eventWindow.convertToEventData(this.parent.activeCellsData as unknown as Record<string, any>, cellData);
            //     args.data = cellData;
            // }
            this.parent.trigger(select, args, () => {
                this.initialTarget = target;
                this.selectedCells = [target];
                this.parent.addSelectedClass([target], target);
            });
        }
    }
    selectAppointment(isReverse, target) {
        const appointments = this.getAppointmentElements();
        if (appointments.length < 0) {
            return;
        }
        this.parent.eventBase.removeSelectedAppointmentClass();
        let nextAppEle;
        if (target.classList.contains(APPOINTMENT_CLASS)) {
            const targetIndex = appointments.indexOf(target);
            nextAppEle = appointments[(isReverse ? targetIndex - 1 : targetIndex + 1)];
        }
        else {
            nextAppEle = isReverse ? appointments[appointments.length - 1] : appointments[0];
        }
        if (nextAppEle) {
            this.parent.eventBase.addSelectedAppointments([nextAppEle], true);
            nextAppEle.focus();
            addClass([nextAppEle], AGENDA_SELECTED_CELL);
        }
    }
    selectAppointmentElementFromWorkCell(isReverse, target) {
        this.parent.eventBase.removeSelectedAppointmentClass();
        this.parent.removeSelectedClass();
        if (target.classList.contains(WORK_CELLS_CLASS) || target.classList.contains(ALLDAY_CELLS_CLASS)) {
            const appointmentElements = this.getUniqueAppointmentElements();
            const filteredElements = [];
            const selectedDate = this.parent.getDateFromElement(target).getTime();
            const selectedSeriesEvents = this.parent.eventsProcessed.filter((eventObject) => {
                return (!isReverse ? (eventObject[this.parent.eventFields.startTime].getTime() >= selectedDate) :
                    (eventObject[this.parent.eventFields.startTime].getTime() <= selectedDate));
            });
            selectedSeriesEvents.filter((event) => {
                appointmentElements.filter((element) => {
                    if (JSON.stringify(event.Guid) === JSON.stringify(element.getAttribute('data-guid'))) {
                        filteredElements.push(element);
                    }
                });
            });
            if (filteredElements.length > 0) {
                const selectedElement = isReverse ? filteredElements[filteredElements.length - 1] : filteredElements[0];
                const focusElements = this.getAppointmentElementsByGuid(selectedElement.getAttribute('data-guid'));
                this.parent.eventBase.addSelectedAppointments(focusElements, true);
                (focusElements[focusElements.length - 1]).focus();
            }
        }
    }
    getAllDayCells(cells) {
        const allDayRow = this.parent.getAllDayRow();
        if (!allDayRow) {
            return [];
        }
        const startCell = cells[0];
        const endCell = cells[cells.length - 1];
        const start = this.parent.getCellDetails(startCell);
        const end = this.parent.getCellDetails(endCell);
        if (end.endTime.getTime() - start.startTime.getTime() >= MS_PER_DAY) {
            const allDayCells = [].slice.call(allDayRow.cells);
            return allDayCells.slice(startCell.cellIndex, endCell.cellIndex + 1);
        }
        return [];
    }
    getAppointmentElements() {
        return [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));
    }
    getAppointmentElementsByGuid(guid) {
        return [].slice.call(this.parent.element.querySelectorAll('div[data-guid="' + guid + '"]'));
    }
    getUniqueAppointmentElements() {
        const appointments = this.getAppointmentElements();
        const appointmentElements = [];
        appointments.map((value) => value.getAttribute('data-guid')).filter((value, index, self) => {
            if (self.indexOf(value) === index) {
                appointmentElements.push(appointments[parseInt(index.toString(), 10)]);
            }
        });
        return appointmentElements;
    }
    getWorkCellFromAppointmentElement(target) {
        const selectedObject = this.parent.eventBase.getEventByGuid(target.getAttribute('data-guid'));
        return this.parent.eventBase.selectWorkCellByTime([selectedObject]);
    }
    processViewNavigation(e) {
        const index = parseInt(e.key, 10) - 1;
        if (index < this.parent.views.length) {
            const view = this.parent.viewCollections[parseInt(index.toString(), 10)].option;
            this.parent.changeView(view, e, undefined, index);
            if (this.parent.headerModule) {
                this.parent.headerModule.element.querySelector('.e-active-view button').focus();
            }
        }
    }
    cancelUpDownAction(isTimelineYear) {
        const isVerticalYear = isTimelineYear && this.parent.activeViewOptions.orientation === 'Vertical';
        const isGroup = this.parent.activeViewOptions.group.resources.length > 0;
        if (isVerticalYear && isGroup || isTimelineYear && this.initialTarget.classList.contains(OTHERMONTH_CLASS)) {
            return true;
        }
        if (this.parent.activeView.isTimelineView() && !isTimelineYear || this.parent.currentView === 'MonthAgenda') {
            return true;
        }
        return false;
    }
    processUp(e, isMultiple) {
        const isTimelineYear = this.parent.currentView === 'TimelineYear';
        if (isMultiple && this.cancelUpDownAction(isTimelineYear)) {
            return;
        }
        let target = (e.target);
        const selectedElements = this.parent.getSelectedCells();
        const selectedEventElements = this.parent.eventBase.getSelectedAppointments();
        const moreEventWrapper = this.parent.element.querySelector('.' + MORE_POPUP_WRAPPER_CLASS);
        const quickPopupWrapper = this.getQuickPopupElement();
        if (selectedElements.length > 0 && !e.target.classList.contains(WORK_CELLS_CLASS)) {
            target = selectedElements[selectedElements.length - 1];
        }
        if (selectedEventElements.length > 0 && !moreEventWrapper.classList.contains(POPUP_OPEN) &&
            !quickPopupWrapper.classList.contains(POPUP_OPEN) &&
            ['Day', 'Week', 'WorkWeek', 'Month'].indexOf(this.parent.currentView) !== -1) {
            target = this.getWorkCellFromAppointmentElement(selectedEventElements[selectedEventElements.length - 1]);
            this.parent.eventBase.removeSelectedAppointmentClass();
        }
        if (!target) {
            return;
        }
        if (target.classList.contains(WORK_CELLS_CLASS) && !this.parent.element.querySelector('.' + POPUP_OPEN)) {
            const tableRows = this.parent.getTableRows();
            const curRowIndex = tableRows.indexOf(target.parentElement);
            let targetCell;
            if (isTimelineYear && isMultiple && this.parent.activeViewOptions.group.resources.length === 0) {
                targetCell = this.isInverseTableSelect() ? this.getVerticalUpDownCell(tableRows, target, curRowIndex, true) :
                    this.getHorizontalUpDownCell(tableRows, target, curRowIndex, true);
            }
            if ((curRowIndex > 0 || targetCell) && curRowIndex < tableRows.length) {
                targetCell = targetCell ? targetCell : (tableRows[curRowIndex - 1]).cells[target.cellIndex];
                if (this.parent.currentView === 'Year' && targetCell.classList.contains(OTHERMONTH_CLASS)) {
                    if (this.parent.activeView.getStartDate().getTime() < +targetCell.getAttribute('data-date')) {
                        targetCell = this.getYearUpDownCell(tableRows, curRowIndex - 1, target.cellIndex, true);
                    }
                    else {
                        return;
                    }
                }
                this.selectCells(isMultiple, targetCell);
            }
        }
        else if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {
            this.selectAppointment(true, target);
        }
    }
    processDown(e, isMultiple) {
        const isTimelineYear = this.parent.currentView === 'TimelineYear';
        if (isMultiple && this.cancelUpDownAction(isTimelineYear)) {
            return;
        }
        let target = (e.target);
        const selectedCells = this.parent.getSelectedCells();
        const selectedElements = this.parent.eventBase.getSelectedAppointments();
        const moreEventWrapper = this.parent.element.querySelector('.' + MORE_POPUP_WRAPPER_CLASS);
        const quickPopupWrapper = this.getQuickPopupElement();
        if (selectedCells.length > 0 && !e.target.classList.contains(WORK_CELLS_CLASS)) {
            target = selectedCells[selectedCells.length - 1];
        }
        if (selectedElements.length > 0 && !moreEventWrapper.classList.contains(POPUP_OPEN) &&
            !quickPopupWrapper.classList.contains(POPUP_OPEN) &&
            ['Day', 'Week', 'WorkWeek', 'Month'].indexOf(this.parent.currentView) !== -1) {
            target = this.getWorkCellFromAppointmentElement(selectedElements[selectedElements.length - 1]);
            this.parent.eventBase.removeSelectedAppointmentClass();
        }
        const tableRows = this.parent.getTableRows();
        if (!target) {
            return;
        }
        if (target.classList.contains(WORK_CELLS_CLASS) && !this.parent.element.querySelector('.' + POPUP_OPEN)) {
            const curRowIndex = tableRows.indexOf(target.parentElement);
            let targetCell;
            if (isTimelineYear && isMultiple && this.parent.activeViewOptions.group.resources.length === 0) {
                targetCell = this.isInverseTableSelect() ? this.getVerticalUpDownCell(tableRows, target, curRowIndex, false)
                    : this.getHorizontalUpDownCell(tableRows, target, curRowIndex, false);
            }
            if (curRowIndex >= 0 && ((curRowIndex < tableRows.length - 1) || targetCell)) {
                targetCell = targetCell ? targetCell : (tableRows[curRowIndex + 1]).cells[target.cellIndex];
                if (this.parent.currentView === 'Year' && targetCell.classList.contains(OTHERMONTH_CLASS)) {
                    if (this.parent.activeView.getEndDate().getTime() > +targetCell.getAttribute('data-date')) {
                        targetCell = this.getYearUpDownCell(tableRows, curRowIndex + 1, target.cellIndex, false);
                    }
                    else {
                        return;
                    }
                }
                this.selectCells(isMultiple, targetCell);
            }
        }
        else if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {
            this.selectAppointment(false, target);
        }
    }
    getYearUpDownCell(tableRows, rowIndex, cellIndex, isUp) {
        while (tableRows[parseInt(rowIndex.toString(), 10)] &&
            tableRows[parseInt(rowIndex.toString(), 10)].cells[parseInt(cellIndex.toString(), 10)].classList.contains(OTHERMONTH_CLASS)) {
            rowIndex = rowIndex + (isUp ? -1 : 1);
        }
        return tableRows[parseInt(rowIndex.toString(), 10)].cells[parseInt(cellIndex.toString(), 10)];
    }
    // eslint-disable-next-line max-len
    getHorizontalUpDownCell(tableRows, target, curRowIndex, isUp) {
        const row = tableRows[curRowIndex + (isUp ? -1 : 1)];
        let cell = row ? row.cells[target.cellIndex] : target;
        if (cell.classList.contains(OTHERMONTH_CLASS)) {
            const workCell = row.querySelector('.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')');
            const date = new Date(+workCell.getAttribute('data-date'));
            const query = '[data-date="' + new Date(date.getFullYear(), date.getMonth() + 1, 0).getTime() + '"]';
            cell = cell.cellIndex < workCell.cellIndex ? workCell : row.querySelector(query);
        }
        return cell;
    }
    // eslint-disable-next-line max-len
    getVerticalUpDownCell(tableRows, target, curRowIndex, isUp) {
        const hasRow = isUp && curRowIndex > 0 || !isUp && curRowIndex < tableRows.length - 1;
        let targetCell = hasRow ? tableRows[curRowIndex + (isUp ? -1 : 1)].cells[target.cellIndex] : undefined;
        if (!targetCell || targetCell.classList.contains(OTHERMONTH_CLASS)) {
            const column = tableRows[parseInt(curRowIndex.toString(), 10)].cells[target.cellIndex - (isUp ? 1 : -1)];
            if (column) {
                const dateAttr = +target.getAttribute('data-date') - (isUp ? MS_PER_DAY : -MS_PER_DAY);
                return this.parent.getContentTable().querySelector('.' + WORK_CELLS_CLASS + '[data-date="' + dateAttr + '"]');
            }
            targetCell = target;
        }
        return targetCell;
    }
    processLeftRight(target) {
        const tableEle = (this.parent.currentView === 'Year' ? target.closest('tbody') : this.parent.getContentTable());
        const curRowIndex = target.parentNode.sectionRowIndex;
        const key = {
            element: tableEle,
            rowIndex: curRowIndex,
            columnIndex: target.cellIndex,
            maxIndex: tableEle.rows[parseInt(curRowIndex.toString(), 10)].cells.length
        };
        return key;
    }
    getQuickPopupElement() {
        return (this.parent.isAdaptive ? document.body : this.parent.element).querySelector('.' + POPUP_WRAPPER_CLASS);
    }
    isCancelLeftRightAction(e, isMultiple, isTimelineYear) {
        const prevent = this.parent.currentView === 'MonthAgenda' || isTimelineYear && this.initialTarget.classList.contains(OTHERMONTH_CLASS);
        if (this.parent.currentView === 'Agenda' || (isMultiple && prevent)) {
            return true;
        }
        if (this.isPreventAction(e) && isMultiple) {
            return true;
        }
        const moreEventWrapper = this.parent.element.querySelector('.' + MORE_POPUP_WRAPPER_CLASS);
        const quickPopupWrapper = this.getQuickPopupElement();
        if (moreEventWrapper.classList.contains(POPUP_OPEN) || quickPopupWrapper.classList.contains(POPUP_OPEN)) {
            return true;
        }
        return false;
    }
    processRight(e, isMultiple) {
        const isTimelineYear = this.parent.currentView === 'TimelineYear';
        if (this.isCancelLeftRightAction(e, isMultiple, isTimelineYear)) {
            return;
        }
        const selectedCells = this.parent.getSelectedCells();
        let targetCell;
        const selectedAppointments = this.parent.eventBase.getSelectedAppointments();
        let target = (e.target);
        if (selectedCells.length > 0 && !target.classList.contains(WORK_CELLS_CLASS) &&
            !target.classList.contains(ALLDAY_CELLS_CLASS)) {
            target = selectedCells[selectedCells.length - 1];
        }
        if (selectedAppointments.length > 0) {
            target = this.getWorkCellFromAppointmentElement(selectedAppointments[selectedAppointments.length - 1]);
            this.parent.eventBase.removeSelectedAppointmentClass();
            if (!target) {
                return;
            }
        }
        if (target.classList.contains(WORK_CELLS_CLASS) &&
            (e.target).classList.contains(WORK_CELLS_CLASS)) {
            const key = this.processLeftRight(target);
            const targetDate = new Date(+target.getAttribute('data-date'));
            const isMonthEnd = this.parent.currentView === 'Year' && targetDate.getTime() === lastDateOfMonth(targetDate).getTime();
            if (key.columnIndex >= 0 && key.columnIndex < key.maxIndex - 1 && !isMonthEnd) {
                targetCell = this.calculateNextPrevDate(target, key.element.rows[key.rowIndex].cells[target.cellIndex + 1], 'right');
                if (isTimelineYear && isMultiple && targetCell.classList.contains(OTHERMONTH_CLASS)) {
                    targetCell = this.getTimelineYearTargetCell(key, target, true);
                }
                if (!isNullOrUndefined(targetCell)) {
                    this.selectCells(isMultiple, targetCell);
                }
            }
            else if (key.columnIndex === key.maxIndex - 1 || isMonthEnd) {
                if (!this.isInverseTableSelect() && key.rowIndex < key.element.rows.length - 1 && !isMonthEnd) {
                    targetCell = this.calculateNextPrevDate(target, key.element.rows[key.rowIndex + 1].cells[0], 'right');
                    const changeTargetCell = isTimelineYear && isMultiple && targetCell.classList.contains(OTHERMONTH_CLASS);
                    targetCell = changeTargetCell ? this.getHorizontalLeftRightCell(key, target, true) : targetCell;
                    if (!isNullOrUndefined(targetCell)) {
                        this.selectCells(isMultiple, targetCell);
                    }
                }
                else if (!isMultiple) {
                    if (isMonthEnd && targetDate.getTime() !== this.parent.activeView.getEndDate().getTime()) {
                        this.selectCells(isMultiple, this.parent.element.querySelector(':not(.' + OTHERMONTH_CLASS + ')[data-date="' + (targetDate.getTime() + MS_PER_DAY) + '"]'));
                        return;
                    }
                    const rowIndex = this.isInverseTableSelect() ? key.rowIndex : 0;
                    this.parent.changeDate(this.parent.activeView.getNextPreviousDate('next'), e);
                    const tableEle = this.parent.getContentTable();
                    const cell = isMonthEnd ? tableEle.rows[parseInt(rowIndex.toString(), 10)].querySelector('.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')')
                        : tableEle.rows[parseInt(rowIndex.toString(), 10)].cells[0];
                    this.selectCells(false, cell);
                }
            }
        }
        else if (target.classList.contains(ALLDAY_CELLS_CLASS)) {
            const curColIndex = target.cellIndex;
            const allDayRow = this.parent.getAllDayRow();
            const maxColIndex = allDayRow.cells.length;
            if (curColIndex >= 0 && curColIndex < maxColIndex - 1) {
                this.selectCells(isMultiple, allDayRow.cells[curColIndex + 1]);
            }
            else if (curColIndex === maxColIndex - 1 && !isMultiple) {
                this.parent.changeDate(this.parent.activeView.getNextPreviousDate('next'), e);
                const allDayRow = this.parent.getAllDayRow();
                this.selectCells(false, allDayRow.cells[0]);
            }
        }
    }
    processLeft(e, isMultiple) {
        const isTimelineYear = this.parent.currentView === 'TimelineYear';
        if (this.isCancelLeftRightAction(e, isMultiple, isTimelineYear)) {
            return;
        }
        let target = (e.target);
        const selectedCells = this.parent.getSelectedCells();
        let targetCell;
        if (selectedCells.length > 0 && !target.classList.contains(WORK_CELLS_CLASS) &&
            !target.classList.contains(ALLDAY_CELLS_CLASS)) {
            target = selectedCells[selectedCells.length - 1];
        }
        const selectedElements = this.parent.eventBase.getSelectedAppointments();
        if (selectedElements.length > 0) {
            target = this.getWorkCellFromAppointmentElement(selectedElements[selectedElements.length - 1]);
            this.parent.eventBase.removeSelectedAppointmentClass();
            if (!target) {
                return;
            }
        }
        if ((e.target).classList.contains(WORK_CELLS_CLASS) &&
            target.classList.contains(WORK_CELLS_CLASS)) {
            const key = this.processLeftRight(target);
            const targetDate = new Date(+target.getAttribute('data-date'));
            const isMonthStart = this.parent.currentView === 'Year' && targetDate.getTime() === firstDateOfMonth(targetDate).getTime();
            if (key.columnIndex > 0 && key.columnIndex < key.maxIndex && !isMonthStart) {
                targetCell = this.calculateNextPrevDate(target, key.element.rows[key.rowIndex].cells[target.cellIndex - 1], 'left');
                if (isTimelineYear && isMultiple && targetCell.classList.contains(OTHERMONTH_CLASS)) {
                    targetCell = this.getTimelineYearTargetCell(key, target, false);
                }
                if (!isNullOrUndefined(targetCell)) {
                    this.selectCells(isMultiple, targetCell);
                }
            }
            else if (key.columnIndex === 0 || isMonthStart) {
                if (!this.isInverseTableSelect() && key.rowIndex > 0) {
                    targetCell = this.calculateNextPrevDate(target, key.element.rows[key.rowIndex - 1].cells[key.maxIndex - 1], 'left');
                    const otherMonthCell = isTimelineYear && isMultiple && targetCell.classList.contains(OTHERMONTH_CLASS);
                    targetCell = otherMonthCell ? this.getHorizontalLeftRightCell(key, target, false) : targetCell;
                    if (!isNullOrUndefined(targetCell)) {
                        this.selectCells(isMultiple, targetCell);
                    }
                }
                else if (!isMultiple) {
                    if (isMonthStart && targetDate.getTime() !== this.parent.activeView.getStartDate().getTime()) {
                        this.selectCells(isMultiple, this.parent.element.querySelector('[data-date="' + (targetDate.getTime() - MS_PER_DAY) + '"]'));
                        return;
                    }
                    this.parent.changeDate(this.parent.activeView.getNextPreviousDate('previous'), e);
                    const tableEle = this.parent.getContentTable();
                    const rowIndex = this.isInverseTableSelect() ? key.rowIndex : tableEle.rows.length - 1;
                    let cell = tableEle.rows[parseInt(rowIndex.toString(), 10)].cells[key.maxIndex - 1];
                    if (isMonthStart) {
                        const tbody = this.parent.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody');
                        cell = tbody.item(tbody.length - 1).querySelector(':not(.' + OTHERMONTH_CLASS + ')[data-date="' + this.parent.activeView.getEndDate().getTime() + '"]');
                    }
                    this.selectCells(false, cell);
                }
            }
        }
        else if (target.classList.contains(ALLDAY_CELLS_CLASS)) {
            const curColIndex = target.cellIndex;
            const allDayRow = this.parent.getAllDayRow();
            const maxColIndex = allDayRow.cells.length;
            if (curColIndex > 0 && curColIndex < maxColIndex) {
                this.selectCells(isMultiple, allDayRow.cells[curColIndex - 1]);
            }
            else if (curColIndex === 0 && !isMultiple) {
                this.parent.changeDate(this.parent.activeView.getNextPreviousDate('previous'), e);
                const allDayRow = this.parent.getAllDayRow();
                this.selectCells(false, allDayRow.cells[maxColIndex - 1]);
            }
        }
    }
    getTimelineYearTargetCell(key, target, isRight) {
        return this.isInverseTableSelect() ? this.getVerticalLeftRightCell(target, isRight) :
            this.getHorizontalLeftRightCell(key, target, isRight);
    }
    getHorizontalLeftRightCell(key, target, isRight) {
        const row = key.element.rows[target.parentNode.sectionRowIndex + (isRight ? 1 : -1)];
        if (row) {
            const query = isRight ? '.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')'
                : '[data-date="' + ((+target.getAttribute('data-date')) - MS_PER_DAY) + '"]';
            return row.querySelector(query);
        }
        return target;
    }
    getVerticalLeftRightCell(target, isRight) {
        const date = new Date(+target.getAttribute('data-date'));
        const start = new Date(date.getFullYear(), date.getMonth() + (isRight ? 1 : -1), 1);
        const tableEle = this.parent.getContentTable();
        const targetCell = tableEle.querySelector('[data-date="' + start.getTime() + '"]');
        if (targetCell.parentNode.sectionRowIndex > target.parentNode.sectionRowIndex) {
            return targetCell;
        }
        return tableEle.querySelector('[data-date="' + new Date(start.getFullYear(), start.getMonth() + 1, 0).getTime() + '"]');
    }
    calculateNextPrevDate(currentCell, target, type) {
        const initialId = this.initialTarget.getAttribute('data-group-index');
        if (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.currentView === 'Month') {
            if (currentCell && target && target.getAttribute('data-group-index') !== initialId) {
                const currentDate = this.parent.getDateFromElement(currentCell);
                const nextPrevDate = (type === 'right') ? new Date(currentDate.setDate(currentDate.getDate() + 1))
                    : new Date(currentDate.setDate(currentDate.getDate() - 1));
                target = [].slice.call(this.parent.element.querySelectorAll('td[data-date="'
                    + nextPrevDate.getTime().toString() + '"]' + '[data-group-index="' + initialId + '"]'))[0];
            }
        }
        return target;
    }
    getFocusableElements(container) {
        const queryString = 'a[href]:not([tabindex="-1"]),input:not([disabled]):not([tabindex="-1"]),' +
            'textarea:not([disabled]):not([tabindex="-1"]),button:not([disabled]):not([tabindex="-1"]),' +
            'select:not([disabled]):not([tabindex="-1"]),[tabindex]:not([tabindex="-1"]),[contentEditable=true]:not([tabindex="-1"])';
        return [].slice.call(container.querySelectorAll(queryString));
    }
    processTabOnPopup(e, popupElement) {
        let focusableElements = this.getFocusableElements(popupElement);
        focusableElements = focusableElements.filter((element) => {
            const footerEle = this.parent.element.querySelector('.' + POPUP_FOOTER_CLASS);
            if (footerEle && footerEle.offsetParent) {
                return !(element.classList.contains(EDIT_CLASS) || element.classList.contains(DELETE_CLASS));
            }
            else {
                return !(element.classList.contains(EDIT_EVENT_CLASS) || element.classList.contains(DELETE_EVENT_CLASS));
            }
        });
        const firstEle = focusableElements[0];
        const lastEle = focusableElements[focusableElements.length - 1];
        if (!isNullOrUndefined(lastEle) && document.activeElement === lastEle && !e.shiftKey) {
            e.preventDefault();
            firstEle.focus();
        }
        if (!isNullOrUndefined(firstEle) && document.activeElement === firstEle && e.shiftKey) {
            e.preventDefault();
            lastEle.focus();
        }
    }
    processTab(e, isReverse) {
        let target = e.target;
        if (target.classList.contains(INLINE_SUBJECT_CLASS) && this.parent.inlineModule) {
            target = target.closest('.e-appointment');
            this.parent.inlineModule.inlineCrudActions(e.target);
        }
        if (this.parent.currentView === 'TimelineYear' && target.classList.contains(OTHERMONTH_CLASS)) {
            if (target.classList.contains(SELECTED_CELL_CLASS)) {
                this.parent.removeSelectedClass();
            }
            return;
        }
        const popupWrapper = closest(target, '.' + POPUP_WRAPPER_CLASS + ',.' + MORE_POPUP_WRAPPER_CLASS);
        if (popupWrapper && popupWrapper.classList.contains(POPUP_OPEN)) {
            if (popupWrapper.classList.contains(MORE_POPUP_WRAPPER_CLASS)) {
                this.parent.eventBase.removeSelectedAppointmentClass();
            }
            this.processTabOnPopup(e, popupWrapper);
            return;
        }
        if (target.classList.contains(ROOT)) {
            this.parent.eventBase.removeSelectedAppointmentClass();
            return;
        }
        if (target.classList.contains(RESOURCE_CELLS_CLASS) && this.parent.activeView.isTimelineView()
            && this.parent.activeViewOptions.group.resources.length > 0) {
            const index = parseInt(target.getAttribute('data-group-index'), 10);
            const appSelector = `.${APPOINTMENT_CLASS}[data-group-index="${isReverse ? index - 1 : index}"]`;
            const appElements = [].slice.call(this.parent.element.querySelectorAll(appSelector));
            if (appElements.length > 0) {
                this.parent.eventBase.removeSelectedAppointmentClass();
                const focusAppointment = isReverse ? appElements.slice(-1)[0] : appElements[0];
                this.parent.eventBase.addSelectedAppointments([focusAppointment], true);
                focusAppointment.focus();
                e.preventDefault();
            }
            else if (index + 1 === this.parent.resourceBase.lastResourceLevel.length) {
                this.parent.element.focus();
                e.preventDefault();
            }
            else if (this.parent.virtualScrollModule) {
                const virtual = this.parent.element.querySelector('.' + VIRTUAL_TRACK_CLASS);
                const averageRowHeight = Math.round(virtual.offsetHeight / this.parent.resourceBase.expandedResources.length);
                this.parent.element.querySelector('.e-content-wrap').scrollTop = ((isReverse ? index - 1 : index + 1) * averageRowHeight);
                this.parent.virtualScrollModule.virtualScrolling();
            }
            else {
                this.setScrollPosition(index);
            }
            return;
        }
        if (target.classList.contains(APPOINTMENT_CLASS)) {
            let appElements = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));
            const isTimelineYear = this.parent.currentView === 'TimelineYear';
            const isTimeline = this.parent.activeView.isTimelineView() && !isTimelineYear;
            if ((isTimeline || isTimelineYear && this.parent.activeViewOptions.orientation === 'Vertical') && this.parent.activeViewOptions.group.resources.length > 0) {
                const index = parseInt(target.getAttribute('data-group-index'), 10);
                appElements = [].slice.call(this.parent.element.querySelectorAll(`.${APPOINTMENT_CLASS}[data-group-index="${index}"]`));
                const resCellSelector = `.${RESOURCE_CELLS_CLASS}[data-group-index="${isReverse ? index : index + 1}"]`;
                const resourceCell = this.parent.element.querySelector(resCellSelector);
                if (resourceCell && (isReverse && target.getAttribute('data-guid') === appElements[0].getAttribute('data-guid') ||
                    !isReverse && target.getAttribute('data-guid') === appElements.slice(-1)[0].getAttribute('data-guid'))) {
                    this.parent.eventBase.removeSelectedAppointmentClass();
                    if (this.parent.virtualScrollModule) {
                        resourceCell.focus({ preventScroll: true });
                    }
                    else {
                        resourceCell.focus();
                    }
                    if (this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0 &&
                        isNullOrUndefined(this.parent.virtualScrollModule)) {
                        this.setScrollPosition(index);
                    }
                    e.preventDefault();
                    return;
                }
            }
            const selectedAppointments = this.parent.eventBase.getSelectedAppointments();
            if (selectedAppointments.length > 0) {
                target = selectedAppointments[selectedAppointments.length - 1];
            }
            this.parent.eventBase.removeSelectedAppointmentClass();
            if (!isReverse && target.getAttribute('data-guid') === appElements[appElements.length - 1].getAttribute('data-guid') ||
                isReverse && target.getAttribute('data-guid') === appElements[0].getAttribute('data-guid')) {
                return;
            }
            if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {
                this.selectAppointment(isReverse, target);
                e.preventDefault();
            }
            return;
        }
        const selectedCells = this.parent.getSelectedCells();
        if (selectedCells.length > 0 && !target.classList.contains(APPOINTMENT_CLASS)) {
            target = selectedCells[selectedCells.length - 1];
            this.selectAppointmentElementFromWorkCell(isReverse, target);
            e.preventDefault();
            return;
        }
        if (target && !target.classList.contains(RESOURCE_CELLS_CLASS) && this.parent.activeView.isTimelineView()
            && this.parent.activeViewOptions.group.resources.length > 0) {
            this.processTabOnResourceCells(target, isReverse);
        }
    }
    processDelete(e) {
        let activeEle = document.activeElement;
        if (this.parent.currentView === 'MonthAgenda') {
            const selectedEle = this.parent.eventBase.getSelectedEvents().element;
            activeEle = ((selectedEle && isNullOrUndefined(selectedEle.length)) ? selectedEle : selectedEle[0]);
        }
        if (activeEle && activeEle.classList.contains(APPOINTMENT_CLASS)) {
            addClass([activeEle], APPOINTMENT_BORDER);
            this.parent.activeEventData = this.parent.eventBase.getSelectedEvents();
            if (this.parent.activeViewOptions.readonly || activeEle.classList.contains(READ_ONLY) ||
                !this.parent.eventSettings.allowDeleting) {
                return;
            }
            this.parent.quickPopup.deleteClick(e);
        }
    }
    processCtrlShiftNavigationArrows(e) {
        if (this.parent.activeViewOptions.group.resources.length > 0 && document.activeElement.classList.contains(APPOINTMENT_CLASS)) {
            const groupIndex = parseInt(document.activeElement.getAttribute('data-group-index'), 10);
            let index = (e.action === 'ctrlShiftLeftArrow' || e.action === 'ctrlShiftUpArrow') ? groupIndex - 1 : groupIndex + 1;
            index = index < 0 ? 0 : index > this.parent.resourceBase.lastResourceLevel.length ?
                this.parent.resourceBase.lastResourceLevel.length : index;
            let eventEle = [];
            while (eventEle.length === 0 && index >= 0 && index <= this.parent.resourceBase.lastResourceLevel.length) {
                eventEle = [].slice.call(this.parent.element.querySelectorAll(`.${APPOINTMENT_CLASS}[data-group-index="${index}"]`));
                index = (e.action === 'ctrlShiftLeftArrow' || e.action === 'ctrlShiftUpArrow') ? index - 1 : index + 1;
            }
            const nextAppEle = eventEle[0];
            if (nextAppEle) {
                this.parent.eventBase.removeSelectedAppointmentClass();
                this.parent.eventBase.addSelectedAppointments([nextAppEle], true);
                nextAppEle.focus();
            }
        }
        else if (this.parent.activeViewOptions.group.resources.length > 0 &&
            !document.activeElement.classList.contains(APPOINTMENT_CLASS)) {
            const index = this.parent.resourceBase.renderedResources[0].groupIndex;
            const appSelector = `.${APPOINTMENT_CLASS}[data-group-index="${index}"]`;
            const appElements = [].slice.call(this.parent.element.querySelectorAll(appSelector));
            if (appElements.length > 0) {
                this.parent.eventBase.removeSelectedAppointmentClass();
                const focusAppointment = appElements[0];
                this.parent.eventBase.addSelectedAppointments([focusAppointment], true);
                focusAppointment.focus();
                e.preventDefault();
            }
        }
    }
    processEscape(event) {
        this.parent.quickPopup.onClosePopup(event);
        this.parent.quickPopup.morePopup.hide();
        if (this.parent.headerModule) {
            this.parent.headerModule.hideHeaderPopup();
        }
        if (this.parent.inlineModule) {
            this.parent.inlineModule.removeInlineAppointmentElement();
        }
    }
    isPreventAction(e) {
        const target = closest(e.target, '.' + RESOURCE_GROUP_CELLS_CLASS);
        if (this.parent.activeView.isTimelineView() && !isNullOrUndefined(target)) {
            return true;
        }
        return false;
    }
    processTabOnResourceCells(target, isReverse) {
        const tabElements = [].slice.call(this.parent.element.querySelectorAll('[tabIndex="0"]'));
        const currentTabIndex = tabElements.indexOf(target);
        const nextTabElement = !isReverse ? tabElements[currentTabIndex + 1] : tabElements[currentTabIndex - 1];
        if (nextTabElement && nextTabElement.classList.contains(RESOURCE_CELLS_CLASS)) {
            const groupIndex = parseInt(nextTabElement.getAttribute('data-group-index'), 10);
            if (this.parent.virtualScrollModule) {
                const resColWrap = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);
                const resCells = [].slice.call(this.parent.element.querySelectorAll('.' + RESOURCE_CELLS_CLASS));
                resCells.forEach((element) => {
                    if (element.getBoundingClientRect().top < resColWrap.getBoundingClientRect().top) {
                        element.setAttribute('tabindex', '-1');
                    }
                });
            }
            else {
                this.setScrollPosition(groupIndex);
            }
        }
    }
    setScrollPosition(index) {
        const workCell = this.parent.element.querySelector(`.${WORK_CELLS_CLASS}[data-group-index="${index}"]`);
        if (workCell) {
            this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS).scrollTop = workCell.offsetTop;
        }
    }
    /**
     * Get module name.
     *
     * @returns {string} Returns the module name.
     */
    getModuleName() {
        return 'keyboard';
    }
    /**
     * To destroy the keyboard module.
     *
     * @returns {void}
     * @private
     */
    destroy() {
        this.removeEventListener();
        this.selectedCells = [];
        this.keyboardModule.destroy();
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * data module is used to generate query and data source.
 *
 * @private
 */
class Data {
    /**
     * Constructor for data module
     *
     * @param {Schedule} parent Accepts the schedule element instance
     * @param {Object | DataManager} dataSource Accepts the datasource as JSON objects or DataManager
     * @param {Query} query Accepts the query to process the data
     * @private
     */
    constructor(parent, dataSource, query) {
        this.parent = parent;
        this.initDataManager(dataSource, query);
    }
    /**
     * The function used to initialize dataManager and query
     *
     * @param {Object | DataManager} dataSource Accepts the datasource as JSON objects or DataManager
     * @param {Query} query Accepts the query to process the data
     * @returns {void}
     * @private
     */
    initDataManager(dataSource, query) {
        this.dataManager = dataSource instanceof DataManager ? dataSource : new DataManager(dataSource);
        this.query = query instanceof Query ? query : new Query();
    }
    /**
     * The function used to generate updated Query from schedule model
     *
     * @param {Date} startDate Accepts the start date
     * @param {Date} endDate Accepts the end date
     * @returns {void}
     * @private
     */
    generateQuery(startDate, endDate) {
        const query = this.query.clone();
        if (this.parent && this.parent.eventSettings.includeFiltersInQuery && startDate && endDate) {
            const dateQuery = this.getStartEndQuery(startDate, endDate);
            const recurrenceQuery = new Predicate(this.parent.eventFields.recurrenceRule, 'notequal', null).and(new Predicate(this.parent.eventFields.recurrenceRule, 'notequal', ''));
            return query.where(dateQuery.or(recurrenceQuery));
        }
        if (startDate) {
            query.addParams('StartDate', startDate.toISOString());
        }
        if (endDate) {
            query.addParams('EndDate', endDate.toISOString());
        }
        return query;
    }
    /**
     * The function used to generate updated Query from schedule model
     *
     * @param {Date} startDate Accepts the start date
     * @param {Date} endDate Accepts the end date
     * @returns {void}
     * @private
     */
    getStartEndQuery(startDate, endDate) {
        const fieldMapping = this.parent.eventFields;
        const dateQuery = new Predicate(fieldMapping.startTime, 'greaterthanorequal', startDate)
            .and(new Predicate(fieldMapping.endTime, 'greaterthanorequal', startDate))
            .and(new Predicate(fieldMapping.startTime, 'lessthan', endDate))
            .or(new Predicate(fieldMapping.startTime, 'lessthanorequal', startDate)
            .and(new Predicate(fieldMapping.endTime, 'greaterthan', startDate)));
        return dateQuery;
    }
    /**
     * The function used to get dataSource by executing given Query
     *
     * @param  {Query} query - A Query that specifies to generate dataSource
     * @returns {void}
     * @private
     */
    getData(query) {
        return this.dataManager.executeQuery(query);
    }
    /**
     * To destroy the crud module.
     *
     * @returns {void}
     * @private
     */
    destroy() {
        this.dataManager = null;
        this.query = null;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/** @private */
class Gregorian {
    firstDateOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth());
    }
    lastDateOfMonth(dt) {
        return new Date(dt.getFullYear(), dt.getMonth() + 1, 0);
    }
    isMonthStart(date) {
        return (date.getDate() === 1);
    }
    getLeapYearDaysCount() {
        return 366;
    }
    getYearDaysCount(date, interval) {
        return ((date.getFullYear() + interval) % 4 === 0) ? 366 : 365;
    }
    getDate(date) {
        return date.getDate();
    }
    getMonth(date) {
        return (date.getMonth() + 1);
    }
    getFullYear(date) {
        return date.getFullYear();
    }
    getYearLastDate(date, interval) {
        return new Date(date.getFullYear() + interval, 0, 0);
    }
    getMonthDaysCount(date) {
        return this.lastDateOfMonth(date).getDate();
    }
    getMonthStartDate(date) {
        return new Date(date.getFullYear(), date.getMonth(), 1, date.getHours(), date.getMinutes());
    }
    getMonthEndDate(date) {
        date.setDate(1);
        return new Date(date.setMonth(date.getMonth() + 1));
    }
    getExpectedDays(date, days) {
        return days;
    }
    setDate(dateObj, date) {
        dateObj.setDate(date);
    }
    setValidDate(date, interval, startDate, monthValue, beginDate) {
        if (!isNullOrUndefined(beginDate)) {
            date.setMonth((beginDate ? monthValue : date.getMonth()) + interval);
        }
        else {
            date.setMonth(date.getMonth() + interval, startDate);
        }
    }
    setMonth(date, interval, startDate) {
        date.setDate(1);
        date.setFullYear(date.getFullYear());
        date.setMonth(interval - 1);
        const maxDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
        date.setDate(Math.min(startDate, maxDay));
    }
    addYears(date, interval) {
        date.setFullYear(date.getFullYear() + interval);
    }
    isSameMonth(date1, date2) {
        return (date1.getMonth() === date2.getMonth());
    }
    checkMonth(date, months) {
        return (months.indexOf(date.getMonth() + 1) === -1);
    }
    compareMonth(date1, date2) {
        return (date1.getMonth() > date2.getMonth());
    }
    isSameYear(date1, date2) {
        return (date1.getFullYear() === date2.getFullYear());
    }
    isLastMonth(date) {
        return (date.getMonth() === 11);
    }
    isLeapYear(year, interval) {
        return ((year + interval) % 4 === 0);
    }
}
/** @private */
class Islamic {
    firstDateOfMonth(date) {
        const hDate = this.getHijriDate(date);
        const gDate = HijriParser.toGregorian(hDate.year, hDate.month, 1);
        return gDate;
    }
    lastDateOfMonth(date) {
        const hDate = this.getHijriDate(date);
        const daysInMonth = this.getDaysInMonth(hDate.month, hDate.year);
        const gDate = HijriParser.toGregorian(hDate.year, hDate.month, daysInMonth);
        let finalGDate = new Date(gDate.getTime());
        finalGDate = new Date(finalGDate.setDate(finalGDate.getDate() + 1));
        let finalHDate = this.getHijriDate(finalGDate);
        if (hDate.month === finalHDate.month) {
            return finalGDate;
        }
        finalHDate = this.getHijriDate(gDate);
        if (hDate.month === finalHDate.month) {
            return gDate;
        }
        return new Date(gDate.setDate(gDate.getDate() - 1));
    }
    isMonthStart(date) {
        const hijriDate = this.getHijriDate(date);
        return (hijriDate.date === 1);
    }
    getLeapYearDaysCount() {
        return 355;
    }
    getYearDaysCount(date, interval) {
        const hDate = this.getHijriDate(date);
        return this.isLeapYear(hDate.year, interval) ? 355 : 354;
    }
    getDate(date) {
        const hijriDate = this.getHijriDate(date);
        return hijriDate.date;
    }
    getMonth(date) {
        const hDate = this.getHijriDate(date);
        return hDate.month;
    }
    getFullYear(date) {
        const hDate = this.getHijriDate(date);
        return hDate.year;
    }
    getYearLastDate(date, interval) {
        const hDate = this.getHijriDate(date);
        const gDate = HijriParser.toGregorian(hDate.year + interval, 1, 0);
        return gDate;
    }
    getMonthDaysCount(date) {
        const maxDate = this.lastDateOfMonth(date);
        const hijriDate = this.getHijriDate(maxDate);
        return hijriDate.date;
    }
    getMonthStartDate(date) {
        const firstDate = this.firstDateOfMonth(date);
        return new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate(), date.getHours(), date.getMinutes());
    }
    getMonthEndDate(date) {
        const lastDate = this.lastDateOfMonth(date);
        lastDate.setDate(lastDate.getDate() + 1);
        return new Date(lastDate.setMonth(lastDate.getMonth()));
    }
    getExpectedDays(date, days) {
        const hDate = this.getHijriDate(date);
        const day = [];
        for (let i = 0; i < days.length; i++) {
            const gDate = HijriParser.toGregorian(hDate.year, hDate.month, days[parseInt(i.toString(), 10)]);
            day.push(gDate.getDate());
        }
        return day;
    }
    setDate(dateObj, date) {
        const hDate = this.getHijriDate(dateObj);
        const gDate = HijriParser.toGregorian(hDate.year, hDate.month, date);
        this.updateDateObj(dateObj, gDate);
    }
    setValidDate(date, interval, startDate, monthValue, beginDate) {
        const firstDate = (!isNullOrUndefined(beginDate)) ? this.firstDateOfMonth(beginDate) : date;
        const hDate = this.getHijriDate(firstDate);
        const gDate = HijriParser.toGregorian(hDate.year, hDate.month + interval, startDate);
        this.updateDateObj(date, gDate);
    }
    setMonth(date, interval, startDate) {
        const hDate = this.getHijriDate(date);
        const gDate = HijriParser.toGregorian(hDate.year, interval, startDate);
        this.updateDateObj(date, gDate);
    }
    addYears(date, interval, monthValue) {
        const hDate = this.getHijriDate(date);
        const gDate = HijriParser.toGregorian(hDate.year + interval, monthValue, 1);
        this.updateDateObj(date, gDate);
    }
    isSameMonth(date1, date2) {
        const currentHijri = this.getHijriDate(date1);
        const tempHijri = this.getHijriDate(date2);
        return (currentHijri.month === tempHijri.month);
    }
    checkMonth(date, months) {
        const hDate = this.getHijriDate(date);
        return (months.indexOf(hDate.month) === -1);
    }
    compareMonth(date1, date2) {
        const hDate = this.getHijriDate(date1);
        const hDate1 = this.getHijriDate(date2);
        return (hDate.month > hDate1.month);
    }
    isSameYear(date1, date2) {
        const hDate = this.getHijriDate(date1);
        const hDate1 = this.getHijriDate(date2);
        return (hDate.year === hDate1.year);
    }
    isLastMonth(date) {
        const hDate = this.getHijriDate(date);
        return (hDate.month === 12);
    }
    updateDateObj(date, gDate) {
        date.setFullYear(gDate.getFullYear(), gDate.getMonth(), gDate.getDate());
    }
    isLeapYear(year, interval) {
        return (14 + 11 * (year + interval)) % 30 < 11;
    }
    getDaysInMonth(month, year) {
        let length = 0;
        length = 29 + ((month + 1) % 2);
        if (month === 11 && this.isLeapYear(year, 0)) {
            length++;
        }
        return length;
    }
    getHijriDate(date) {
        return HijriParser.getHijriDate(date);
    }
}

/**
 * Time zone
 */
class Timezone {
    constructor() {
        this.timezoneData = [];
        this.timezoneData = this.getTimezoneData();
    }
    offset(date, timezone) {
        const localOffset = date.getTimezoneOffset();
        try {
            const convertedDate = new Date(date.toLocaleString('en-US', { timeZone: timezone }));
            if (!isNaN(convertedDate.getTime())) {
                return ((date.getTime() - convertedDate.getTime()) / 60000) + localOffset;
            }
            return 0;
        }
        catch (error) {
            return 0;
        }
    }
    convert(date, fromOffset, toOffset) {
        if (typeof fromOffset === 'string') {
            fromOffset = this.offset(date, fromOffset);
        }
        if (typeof toOffset === 'string') {
            toOffset = this.offset(date, toOffset);
        }
        const fromLocalOffset = date.getTimezoneOffset();
        date = new Date(date.getTime() + (fromOffset - toOffset) * 60000);
        const toLocalOffset = date.getTimezoneOffset();
        return new Date(date.getTime() + (toLocalOffset - fromLocalOffset) * 60000);
    }
    add(date, timezone) {
        return this.convert(date, date.getTimezoneOffset(), timezone);
    }
    remove(date, timezone) {
        return this.convert(date, timezone, date.getTimezoneOffset());
    }
    removeLocalOffset(date) {
        return new Date(date.getTime() - (date.getTimezoneOffset() * 60000));
    }
    getLocalTimezoneName() {
        return window.Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC' : 'UTC';
    }
    getTimezoneData() {
        return timezoneData;
    }
}
const timezoneData = [
    { Value: 'Pacific/Niue', Text: '(UTC-11:00) Niue' },
    { Value: 'Pacific/Pago_Pago', Text: '(UTC-11:00) Pago Pago' },
    { Value: 'Pacific/Honolulu', Text: '(UTC-10:00) Hawaii Time' },
    { Value: 'Pacific/Rarotonga', Text: '(UTC-10:00) Rarotonga' },
    { Value: 'Pacific/Tahiti', Text: '(UTC-10:00) Tahiti' },
    { Value: 'Pacific/Marquesas', Text: '(UTC-09:30) Marquesas' },
    { Value: 'America/Anchorage', Text: '(UTC-09:00) Alaska Time' },
    { Value: 'Pacific/Gambier', Text: '(UTC-09:00) Gambier' },
    { Value: 'America/Los_Angeles', Text: '(UTC-08:00) Pacific Time' },
    { Value: 'America/Tijuana', Text: '(UTC-08:00) Pacific Time - Tijuana' },
    { Value: 'America/Vancouver', Text: '(UTC-08:00) Pacific Time - Vancouver' },
    { Value: 'America/Whitehorse', Text: '(UTC-08:00) Pacific Time - Whitehorse' },
    { Value: 'Pacific/Pitcairn', Text: '(UTC-08:00) Pitcairn' },
    { Value: 'America/Denver', Text: '(UTC-07:00) Mountain Time' },
    { Value: 'America/Phoenix', Text: '(UTC-07:00) Mountain Time - Arizona' },
    { Value: 'America/Mazatlan', Text: '(UTC-07:00) Mountain Time - Chihuahua, Mazatlan' },
    { Value: 'America/Dawson_Creek', Text: '(UTC-07:00) Mountain Time - Dawson Creek' },
    { Value: 'America/Edmonton', Text: '(UTC-07:00) Mountain Time - Edmonton' },
    { Value: 'America/Hermosillo', Text: '(UTC-07:00) Mountain Time - Hermosillo' },
    { Value: 'America/Yellowknife', Text: '(UTC-07:00) Mountain Time - Yellowknife' },
    { Value: 'America/Belize', Text: '(UTC-06:00) Belize' },
    { Value: 'America/Chicago', Text: '(UTC-06:00) Central Time' },
    { Value: 'America/Mexico_City', Text: '(UTC-06:00) Central Time - Mexico City' },
    { Value: 'America/Regina', Text: '(UTC-06:00) Central Time - Regina' },
    { Value: 'America/Tegucigalpa', Text: '(UTC-06:00) Central Time - Tegucigalpa' },
    { Value: 'America/Winnipeg', Text: '(UTC-06:00) Central Time - Winnipeg' },
    { Value: 'America/Costa_Rica', Text: '(UTC-06:00) Costa Rica' },
    { Value: 'America/El_Salvador', Text: '(UTC-06:00) El Salvador' },
    { Value: 'Pacific/Galapagos', Text: '(UTC-06:00) Galapagos' },
    { Value: 'America/Guatemala', Text: '(UTC-06:00) Guatemala' },
    { Value: 'America/Managua', Text: '(UTC-06:00) Managua' },
    { Value: 'America/Cancun', Text: '(UTC-05:00) America Cancun' },
    { Value: 'America/Bogota', Text: '(UTC-05:00) Bogota' },
    { Value: 'Pacific/Easter', Text: '(UTC-05:00) Easter Island' },
    { Value: 'America/New_York', Text: '(UTC-05:00) Eastern Time' },
    { Value: 'America/Iqaluit', Text: '(UTC-05:00) Eastern Time - Iqaluit' },
    { Value: 'America/Toronto', Text: '(UTC-05:00) Eastern Time - Toronto' },
    { Value: 'America/Guayaquil', Text: '(UTC-05:00) Guayaquil' },
    { Value: 'America/Havana', Text: '(UTC-05:00) Havana' },
    { Value: 'America/Jamaica', Text: '(UTC-05:00) Jamaica' },
    { Value: 'America/Lima', Text: '(UTC-05:00) Lima' },
    { Value: 'America/Nassau', Text: '(UTC-05:00) Nassau' },
    { Value: 'America/Panama', Text: '(UTC-05:00) Panama' },
    { Value: 'America/Port-au-Prince', Text: '(UTC-05:00) Port-au-Prince' },
    { Value: 'America/Rio_Branco', Text: '(UTC-05:00) Rio Branco' },
    { Value: 'America/Halifax', Text: '(UTC-04:00) Atlantic Time - Halifax' },
    { Value: 'America/Barbados', Text: '(UTC-04:00) Barbados' },
    { Value: 'Atlantic/Bermuda', Text: '(UTC-04:00) Bermuda' },
    { Value: 'America/Boa_Vista', Text: '(UTC-04:00) Boa Vista' },
    { Value: 'America/Caracas', Text: '(UTC-04:00) Caracas' },
    { Value: 'America/Curacao', Text: '(UTC-04:00) Curacao' },
    { Value: 'America/Grand_Turk', Text: '(UTC-04:00) Grand Turk' },
    { Value: 'America/Guyana', Text: '(UTC-04:00) Guyana' },
    { Value: 'America/La_Paz', Text: '(UTC-04:00) La Paz' },
    { Value: 'America/Manaus', Text: '(UTC-04:00) Manaus' },
    { Value: 'America/Martinique', Text: '(UTC-04:00) Martinique' },
    { Value: 'America/Port_of_Spain', Text: '(UTC-04:00) Port of Spain' },
    { Value: 'America/Porto_Velho', Text: '(UTC-04:00) Porto Velho' },
    { Value: 'America/Puerto_Rico', Text: '(UTC-04:00) Puerto Rico' },
    { Value: 'America/Santo_Domingo', Text: '(UTC-04:00) Santo Domingo' },
    { Value: 'America/Thule', Text: '(UTC-04:00) Thule' },
    { Value: 'America/St_Johns', Text: '(UTC-03:30) Newfoundland Time - St. Johns' },
    { Value: 'America/Araguaina', Text: '(UTC-03:00) Araguaina' },
    { Value: 'America/Asuncion', Text: '(UTC-03:00) Asuncion' },
    { Value: 'America/Belem', Text: '(UTC-03:00) Belem' },
    { Value: 'America/Argentina/Buenos_Aires', Text: '(UTC-03:00) Buenos Aires' },
    { Value: 'America/Campo_Grande', Text: '(UTC-03:00) Campo Grande' },
    { Value: 'America/Cayenne', Text: '(UTC-03:00) Cayenne' },
    { Value: 'America/Cuiaba', Text: '(UTC-03:00) Cuiaba' },
    { Value: 'America/Fortaleza', Text: '(UTC-03:00) Fortaleza' },
    { Value: 'America/Godthab', Text: '(UTC-03:00) Godthab' },
    { Value: 'America/Maceio', Text: '(UTC-03:00) Maceio' },
    { Value: 'America/Miquelon', Text: '(UTC-03:00) Miquelon' },
    { Value: 'America/Montevideo', Text: '(UTC-03:00) Montevideo' },
    { Value: 'Antarctica/Palmer', Text: '(UTC-03:00) Palmer' },
    { Value: 'America/Paramaribo', Text: '(UTC-03:00) Paramaribo' },
    { Value: 'America/Punta_Arenas', Text: '(UTC-03:00) Punta Arenas' },
    { Value: 'America/Recife', Text: '(UTC-03:00) Recife' },
    { Value: 'Antarctica/Rothera', Text: '(UTC-03:00) Rothera' },
    { Value: 'America/Bahia', Text: '(UTC-03:00) Salvador' },
    { Value: 'America/Santiago', Text: '(UTC-03:00) Santiago' },
    { Value: 'Atlantic/Stanley', Text: '(UTC-03:00) Stanley' },
    { Value: 'America/Noronha', Text: '(UTC-02:00) Noronha' },
    { Value: 'America/Sao_Paulo', Text: '(UTC-02:00) Sao Paulo' },
    { Value: 'Atlantic/South_Georgia', Text: '(UTC-02:00) South Georgia' },
    { Value: 'Atlantic/Azores', Text: '(UTC-01:00) Azores' },
    { Value: 'Atlantic/Cape_Verde', Text: '(UTC-01:00) Cape Verde' },
    { Value: 'America/Scoresbysund', Text: '(UTC-01:00) Scoresbysund' },
    { Value: 'Africa/Abidjan', Text: '(UTC+00:00) Abidjan' },
    { Value: 'Africa/Accra', Text: '(UTC+00:00) Accra' },
    { Value: 'Africa/Bissau', Text: '(UTC+00:00) Bissau' },
    { Value: 'Atlantic/Canary', Text: '(UTC+00:00) Canary Islands' },
    { Value: 'Africa/Casablanca', Text: '(UTC+00:00) Casablanca' },
    { Value: 'America/Danmarkshavn', Text: '(UTC+00:00) Danmarkshavn' },
    { Value: 'Europe/Dublin', Text: '(UTC+00:00) Dublin' },
    { Value: 'Africa/El_Aaiun', Text: '(UTC+00:00) El Aaiun' },
    { Value: 'Atlantic/Faroe', Text: '(UTC+00:00) Faeroe' },
    { Value: 'Etc/UTC', Text: '(UTC+00:00) UTC (no daylight saving)' },
    { Value: 'Europe/Lisbon', Text: '(UTC+00:00) Lisbon' },
    { Value: 'Europe/London', Text: '(UTC+00:00) London' },
    { Value: 'Africa/Monrovia', Text: '(UTC+00:00) Monrovia' },
    { Value: 'Atlantic/Reykjavik', Text: '(UTC+00:00) Reykjavik' },
    { Value: 'UTC', Text: 'UTC' },
    { Value: 'Africa/Algiers', Text: '(UTC+01:00) Algiers' },
    { Value: 'Europe/Amsterdam', Text: '(UTC+01:00) Amsterdam' },
    { Value: 'Europe/Andorra', Text: '(UTC+01:00) Andorra' },
    { Value: 'Europe/Berlin', Text: '(UTC+01:00) Berlin' },
    { Value: 'Europe/Brussels', Text: '(UTC+01:00) Brussels' },
    { Value: 'Europe/Budapest', Text: '(UTC+01:00) Budapest' },
    { Value: 'Europe/Belgrade', Text: '(UTC+01:00) Central European Time - Belgrade' },
    { Value: 'Europe/Prague', Text: '(UTC+01:00) Central European Time - Prague' },
    { Value: 'Africa/Ceuta', Text: '(UTC+01:00) Ceuta' },
    { Value: 'Europe/Copenhagen', Text: '(UTC+01:00) Copenhagen' },
    { Value: 'Europe/Gibraltar', Text: '(UTC+01:00) Gibraltar' },
    { Value: 'Africa/Lagos', Text: '(UTC+01:00) Lagos' },
    { Value: 'Europe/Luxembourg', Text: '(UTC+01:00) Luxembourg' },
    { Value: 'Europe/Madrid', Text: '(UTC+01:00) Madrid' },
    { Value: 'Europe/Malta', Text: '(UTC+01:00) Malta' },
    { Value: 'Europe/Monaco', Text: '(UTC+01:00) Monaco' },
    { Value: 'Africa/Ndjamena', Text: '(UTC+01:00) Ndjamena' },
    { Value: 'Europe/Oslo', Text: '(UTC+01:00) Oslo' },
    { Value: 'Europe/Paris', Text: '(UTC+01:00) Paris' },
    { Value: 'Europe/Rome', Text: '(UTC+01:00) Rome' },
    { Value: 'Europe/Stockholm', Text: '(UTC+01:00) Stockholm' },
    { Value: 'Europe/Tirane', Text: '(UTC+01:00) Tirane' },
    { Value: 'Africa/Tunis', Text: '(UTC+01:00) Tunis' },
    { Value: 'Europe/Vienna', Text: '(UTC+01:00) Vienna' },
    { Value: 'Europe/Warsaw', Text: '(UTC+01:00) Warsaw' },
    { Value: 'Europe/Zurich', Text: '(UTC+01:00) Zurich' },
    { Value: 'Asia/Amman', Text: '(UTC+02:00) Amman' },
    { Value: 'Europe/Athens', Text: '(UTC+02:00) Athens' },
    { Value: 'Asia/Beirut', Text: '(UTC+02:00) Beirut' },
    { Value: 'Europe/Bucharest', Text: '(UTC+02:00) Bucharest' },
    { Value: 'Africa/Cairo', Text: '(UTC+02:00) Cairo' },
    { Value: 'Europe/Chisinau', Text: '(UTC+02:00) Chisinau' },
    { Value: 'Asia/Damascus', Text: '(UTC+02:00) Damascus' },
    { Value: 'Asia/Gaza', Text: '(UTC+02:00) Gaza' },
    { Value: 'Europe/Helsinki', Text: '(UTC+02:00) Helsinki' },
    { Value: 'Asia/Jerusalem', Text: '(UTC+02:00) Jerusalem' },
    { Value: 'Africa/Johannesburg', Text: '(UTC+02:00) Johannesburg' },
    { Value: 'Africa/Khartoum', Text: '(UTC+02:00) Khartoum' },
    { Value: 'Europe/Kiev', Text: '(UTC+02:00) Kiev' },
    { Value: 'Africa/Maputo', Text: '(UTC+02:00) Maputo' },
    { Value: 'Europe/Kaliningrad', Text: '(UTC+02:00) Moscow-01 - Kaliningrad' },
    { Value: 'Asia/Nicosia', Text: '(UTC+02:00) Nicosia' },
    { Value: 'Europe/Riga', Text: '(UTC+02:00) Riga' },
    { Value: 'Europe/Sofia', Text: '(UTC+02:00) Sofia' },
    { Value: 'Europe/Tallinn', Text: '(UTC+02:00) Tallinn' },
    { Value: 'Africa/Tripoli', Text: '(UTC+02:00) Tripoli' },
    { Value: 'Europe/Vilnius', Text: '(UTC+02:00) Vilnius' },
    { Value: 'Africa/Windhoek', Text: '(UTC+02:00) Windhoek' },
    { Value: 'Asia/Baghdad', Text: '(UTC+03:00) Baghdad' },
    { Value: 'Europe/Istanbul', Text: '(UTC+03:00) Istanbul' },
    { Value: 'Europe/Minsk', Text: '(UTC+03:00) Minsk' },
    { Value: 'Europe/Moscow', Text: '(UTC+03:00) Moscow+00 - Moscow' },
    { Value: 'Africa/Nairobi', Text: '(UTC+03:00) Nairobi' },
    { Value: 'Asia/Qatar', Text: '(UTC+03:00) Qatar' },
    { Value: 'Asia/Riyadh', Text: '(UTC+03:00) Riyadh' },
    { Value: 'Antarctica/Syowa', Text: '(UTC+03:00) Syowa' },
    { Value: 'Asia/Tehran', Text: '(UTC+03:30) Tehran' },
    { Value: 'Asia/Baku', Text: '(UTC+04:00) Baku' },
    { Value: 'Asia/Dubai', Text: '(UTC+04:00) Dubai' },
    { Value: 'Indian/Mahe', Text: '(UTC+04:00) Mahe' },
    { Value: 'Indian/Mauritius', Text: '(UTC+04:00) Mauritius' },
    { Value: 'Europe/Samara', Text: '(UTC+04:00) Moscow+01 - Samara' },
    { Value: 'Indian/Reunion', Text: '(UTC+04:00) Reunion' },
    { Value: 'Asia/Tbilisi', Text: '(UTC+04:00) Tbilisi' },
    { Value: 'Asia/Yerevan', Text: '(UTC+04:00) Yerevan' },
    { Value: 'Asia/Kabul', Text: '(UTC+04:30) Kabul' },
    { Value: 'Asia/Aqtau', Text: '(UTC+05:00) Aqtau' },
    { Value: 'Asia/Aqtobe', Text: '(UTC+05:00) Aqtobe' },
    { Value: 'Asia/Ashgabat', Text: '(UTC+05:00) Ashgabat' },
    { Value: 'Asia/Dushanbe', Text: '(UTC+05:00) Dushanbe' },
    { Value: 'Asia/Karachi', Text: '(UTC+05:00) Karachi' },
    { Value: 'Indian/Kerguelen', Text: '(UTC+05:00) Kerguelen' },
    { Value: 'Indian/Maldives', Text: '(UTC+05:00) Maldives' },
    { Value: 'Antarctica/Mawson', Text: '(UTC+05:00) Mawson' },
    { Value: 'Asia/Yekaterinburg', Text: '(UTC+05:00) Moscow+02 - Yekaterinburg' },
    { Value: 'Asia/Tashkent', Text: '(UTC+05:00) Tashkent' },
    { Value: 'Asia/Colombo', Text: '(UTC+05:30) Colombo' },
    { Value: 'Asia/Kolkata', Text: '(UTC+05:30) India Standard Time' },
    { Value: 'Asia/Katmandu', Text: '(UTC+05:45) Katmandu' },
    { Value: 'Asia/Almaty', Text: '(UTC+06:00) Almaty' },
    { Value: 'Asia/Bishkek', Text: '(UTC+06:00) Bishkek' },
    { Value: 'Indian/Chagos', Text: '(UTC+06:00) Chagos' },
    { Value: 'Asia/Dhaka', Text: '(UTC+06:00) Dhaka' },
    { Value: 'Asia/Omsk', Text: '(UTC+06:00) Moscow+03 - Omsk' },
    { Value: 'Asia/Thimphu', Text: '(UTC+06:00) Thimphu' },
    { Value: 'Antarctica/Vostok', Text: '(UTC+06:00) Vostok' },
    { Value: 'Indian/Cocos', Text: '(UTC+06:30) Cocos' },
    { Value: 'Asia/Yangon', Text: '(UTC+06:30) Rangoon' },
    { Value: 'Asia/Bangkok', Text: '(UTC+07:00) Bangkok' },
    { Value: 'Indian/Christmas', Text: '(UTC+07:00) Christmas' },
    { Value: 'Antarctica/Davis', Text: '(UTC+07:00) Davis' },
    { Value: 'Asia/Saigon', Text: '(UTC+07:00) Hanoi' },
    { Value: 'Asia/Hovd', Text: '(UTC+07:00) Hovd' },
    { Value: 'Asia/Jakarta', Text: '(UTC+07:00) Jakarta' },
    { Value: 'Asia/Krasnoyarsk', Text: '(UTC+07:00) Moscow+04 - Krasnoyarsk' },
    { Value: 'Asia/Brunei', Text: '(UTC+08:00) Brunei' },
    { Value: 'Asia/Shanghai', Text: '(UTC+08:00) China Time - Beijing' },
    { Value: 'Asia/Choibalsan', Text: '(UTC+08:00) Choibalsan' },
    { Value: 'Asia/Hong_Kong', Text: '(UTC+08:00) Hong Kong' },
    { Value: 'Asia/Kuala_Lumpur', Text: '(UTC+08:00) Kuala Lumpur' },
    { Value: 'Asia/Macau', Text: '(UTC+08:00) Macau' },
    { Value: 'Asia/Makassar', Text: '(UTC+08:00) Makassar' },
    { Value: 'Asia/Manila', Text: '(UTC+08:00) Manila' },
    { Value: 'Asia/Irkutsk', Text: '(UTC+08:00) Moscow+05 - Irkutsk' },
    { Value: 'Asia/Singapore', Text: '(UTC+08:00) Singapore' },
    { Value: 'Asia/Taipei', Text: '(UTC+08:00) Taipei' },
    { Value: 'Asia/Ulaanbaatar', Text: '(UTC+08:00) Ulaanbaatar' },
    { Value: 'Australia/Perth', Text: '(UTC+08:00) Western Time - Perth' },
    { Value: 'Asia/Pyongyang', Text: '(UTC+08:30) Pyongyang' },
    { Value: 'Asia/Dili', Text: '(UTC+09:00) Dili' },
    { Value: 'Asia/Jayapura', Text: '(UTC+09:00) Jayapura' },
    { Value: 'Asia/Yakutsk', Text: '(UTC+09:00) Moscow+06 - Yakutsk' },
    { Value: 'Pacific/Palau', Text: '(UTC+09:00) Palau' },
    { Value: 'Asia/Seoul', Text: '(UTC+09:00) Seoul' },
    { Value: 'Asia/Tokyo', Text: '(UTC+09:00) Tokyo' },
    { Value: 'Australia/Darwin', Text: '(UTC+09:30) Central Time - Darwin' },
    { Value: 'Antarctica/DumontDUrville', Text: '(UTC+10:00) Dumont D"Urville' },
    { Value: 'Australia/Brisbane', Text: '(UTC+10:00) Eastern Time - Brisbane' },
    { Value: 'Pacific/Guam', Text: '(UTC+10:00) Guam' },
    { Value: 'Asia/Vladivostok', Text: '(UTC+10:00) Moscow+07 - Vladivostok' },
    { Value: 'Pacific/Port_Moresby', Text: '(UTC+10:00) Port Moresby' },
    { Value: 'Pacific / Chuuk', Text: '(UTC+10:00) Truk' },
    { Value: 'Australia/Adelaide', Text: '(UTC+10:30) Central Time - Adelaide' },
    { Value: 'Antarctica/Casey', Text: '(UTC+11:00) Casey' },
    { Value: 'Australia/Hobart', Text: '(UTC+11:00) Eastern Time - Hobart' },
    { Value: 'Australia/Sydney', Text: '(UTC+11:00) Eastern Time - Melbourne, Sydney' },
    { Value: 'Pacific/Efate', Text: '(UTC+11:00) Efate' },
    { Value: 'Pacific/Guadalcanal', Text: '(UTC+11:00) Guadalcanal' },
    { Value: 'Pacific/Kosrae', Text: '(UTC+11:00) Kosrae' },
    { Value: 'Asia/Magadan', Text: '(UTC+11:00) Moscow+08 - Magadan' },
    { Value: 'Pacific / Norfolk', Text: '(UTC+11:00) Norfolk' },
    { Value: 'Pacific/Noumea', Text: '(UTC+11:00) Noumea' },
    { Value: 'Pacific/Pohnpei', Text: '(UTC+11:00) Ponape' },
    { Value: 'Pacific/Funafuti', Text: '(UTC+12:00) Funafuti' },
    { Value: 'Pacific/Kwajalein', Text: '(UTC+12:00) Kwajalein' },
    { Value: 'Pacific/Majuro', Text: '(UTC+12:00) Majuro' },
    { Value: 'Asia/Kamchatka', Text: '(UTC+12:00) Moscow+09 - Petropavlovsk - Kamchatskiy' },
    { Value: 'Pacific / Nauru', Text: '(UTC+12:00) Nauru' },
    { Value: 'Pacific/Tarawa', Text: '(UTC+12:00) Tarawa' },
    { Value: 'Pacific/Wake', Text: '(UTC+12:00) Wake' },
    { Value: 'Pacific/Wallis', Text: '(UTC+12:00) Wallis' },
    { Value: 'Pacific/Auckland', Text: '(UTC+13:00) Auckland' },
    { Value: 'Pacific/Enderbury', Text: '(UTC+13:00) Enderbury' },
    { Value: 'Pacific/Fakaofo', Text: '(UTC+13:00) Fakaofo' },
    { Value: 'Pacific/Fiji', Text: '(UTC+13:00) Fiji' },
    { Value: 'Pacific/Tongatapu', Text: '(UTC+13:00) Tongatapu' },
    { Value: 'Pacific/Apia', Text: '(UTC+14:00) Apia' },
    { Value: 'Pacific/Kiritimati', Text: '(UTC+14:00) Kiritimati' }
];

/* eslint-disable max-len */
/**
 * Date Generator from Recurrence Rule
 */
/**
 * Generate Summary from Recurrence Rule
 *
 * @param {string} rule Accepts the Recurrence rule
 * @param {L10n} localeObject Accepts the locale object
 * @param {string} locale Accepts the locale name
 * @param {CalendarType} calendarType Accepts the calendar type
 * @returns {string} Returns the summary string from given recurrence rule
 */
function generateSummary(rule, localeObject, locale, calendarType = 'Gregorian') {
    const ruleObject = extractObjectFromRule(rule);
    let summary = localeObject.getConstant(EVERY) + ' ';
    let cldrObj;
    let cldrObj1;
    const calendarMode = calendarType.toLowerCase();
    if (locale === 'en' || locale === 'en-US') {
        const nameSpace1 = 'months.stand-alone.abbreviated';
        const nameSpace = 'days.stand-alone.abbreviated';
        cldrObj1 = (getValue(nameSpace1, getDefaultDateObject(calendarMode)));
        cldrObj = (getValue(nameSpace, getDefaultDateObject(calendarMode)));
    }
    else {
        const nameSpace1 = 'main.' + locale + '.dates.calendars.' + calendarMode + '.months.stand-alone.abbreviated';
        const nameSpace = 'main.' + locale + '.dates.calendars.' + calendarMode + '.days.stand-alone.abbreviated';
        cldrObj1 =
            (getValue(nameSpace1, cldrData));
        cldrObj =
            (getValue(nameSpace, cldrData));
    }
    if (ruleObject.interval > 1) {
        summary += ruleObject.interval + ' ';
    }
    switch (ruleObject.freq) {
        case 'DAILY':
            summary += localeObject.getConstant(DAYS);
            break;
        case 'WEEKLY':
            summary += localeObject.getConstant(WEEKS) + ' ' + localeObject.getConstant(ON) + ' ';
            ruleObject.day.forEach((day, index) => {
                summary += capitalizeFirstWord(getValue(DAYINDEXOBJECT[`${day}`], cldrObj), 'single');
                summary += (((ruleObject.day.length - 1) === index) ? '' : ', ');
            });
            break;
        case 'MONTHLY':
            summary += localeObject.getConstant(MONTHS) + ' ' + localeObject.getConstant(ON) + ' ';
            summary += getMonthSummary(ruleObject, cldrObj, localeObject);
            break;
        case 'YEARLY':
            summary += localeObject.getConstant(YEARS) + ' ' + localeObject.getConstant(ON) + ' ';
            summary += capitalizeFirstWord(getValue((ruleObject.month[0]).toString(), cldrObj1), 'single') + ' ';
            summary += getMonthSummary(ruleObject, cldrObj, localeObject);
            break;
    }
    if (ruleObject.count) {
        summary += ', ' + (ruleObject.count) + ' ' + localeObject.getConstant(TIMES);
    }
    else if (ruleObject.until) {
        const tempDate = ruleObject.until;
        summary += ', ' + localeObject.getConstant(UNTIL)
            + ' ' + tempDate.getDate()
            + ' ' + capitalizeFirstWord(getValue((tempDate.getMonth() + 1).toString(), cldrObj1), 'single')
            + ' ' + tempDate.getFullYear();
    }
    return summary;
}
/**
 * Generates Month summary
 *
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @param {string[]} cldrObj Accepts the collections of month name from calendar
 * @param {L10n} localeObj Accepts the locale object
 * @returns {string} Returns the month summary string from given recurrence rule object
 * @private
 */
function getMonthSummary(ruleObject, cldrObj, localeObj) {
    let summary = '';
    if (ruleObject.monthDay.length) {
        summary += ruleObject.monthDay[0];
    }
    else if (ruleObject.day) {
        const pos = ruleObject.setPosition - 1;
        summary += localeObj.getConstant(WEEKPOS[pos > -1 ? pos : (WEEKPOS.length - 1)])
            + ' ' + capitalizeFirstWord(getValue(DAYINDEXOBJECT[ruleObject.day[0]], cldrObj), 'single');
    }
    return summary;
}
/**
 * Generates the date collections from the given recurrence rule
 *
 * @param {Date} startDate Accepts the rule start date
 * @param {string} rule Accepts the recurrence rule
 * @param {string} excludeDate Accepts the exception dates in string format
 * @param {number} startDayOfWeek Accepts the start day index of week
 * @param {number} maximumCount Accepts the maximum number count to generate date collections
 * @param {Date} viewDate Accepts the current date instead of start date
 * @param {CalendarType} calendarMode Accepts the calendar type
 * @param {string} oldTimezone Accepts the timezone name
 * @param {string} newTimezone Accepts the timezone name
 * @returns {number[]} Returns the collection of dates
 */
function generate(startDate, rule, excludeDate, startDayOfWeek, maximumCount = MAXOCCURRENCE, viewDate = null, calendarMode = 'Gregorian', oldTimezone = null, newTimezone = null) {
    const ruleObject = extractObjectFromRule(rule);
    let cacheDate;
    calendarUtil = getCalendarUtil(calendarMode);
    const data = [];
    const modifiedDate = new Date(startDate.getTime());
    tempExcludeDate = [];
    const tempDate = isNullOrUndefined(excludeDate) ? [] : excludeDate.split(',');
    const tz = new Timezone();
    tempDate.forEach((content) => {
        let parsedDate = getDateFromRecurrenceDateString(content);
        if (oldTimezone && newTimezone) {
            parsedDate = tz.convert(new Date(parsedDate.getTime()), oldTimezone, newTimezone);
        }
        tempExcludeDate.push(new Date(parsedDate.getTime()).setHours(0, 0, 0, 0));
    });
    ruleObject.recExceptionCount = !isNullOrUndefined(ruleObject.count) ? tempExcludeDate.length : 0;
    if (viewDate && viewDate > startDate && !ruleObject.count) {
        tempViewDate = new Date(new Date(viewDate.getTime()).setHours(0, 0, 0));
    }
    else {
        tempViewDate = null;
    }
    if (!ruleObject.until && tempViewDate) {
        cacheDate = new Date(tempViewDate.getTime());
        cacheDate.setDate(tempViewDate.getDate() + maximumCount * (ruleObject.interval));
        ruleObject.until = cacheDate;
    }
    if (ruleObject.until && startDate > ruleObject.until) {
        return data;
    }
    maxOccurrence = maximumCount;
    setFirstDayOfWeek(DAYINDEX[parseInt(startDayOfWeek.toString(), 10)]);
    if (ruleObject.until) {
        const end = resetTime(ruleObject.until);
        ruleObject.until = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 23, 59, 59);
    }
    switch (ruleObject.freq) {
        case 'DAILY':
            dailyType(modifiedDate, ruleObject.until, data, ruleObject);
            break;
        case 'WEEKLY':
            weeklyType(modifiedDate, ruleObject.until, data, ruleObject);
            break;
        case 'MONTHLY':
            monthlyType(modifiedDate, ruleObject.until, data, ruleObject);
            break;
        case 'YEARLY':
            yearlyType(modifiedDate, ruleObject.until, data, ruleObject);
    }
    return data;
}
/**
 * Generate date object from given date string
 *
 * @param {string} recDateString Accepts the exception date as string
 * @returns {Date} Returns the date from exception date string
 */
function getDateFromRecurrenceDateString(recDateString) {
    return new Date(recDateString.substr(0, 4) +
        '-' + recDateString.substr(4, 2) +
        '-' + recDateString.substr(6, 5) +
        ':' + recDateString.substr(11, 2) +
        ':' + recDateString.substr(13));
}
/**
 * Internal method to handle exclude date
 *
 * @param {number[]} data Accepts the exception date collections
 * @param {number} date Accepts the new exclude date
 * @returns {void}
 * @private
 */
function excludeDateHandler(data, date) {
    const zeroIndex = new Date(date).setHours(0, 0, 0, 0);
    if (tempExcludeDate.indexOf(zeroIndex) === -1 && (!tempViewDate || zeroIndex >= tempViewDate.getTime())) {
        data.push(date);
    }
}
/**
 * Internal method for get date count
 *
 * @param {Date} startDate Accepts the date
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {number} Returns the number of date count
 * @private
 */
function getDateCount$1(startDate, ruleObject) {
    let count = maxOccurrence;
    if (ruleObject.count) {
        count = ruleObject.count;
    }
    else if (ruleObject.until) {
        if (ruleObject.freq === 'DAILY' || ruleObject.freq === 'WEEKLY') {
            count = Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1;
        }
        else if (ruleObject.freq === 'MONTHLY' || ruleObject.freq === 'YEARLY') {
            count = Math.floor(((ruleObject.until.getMonth() + 12 * ruleObject.until.getFullYear()) -
                (startDate.getMonth() + 12 * startDate.getFullYear())) / ruleObject.interval) +
                (ruleObject.day.length > 1 ? (Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1) : 1);
            if (ruleObject.freq === 'YEARLY') {
                count = ruleObject.month.length > 1 ? (count * ruleObject.month.length) : count;
            }
        }
    }
    return count;
}
/**
 *  Internal method for daily type recurrence rule
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function dailyType(startDate, endDate, data, ruleObject) {
    const tempDate = new Date(startDate.getTime());
    const interval = ruleObject.interval;
    const expectedCount = getDateCount$1(startDate, ruleObject);
    let state;
    const expectedDays = ruleObject.day;
    while (compareDates(tempDate, endDate)) {
        state = true;
        state = validateRules(tempDate, ruleObject);
        if (state && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1 || expectedDays.length === 0)) {
            excludeDateHandler(data, tempDate.getTime());
            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
                break;
            }
        }
        tempDate.setDate(tempDate.getDate() + interval);
        if (tempDate.getHours() !== startDate.getHours()) {
            tempDate.setHours(startDate.getHours());
        }
    }
}
/**
 * Internal method for weekly type recurrence rule
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function weeklyType(startDate, endDate, data, ruleObject) {
    let tempDate = new Date(startDate.getTime());
    if (!ruleObject.day.length) {
        ruleObject.day.push(DAYINDEX[startDate.getDay()]);
    }
    const interval = ruleObject.interval;
    const expectedDays = ruleObject.day;
    const expectedCount = getDateCount$1(startDate, ruleObject);
    let weekState = true;
    let wkstIndex;
    let weekCollection = [];
    if (expectedDays.length > 1) {
        if (isNullOrUndefined(ruleObject.wkst) || ruleObject.wkst === '') {
            ruleObject.wkst = dayIndex[0];
        }
        wkstIndex = DAYINDEX.indexOf(ruleObject.wkst);
        while (compareDates(tempDate, endDate)) {
            let startDateDiff = DAYINDEX.indexOf(DAYINDEX[tempDate.getDay()]) - wkstIndex;
            startDateDiff = startDateDiff === -1 ? 6 : startDateDiff;
            const weekstartDate = addDays(tempDate, -startDateDiff);
            let weekendDate = addDays(weekstartDate, 6);
            let compareTempDate = new Date(tempDate.getTime());
            weekendDate = resetTime(weekendDate);
            compareTempDate = resetTime(compareTempDate);
            while (weekendDate >= compareTempDate) {
                if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {
                    weekCollection.push([tempDate.getTime()]);
                }
                if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
                    break;
                }
                tempDate.setDate(tempDate.getDate() + 1);
                if (tempDate.getHours() !== startDate.getHours()) {
                    tempDate.setHours(startDate.getHours());
                }
                compareTempDate = new Date(tempDate.getTime());
                compareTempDate = resetTime(compareTempDate);
            }
            tempDate.setDate(tempDate.getDate() - 1);
            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
                break;
            }
            tempDate.setDate((tempDate.getDate()) + 1 + ((interval - 1) * 7));
            insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);
            weekCollection = [];
        }
    }
    else {
        tempDate = getStartDateForWeek(startDate, ruleObject.day);
        while (compareDates(tempDate, endDate)) {
            weekState = validateRules(tempDate, ruleObject);
            if (weekState && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1)) {
                excludeDateHandler(data, tempDate.getTime());
            }
            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
                break;
            }
            tempDate.setDate(tempDate.getDate() + (interval * 7));
        }
        insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);
        weekCollection = [];
    }
}
/**
 *  Internal method for monthly type recurrence rule
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function monthlyType(startDate, endDate, data, ruleObject) {
    // Set monthday value if BYDAY, BYMONTH and Month day property is not set based on start date
    if (!ruleObject.month.length && !ruleObject.day.length && !ruleObject.monthDay.length) {
        ruleObject.monthDay.push(startDate.getDate());
        if (ruleObject.freq === 'YEARLY') {
            ruleObject.month.push(startDate.getMonth() + 1);
        }
    }
    else if (ruleObject.month.length > 0 && !ruleObject.day.length && !ruleObject.monthDay.length) {
        ruleObject.monthDay.push(startDate.getDate());
    }
    const ruleType = validateMonthlyRuleType(ruleObject);
    switch (ruleType) {
        case 'day':
            switch (ruleObject.freq) {
                case 'MONTHLY':
                    monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);
                    break;
                case 'YEARLY':
                    monthlyDayTypeProcess(startDate, endDate, data, ruleObject);
                    break;
            }
            break;
        case 'both':
        case 'date':
            switch (ruleObject.freq) {
                case 'MONTHLY':
                    monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);
                    break;
                case 'YEARLY':
                    monthlyDateTypeProcess(startDate, endDate, data, ruleObject);
                    break;
            }
            break;
    }
}
/**
 * Internal method for yearly type recurrence rule
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function yearlyType(startDate, endDate, data, ruleObject) {
    const typeValue = checkYearlyType(ruleObject);
    switch (typeValue) {
        case 'MONTH':
            monthlyType(startDate, endDate, data, ruleObject);
            break;
        case 'WEEKNO':
            processWeekNo(startDate, endDate, data, ruleObject);
            break;
        case 'YEARDAY':
            processYearDay(startDate, endDate, data, ruleObject);
            break;
    }
}
/**
 * Internal method for process week no
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function processWeekNo(startDate, endDate, data, ruleObject) {
    let stDate = calendarUtil.getYearLastDate(startDate, 0);
    let tempDate;
    const expectedCount = getDateCount$1(startDate, ruleObject);
    let state;
    let startDay;
    let firstWeekSpan;
    const weekNos = ruleObject.weekNo;
    let weekNo;
    let maxDate;
    let minDate;
    let weekCollection = [];
    const expectedDays = ruleObject.day;
    while (compareDates(stDate, endDate)) {
        startDay = dayIndex.indexOf(DAYINDEX[stDate.getDay()]);
        firstWeekSpan = (6 - startDay) + 1;
        for (let index = 0; index < weekNos.length; index++) {
            weekNo = weekNos[parseInt(index.toString(), 10)];
            weekNo = (weekNo > 0) ? weekNo : 53 + weekNo + 1;
            maxDate = (weekNo === 1) ? firstWeekSpan : firstWeekSpan + ((weekNo - 1) * 7);
            minDate = (weekNo === 1) ? firstWeekSpan - 7 : firstWeekSpan + ((weekNo - 2) * 7);
            while (minDate < maxDate) {
                tempDate = new Date(stDate.getTime() + (MS_PER_DAY * minDate));
                if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {
                    if (isNullOrUndefined(ruleObject.setPosition)) {
                        insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());
                    }
                    else {
                        weekCollection.push([tempDate.getTime()]);
                    }
                }
                minDate++;
            }
        }
        if (!isNullOrUndefined(ruleObject.setPosition)) {
            insertDatasIntoExistingCollection(weekCollection, state, startDate, endDate, data, ruleObject);
        }
        if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
            return;
        }
        stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);
        weekCollection = [];
    }
}
/**
 * Internal method for process year day
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function processYearDay(startDate, endDate, data, ruleObject) {
    let stDate = calendarUtil.getYearLastDate(startDate, 0);
    let tempDate;
    const expectedCount = getDateCount$1(startDate, ruleObject);
    let state;
    let dateCollection = [];
    let date;
    const expectedDays = ruleObject.day;
    while (compareDates(stDate, endDate)) {
        for (let index = 0; index < ruleObject.yearDay.length; index++) {
            date = ruleObject.yearDay[parseInt(index.toString(), 10)];
            tempDate = new Date(stDate.getTime());
            if ((date === calendarUtil.getLeapYearDaysCount() || date === -calendarUtil.getLeapYearDaysCount()) &&
                (!calendarUtil.isLeapYear(calendarUtil.getFullYear(tempDate), 1))) {
                tempDate.setDate(tempDate.getDate() + 1);
                continue;
            }
            tempDate.setDate(tempDate.getDate() + ((date < 0) ?
                calendarUtil.getYearDaysCount(tempDate, 1) + 1 + date : date));
            if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {
                if (ruleObject.setPosition == null) {
                    insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());
                }
                else {
                    dateCollection.push([tempDate.getTime()]);
                }
            }
        }
        if (!isNullOrUndefined(ruleObject.setPosition)) {
            insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject);
        }
        if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
            return;
        }
        stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);
        dateCollection = [];
    }
}
/**
 * Internal method to check yearly type
 *
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {YearRuleType} Returns the Yearly rule type object
 * @private
 */
function checkYearlyType(ruleObject) {
    if (ruleObject.yearDay.length) {
        return 'YEARDAY';
    }
    else if (ruleObject.weekNo.length) {
        return 'WEEKNO';
    }
    return 'MONTH';
}
/**
 * Internal method to initialize recurrence rule variables
 *
 * @param {Date} startDate Accepts the start date
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {RuleData} Return the rule data object
 * @private
 */
function initializeRecRuleVariables(startDate, ruleObject) {
    const ruleData = {
        monthCollection: [],
        index: 0,
        tempDate: new Date(startDate.getTime()),
        mainDate: new Date(startDate.getTime()),
        expectedCount: getDateCount$1(startDate, ruleObject),
        monthInit: 0,
        dateCollection: []
    };
    if (ruleObject.month.length) {
        calendarUtil.setMonth(ruleData.tempDate, ruleObject.month[0], ruleData.tempDate.getDate());
    }
    return ruleData;
}
/**
 * Internal method for process monthly date type recurrence rule
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function monthlyDateTypeProcess(startDate, endDate, data, ruleObject) {
    if (ruleObject.month.length) {
        monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);
        return;
    }
    const ruleData = initializeRecRuleVariables(startDate, ruleObject);
    let currentMonthDate;
    ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);
    while (compareDates(ruleData.tempDate, endDate)) {
        currentMonthDate = new Date(ruleData.tempDate.getTime());
        while (calendarUtil.isSameYear(currentMonthDate, ruleData.tempDate) &&
            (ruleData.expectedCount && (data.length + ruleObject.recExceptionCount) <= ruleData.expectedCount)) {
            if (ruleObject.month.length === 0 || (ruleObject.month.length > 0
                && !calendarUtil.checkMonth(ruleData.tempDate, ruleObject.month))) {
                processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, false);
                ruleData.beginDate = new Date(ruleData.tempDate.getTime());
                ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);
            }
            else {
                calendarUtil.setValidDate(ruleData.tempDate, 1, 1);
                ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);
                break;
            }
        }
        ruleData.tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());
        insertDataCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);
        if (calendarUtil.isLastMonth(ruleData.tempDate)) {
            calendarUtil.setValidDate(ruleData.tempDate, 1, 1);
            ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);
        }
        if (ruleData.expectedCount && (data.length + ruleObject.recExceptionCount) >= ruleData.expectedCount) {
            return;
        }
        ruleData.tempDate.setFullYear(ruleData.tempDate.getFullYear() + ruleObject.interval - 1);
        ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);
        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);
        ruleData.dateCollection = [];
    }
}
/**
 * Internal method for process monthly date type with month frequency from recurrence rule
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {
    const ruleData = initializeRecRuleVariables(startDate, ruleObject);
    ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);
    if (((ruleObject.freq === 'MONTHLY' && ruleObject.interval === 12) || (ruleObject.freq === 'YEARLY')) &&
        calendarUtil.getMonthDaysCount(startDate) < ruleObject.monthDay[0]) {
        return;
    }
    while (compareDates(ruleData.tempDate, endDate)) {
        ruleData.beginDate = new Date(ruleData.tempDate.getTime());
        processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, true, startDate, data);
        if (!isNullOrUndefined(ruleObject.setPosition)) {
            insertDatasIntoExistingCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);
        }
        if (ruleData.expectedCount && (data.length + ruleObject.recExceptionCount) >= ruleData.expectedCount) {
            return;
        }
        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);
        ruleData.dateCollection = [];
    }
}
/**
 * To process date collection for Monthly & Yearly based on BYMONTH Day property
 *
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @param {RuleData} recRuleVariables Accepts the rule data
 * @param {Date} endDate Accepts the end date
 * @param {boolean} isByMonth Accepts the boolean to validate either month or not
 * @param {Date} startDate Accepts the start date
 * @param {number[]} data Accepts the collection of dates
 * @returns {void}
 * @private
 */
function processDateCollectionForByMonthDay(ruleObject, recRuleVariables, endDate, isByMonth, startDate, data) {
    for (let index = 0; index < ruleObject.monthDay.length; index++) {
        recRuleVariables.date = ruleObject.monthDay[parseInt(index.toString(), 10)];
        recRuleVariables.tempDate = calendarUtil.getMonthStartDate(recRuleVariables.tempDate);
        const maxDate = calendarUtil.getMonthDaysCount(recRuleVariables.tempDate);
        recRuleVariables.date = recRuleVariables.date > 0 ? recRuleVariables.date : (maxDate + recRuleVariables.date + 1);
        if (validateProperDate(recRuleVariables.tempDate, recRuleVariables.date, recRuleVariables.mainDate)
            && (recRuleVariables.date > 0)) {
            calendarUtil.setDate(recRuleVariables.tempDate, recRuleVariables.date);
            if (endDate && recRuleVariables.tempDate > endDate) {
                return;
            }
            if (ruleObject.day.length === 0 || ruleObject.day.indexOf(DAYINDEX[recRuleVariables.tempDate.getDay()]) > -1) {
                if (isByMonth && isNullOrUndefined(ruleObject.setPosition) && (recRuleVariables.expectedCount
                    && (data.length + ruleObject.recExceptionCount) < recRuleVariables.expectedCount)) {
                    insertDateCollection(recRuleVariables.state, startDate, endDate, data, ruleObject, recRuleVariables.tempDate.getTime());
                }
                else {
                    recRuleVariables.dateCollection.push([recRuleVariables.tempDate.getTime()]);
                }
            }
        }
    }
}
/**
 * Internal method to set next valid date
 *
 * @param {Date} tempDate Accepts the date
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @param {number} monthInit Accepts the initial month
 * @param {Date} beginDate Accepts the initial date
 * @param {number} interval Accepts the interval duration
 * @returns {number} Returnx the next valid date
 * @private
 */
function setNextValidDate(tempDate, ruleObject, monthInit, beginDate = null, interval) {
    let monthData = beginDate ? beginDate.getMonth() : 0;
    const startDate = calendarUtil.getMonthStartDate(tempDate);
    interval = isNullOrUndefined(interval) ? ruleObject.interval : interval;
    tempDate.setFullYear(startDate.getFullYear());
    tempDate.setMonth(startDate.getMonth());
    tempDate.setDate(startDate.getDate());
    if (ruleObject.month.length) {
        monthInit++;
        monthInit = monthInit % ruleObject.month.length;
        calendarUtil.setMonth(tempDate, ruleObject.month[parseInt(monthInit.toString(), 10)], 1);
        if (monthInit === 0) {
            calendarUtil.addYears(tempDate, interval, ruleObject.month[0]);
        }
    }
    else {
        if (beginDate && (beginDate.getFullYear() < tempDate.getFullYear())) {
            monthData = tempDate.getMonth() - 1;
        }
        calendarUtil.setValidDate(tempDate, interval, 1, monthData, beginDate);
    }
    return monthInit;
}
/**
 * To get month collection when BYDAY property having more than one value in list.
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function getMonthCollection(startDate, endDate, data, ruleObject) {
    const expectedDays = ruleObject.day;
    let tempDate = new Date(startDate.getTime());
    tempDate = calendarUtil.getMonthStartDate(tempDate);
    let monthCollection = [];
    let dateCollection = [];
    let dates = [];
    let index;
    let state;
    const expectedCount = getDateCount$1(startDate, ruleObject);
    let monthInit = 0;
    let beginDate;
    if (ruleObject.month.length) {
        calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);
    }
    tempDate = getStartDateForWeek(tempDate, ruleObject.day);
    while (compareDates(tempDate, endDate)
        && (expectedCount && (data.length + ruleObject.recExceptionCount) < expectedCount)) {
        const currentMonthDate = new Date(tempDate.getTime());
        const isHavingNumber = expectedDays.map((item) => HASNUMBER.test(item));
        if (isHavingNumber.indexOf(true) > -1) {
            for (let j = 0; j <= expectedDays.length - 1; j++) {
                const expectedDaysArray = expectedDays[parseInt(j.toString(), 10)].match(SPLITNUMBERANDSTRING);
                const position = parseInt(expectedDaysArray[0], 10);
                tempDate = new Date(tempDate.getTime());
                tempDate = calendarUtil.getMonthStartDate(tempDate);
                tempDate = getStartDateForWeek(tempDate, expectedDays);
                currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());
                while (calendarUtil.isSameYear(currentMonthDate, tempDate) && calendarUtil.isSameMonth(currentMonthDate, tempDate)) {
                    if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentMonthDate.getDay()]) {
                        monthCollection.push([currentMonthDate.getTime()]);
                    }
                    currentMonthDate.setDate(currentMonthDate.getDate() + (1));
                }
                currentMonthDate.setDate(currentMonthDate.getDate() - (1));
                if (expectedDaysArray[0].indexOf('-') > -1) {
                    index = monthCollection.length - (-1 * position);
                }
                else {
                    index = position - 1;
                }
                index = isNaN(index) ? 0 : index;
                if (monthCollection.length > 0) {
                    if (isNullOrUndefined(ruleObject.setPosition)) {
                        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);
                    }
                    else {
                        dateCollection = [(filterDateCollectionByIndex(monthCollection, index, dates))];
                    }
                }
                if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
                    return;
                }
                monthCollection = [];
            }
            if (!isNullOrUndefined(ruleObject.setPosition)) {
                insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);
                dates = [];
            }
            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);
            tempDate = getStartDateForWeek(tempDate, ruleObject.day);
            monthCollection = [];
        }
        else {
            let weekCollection = [];
            const dayCycleData = processWeekDays(expectedDays);
            currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());
            const initialDate = new Date(tempDate.getTime());
            beginDate = new Date(tempDate.getTime());
            while (calendarUtil.isSameMonth(initialDate, tempDate)) {
                weekCollection.push(tempDate.getTime());
                if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {
                    monthCollection.push(weekCollection);
                    weekCollection = [];
                }
                tempDate.setDate(tempDate.getDate()
                    + dayCycleData[DAYINDEX[tempDate.getDay()]]);
            }
            index = ((ruleObject.setPosition < 1) ? (monthCollection.length + ruleObject.setPosition) : ruleObject.setPosition - 1);
            if (isNullOrUndefined(ruleObject.setPosition)) {
                index = 0;
                const datas = [];
                for (let week = 0; week < monthCollection.length; week++) {
                    for (let row = 0; row < monthCollection[parseInt(week.toString(), 10)].length; row++) {
                        datas.push(monthCollection[parseInt(week.toString(), 10)][parseInt(row.toString(), 10)]);
                    }
                }
                monthCollection = [datas];
            }
            if (monthCollection.length > 0) {
                insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);
            }
            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
                return;
            }
            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);
            tempDate = getStartDateForWeek(tempDate, ruleObject.day);
            monthCollection = [];
        }
    }
}
/**
 * To process monday day type for FREQ=MONTHLY
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {
    const expectedDays = ruleObject.day;
    // When BYDAY property having more than 1 value.
    if (expectedDays.length > 1) {
        getMonthCollection(startDate, endDate, data, ruleObject);
        return;
    }
    let tempDate = new Date(startDate.getTime());
    const expectedCount = getDateCount$1(startDate, ruleObject);
    let monthCollection = [];
    let beginDate;
    let monthInit = 0;
    tempDate = calendarUtil.getMonthStartDate(tempDate);
    if (ruleObject.month.length) {
        calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);
    }
    tempDate = getStartDateForWeek(tempDate, ruleObject.day);
    while (compareDates(tempDate, endDate) && (expectedCount && (data.length + ruleObject.recExceptionCount) < expectedCount)) {
        beginDate = new Date(tempDate.getTime());
        const currentMonthDate = new Date(tempDate.getTime());
        while (calendarUtil.isSameMonth(tempDate, currentMonthDate)) {
            monthCollection.push([currentMonthDate.getTime()]);
            currentMonthDate.setDate(currentMonthDate.getDate() + (7));
        }
        // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection
        insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);
        monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);
        tempDate = getStartDateForWeek(tempDate, ruleObject.day);
        monthCollection = [];
    }
}
/**
 * To process monday day type for FREQ=YEARLY
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function monthlyDayTypeProcess(startDate, endDate, data, ruleObject) {
    const expectedDays = ruleObject.day;
    const isHavingNumber = expectedDays.map((item) => HASNUMBER.test(item));
    // If BYDAY property having more than 1 value in list
    if (expectedDays.length > 1 && isHavingNumber.indexOf(true) > -1) {
        processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject);
        return;
    }
    else if (ruleObject.month.length && expectedDays.length === 1 && isHavingNumber.indexOf(true) > -1) {
        monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);
        return;
    }
    let tempDate = new Date(startDate.getTime());
    let currentMonthDate;
    const expectedCount = getDateCount$1(startDate, ruleObject);
    const interval = ruleObject.interval;
    let monthCollection = [];
    if (ruleObject.month.length) {
        calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());
    }
    // Set the date as start date of the yeear if yearly freq having ByDay property alone
    if (isNullOrUndefined(ruleObject.setPosition) && ruleObject.month.length === 0 && ruleObject.weekNo.length === 0) {
        tempDate.setFullYear(startDate.getFullYear(), 0, 1);
    }
    tempDate = calendarUtil.getMonthStartDate(tempDate);
    tempDate = getStartDateForWeek(tempDate, ruleObject.day);
    while (compareDates(tempDate, endDate)) {
        currentMonthDate = new Date(tempDate.getTime());
        while (calendarUtil.isSameYear(currentMonthDate, tempDate) &&
            (expectedCount && (data.length + ruleObject.recExceptionCount) <= expectedCount)) {
            currentMonthDate = new Date(tempDate.getTime());
            while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {
                if (ruleObject.month.length === 0 || (ruleObject.month.length > 0
                    && !calendarUtil.checkMonth(tempDate, ruleObject.month))) {
                    if (expectedDays.length > 1) {
                        if (calendarUtil.compareMonth(currentMonthDate, tempDate)) {
                            calendarUtil.setValidDate(tempDate, 1, 1);
                            tempDate = getStartDateForWeek(tempDate, ruleObject.day);
                            break;
                        }
                        if (expectedDays.indexOf(DAYINDEX[currentMonthDate.getDay()]) > -1) {
                            monthCollection.push([currentMonthDate.getTime()]);
                        }
                        currentMonthDate.setDate(currentMonthDate.getDate() + (1));
                    }
                    else {
                        // If BYDAY property having 1 value in list
                        if (currentMonthDate.getFullYear() > tempDate.getFullYear()) {
                            calendarUtil.setValidDate(tempDate, 1, 1);
                            tempDate = getStartDateForWeek(tempDate, ruleObject.day);
                            break;
                        }
                        const newstr = getDayString(expectedDays[0]);
                        if (DAYINDEX[currentMonthDate.getDay()] === newstr
                            && new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), 0)
                                > new Date(startDate.getFullYear())) {
                            monthCollection.push([currentMonthDate.getTime()]);
                        }
                        currentMonthDate.setDate(currentMonthDate.getDate() + (7));
                    }
                }
                else {
                    calendarUtil.setValidDate(tempDate, 1, 1);
                    tempDate = getStartDateForWeek(tempDate, ruleObject.day);
                    break;
                }
            }
        }
        tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());
        // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection
        insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);
        if (calendarUtil.isLastMonth(tempDate)) {
            calendarUtil.setValidDate(tempDate, 1, 1);
            tempDate = getStartDateForWeek(tempDate, ruleObject.day);
        }
        tempDate.setFullYear(tempDate.getFullYear() + interval - 1);
        if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
            return;
        }
        tempDate = getStartDateForWeek(tempDate, ruleObject.day);
        monthCollection = [];
    }
}
/**
 * To process the recurrence rule when BYDAY property having values with integer
 *
 * @param {Date} startDate Accepts the strat date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of dates
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject) {
    const expectedDays = ruleObject.day;
    const expectedCount = getDateCount$1(startDate, ruleObject);
    let tempDate = new Date(startDate.getTime());
    const interval = ruleObject.interval;
    let monthCollection = [];
    let dateCollection = [];
    let index;
    let state;
    let monthInit = 0;
    let currentMonthDate;
    let currentDate;
    let beginDate;
    tempDate = calendarUtil.getMonthStartDate(tempDate);
    let datas = [];
    if (ruleObject.month.length) {
        calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);
    }
    tempDate = getStartDateForWeek(tempDate, ruleObject.day);
    while (compareDates(tempDate, endDate)) {
        currentMonthDate = new Date(tempDate.getTime());
        for (let i = 0; i <= ruleObject.month.length; i++) {
            for (let j = 0; j <= expectedDays.length - 1; j++) {
                tempDate = calendarUtil.getMonthStartDate(tempDate);
                tempDate = getStartDateForWeek(tempDate, ruleObject.day);
                monthCollection = [];
                while (calendarUtil.isSameYear(currentMonthDate, tempDate) &&
                    (expectedCount && (data.length + ruleObject.recExceptionCount) <= expectedCount)) {
                    while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {
                        currentMonthDate = new Date(tempDate.getTime());
                        if (ruleObject.month.length === 0 ||
                            (ruleObject.month.length > 0 && ruleObject.month[parseInt(i.toString(), 10)] === calendarUtil.getMonth(currentMonthDate))) {
                            const expectedDaysArray = expectedDays[parseInt(j.toString(), 10)].match(SPLITNUMBERANDSTRING);
                            const position = parseInt(expectedDaysArray[0], 10);
                            currentDate = new Date(tempDate.getTime());
                            while (calendarUtil.isSameYear(currentDate, tempDate)
                                && calendarUtil.isSameMonth(currentDate, tempDate)) {
                                if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentDate.getDay()]) {
                                    monthCollection.push([currentDate.getTime()]);
                                }
                                currentDate.setDate(currentDate.getDate() + (1));
                            }
                            currentDate.setDate(currentDate.getDate() - (1));
                            if (expectedDaysArray[0].indexOf('-') > -1) {
                                index = monthCollection.length - (-1 * position);
                            }
                            else {
                                index = position - 1;
                            }
                            index = isNaN(index) ? 0 : index;
                        }
                        monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate, 1);
                        tempDate = getStartDateForWeek(tempDate, ruleObject.day);
                    }
                }
                tempDate = j === 0 && currentDate ? new Date(currentDate.getTime()) : new Date(currentMonthDate.getTime());
                if (monthCollection.length > 0) {
                    if (isNullOrUndefined(ruleObject.setPosition)) {
                        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);
                    }
                    else {
                        dateCollection = [(filterDateCollectionByIndex(monthCollection, index, datas))];
                    }
                }
                if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {
                    return;
                }
            }
        }
        if (!isNullOrUndefined(ruleObject.setPosition)) {
            insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);
            datas = [];
        }
        if (calendarUtil.isLastMonth(tempDate)) {
            calendarUtil.setValidDate(tempDate, 1, 1);
            tempDate.setFullYear(tempDate.getFullYear() + interval - 1);
        }
        else {
            tempDate.setFullYear(tempDate.getFullYear() + interval);
        }
        tempDate = getStartDateForWeek(tempDate, ruleObject.day);
        if (ruleObject.month.length) {
            calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());
        }
    }
}
/**
 * To get recurrence collection if BYSETPOS is null
 *
 * @param {number[]} monthCollection Accepts the month collection dates
 * @param {string[]} expectedDays Accepts the exception dates
 * @returns {RuleData} Returns the rule data object
 * @private
 */
function getRecurrenceCollection(monthCollection, expectedDays) {
    let index;
    const recurrenceCollectionObject = { monthCollection: [], index: 0 };
    if (expectedDays.length === 1) {
        // To split numeric value from BYDAY property value
        const expectedDaysArrays = expectedDays[0].match(SPLITNUMBERANDSTRING);
        let arrPosition;
        if (expectedDaysArrays.length > 1) {
            arrPosition = parseInt(expectedDaysArrays[0], 10);
            index = ((arrPosition < 1) ? (monthCollection.length + arrPosition) : arrPosition - 1);
        }
        else {
            index = 0;
            monthCollection = getDateCollectionforBySetPosNull(monthCollection);
        }
    }
    else {
        index = 0;
        monthCollection = getDateCollectionforBySetPosNull(monthCollection);
    }
    recurrenceCollectionObject.monthCollection = monthCollection;
    recurrenceCollectionObject.index = index;
    return recurrenceCollectionObject;
}
/**
 * Internal method to process the data collections
 *
 * @param {number[]} dateCollection Accepts the date collections
 * @param {boolean} state Accepts the state
 * @param {Date} startDate Accepts the start date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of numbers
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function insertDataCollection(dateCollection, state, startDate, endDate, data, ruleObject) {
    let index = ((ruleObject.setPosition < 1) ?
        (dateCollection.length + ruleObject.setPosition) : ruleObject.setPosition - 1);
    if (isNullOrUndefined(ruleObject.setPosition)) {
        index = 0;
        dateCollection = getDateCollectionforBySetPosNull(dateCollection);
    }
    if (dateCollection.length > 0) {
        insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject, index);
    }
}
/**
 * To process month collection if BYSETPOS is null
 *
 * @param {number[]} monthCollection Accepts the month date collections
 * @returns {number[]} Returns the month date collections
 * @private
 */
function getDateCollectionforBySetPosNull(monthCollection) {
    const datas = [];
    for (let week = 0; week < monthCollection.length; week++) {
        for (let row = 0; row < monthCollection[parseInt(week.toString(), 10)].length; row++) {
            datas.push(new Date(monthCollection[parseInt(week.toString(), 10)][parseInt(row.toString(), 10)]).getTime());
        }
    }
    monthCollection = datas.length > 0 ? [datas] : [];
    return monthCollection;
}
/**
 * To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection
 *
 * @param {number[]} monthCollection Accepts the month date collections
 * @param {Date} startDate Accepts the start date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the date collections
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject) {
    const expectedDays = ruleObject.day;
    let state;
    let datas = [];
    let dateCollection = [];
    const recurrenceCollections = getRecurrenceCollection(monthCollection, expectedDays);
    monthCollection = recurrenceCollections.monthCollection;
    const index = recurrenceCollections.index;
    if (ruleObject.setPosition != null) {
        dateCollection = [(filterDateCollectionByIndex(monthCollection, index, datas))];
        insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);
    }
    else {
        if (monthCollection.length > 0) {
            insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);
        }
    }
    datas = [];
}
/**
 * To filter date collection when BYDAY property having values with number
 *
 * @param {number[]} monthCollection Accepts the date collections
 * @param {number} index Accepts the index of date collections
 * @param {number[]} datas Accepts the collection of dates
 * @returns {number[]} Returns the collection of dates
 * @private
 */
function filterDateCollectionByIndex(monthCollection, index, datas) {
    for (let week = 0; week < monthCollection[parseInt(index.toString(), 10)].length; week++) {
        datas.push(monthCollection[parseInt(index.toString(), 10)][parseInt(week.toString(), 10)]);
    }
    return datas;
}
/**
 * To insert processed date collection in final array element
 *
 * @param {boolean} state Accepts the state of the recurrence rule
 * @param {Date} startDate Accepts the start date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of date
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @param {number} dayData Accepts the date index
 * @returns {void}
 * @private
 */
function insertDateCollection(state, startDate, endDate, data, ruleObject, dayData) {
    const expectedCount = getDateCount$1(startDate, ruleObject);
    const chDate = new Date(dayData);
    state = validateRules(chDate, ruleObject);
    if ((chDate >= startDate) && compareDates(chDate, endDate) && state
        && expectedCount && (data.length + ruleObject.recExceptionCount) < expectedCount) {
        excludeDateHandler(data, dayData);
    }
}
/**
 * Return the last week number of given month and year.
 *
 * @param {number} year Accepts the Year in number format
 * @param {number} startDayOfWeek Accepts the start date
 * @param {number[]} monthCollection Accepts the collection of dates
 * @param {number} week Accepts the week in number format
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {number} returns week number
 * @private
 */
function weekCount(year, startDayOfWeek, monthCollection, week, ruleObject) {
    const firstDayOfWeek = startDayOfWeek || 0;
    const firstOfMonth = new Date(year, ruleObject.month[0] - 1, 1);
    const lastOfMonth = new Date(year, ruleObject.month[0], 0);
    const numberOfDaysInMonth = lastOfMonth.getDate();
    const firstWeekDay = (firstOfMonth.getDay() - firstDayOfWeek + 7) % 7;
    const used = firstWeekDay + numberOfDaysInMonth;
    const count = Math.ceil(used / 7) - 1;
    const dayData = monthCollection[parseInt(week.toString(), 10)][parseInt(count.toString(), 10)];
    const chDate = new Date(dayData);
    const state = validateRules(chDate, ruleObject);
    return (state) ? count : count - 1;
}
/**
 * To process date collection based on Byset position after process the collection based on BYDAY property value index: EX:BYDAY=1SUm-1SU
 *
 * @param {number[]} monthCollection Accepts the collection of dates
 * @param {boolean} state Accepts the state of the recurrence rule
 * @param {Date} startDate Accepts the start date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of date
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {void}
 * @private
 */
function insertDateCollectionBasedonBySetPos(monthCollection, state, startDate, endDate, data, ruleObject) {
    if (monthCollection.length > 0) {
        for (let week = 0; week < monthCollection.length; week++) {
            monthCollection[parseInt(week.toString(), 10)].sort();
            const expectedDays = ruleObject.day;
            const isHavingNumber = expectedDays.map((item) => HASNUMBER.test(item));
            const weekIndex = (ruleObject.freq === 'YEARLY' && (ruleObject.validRules.indexOf('BYMONTH') > -1) &&
                !(isHavingNumber.indexOf(true) > -1)) ?
                weekCount(new Date(monthCollection[0][0]).getFullYear(), 0, monthCollection, week, ruleObject)
                : (monthCollection[parseInt(week.toString(), 10)].length + ruleObject.setPosition);
            const index = ((ruleObject.setPosition < 1) ? weekIndex : ruleObject.setPosition - 1);
            const dayData = monthCollection[parseInt(week.toString(), 10)][parseInt(index.toString(), 10)];
            insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);
        }
    }
}
/**
 * To insert datas into existing collection which is processed from previous loop.
 *
 * @param {number[]} monthCollection Accepts the collection of dates
 * @param {boolean} state Accepts the state of the recurrence rule
 * @param {Date} startDate Accepts the start date
 * @param {Date} endDate Accepts the end date
 * @param {number[]} data Accepts the collection of date
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @param {number} index Accepts the index value
 * @returns {void}
 * @private
 */
function insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index) {
    if (monthCollection.length > 0) {
        index = !isNullOrUndefined(index) ? index :
            ((ruleObject.setPosition < 1)
                ? (monthCollection.length + ruleObject.setPosition) : ruleObject.setPosition - 1);
        monthCollection[parseInt(index.toString(), 10)].sort();
        for (let week = 0; week < monthCollection[parseInt(index.toString(), 10)].length; week++) {
            const dayData = monthCollection[parseInt(index.toString(), 10)][parseInt(week.toString(), 10)];
            insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);
        }
    }
}
/**
 * Internal method to compare dates
 *
 * @param {Date} startDate Accepts the start date
 * @param {Date} endDate Accepts the end date
 * @returns {boolean} Returns the result of checking start and end dates
 * @private
 */
function compareDates(startDate, endDate) {
    return endDate ? (startDate <= endDate) : true;
}
/**
 * Internal method to get day string
 *
 * @param {string} expectedDays Accepts the exception date string
 * @returns {string} Returns the valid string
 * @private
 */
function getDayString(expectedDays) {
    // To get BYDAY value without numeric value
    const newstr = expectedDays.replace(REMOVENUMBERINSTRING, '');
    return newstr;
}
/**
 * Internal method to check day index
 *
 * @param {number} day Accepts the day index
 * @param {string[]} expectedDays Accepts the exception dates
 * @returns {boolean} Returns the index date
 * @private
 */
function checkDayIndex(day, expectedDays) {
    const sortedExpectedDays = [];
    expectedDays.forEach((element) => {
        const expectedDaysNumberSplit = element.match(SPLITNUMBERANDSTRING);
        if (expectedDaysNumberSplit.length === 2) {
            sortedExpectedDays.push(expectedDaysNumberSplit[1]);
        }
        else {
            sortedExpectedDays.push(expectedDaysNumberSplit[0]);
        }
    });
    return (sortedExpectedDays.indexOf(DAYINDEX[parseInt(day.toString(), 10)]) === -1);
}
/**
 * Internal method to get start date of week
 *
 * @param {Date} startDate Accepts the start date
 * @param {string[]} expectedDays Accepts the exception dates
 * @returns {Date} Return the week start date
 * @private
 */
function getStartDateForWeek(startDate, expectedDays) {
    const tempDate = new Date(startDate.getTime());
    let newstr;
    if (expectedDays.length > 0) {
        const expectedDaysArr = [];
        for (let i = 0; i <= expectedDays.length - 1; i++) {
            newstr = getDayString(expectedDays[parseInt(i.toString(), 10)]);
            expectedDaysArr.push(newstr);
        }
        if (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1) {
            do {
                tempDate.setDate(tempDate.getDate() + 1);
            } while (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1);
        }
    }
    return tempDate;
}
/**
 * Method to generate recurrence rule object from given rule
 *
 * @param {string} rules Accepts the recurrence rule
 * @returns {RecRule} Returns the recurrence rule object
 */
function extractObjectFromRule(rules) {
    const ruleObject = {
        freq: null,
        interval: 1,
        count: null,
        until: null,
        day: [],
        wkst: null,
        month: [],
        weekNo: [],
        monthDay: [],
        yearDay: [],
        setPosition: null,
        validRules: []
    };
    const rulesList = rules.split(';');
    let splitData = [];
    let temp;
    rulesList.forEach((data) => {
        splitData = data.split('=');
        switch (splitData[0]) {
            case 'UNTIL':
                temp = splitData[1];
                ruleObject.until = getDateFromRecurrenceDateString(temp);
                break;
            case 'BYDAY':
                ruleObject.day = splitData[1].split(',');
                ruleObject.validRules.push(splitData[0]);
                break;
            case 'BYMONTHDAY':
                ruleObject.monthDay = splitData[1].split(',').map(Number);
                ruleObject.validRules.push(splitData[0]);
                break;
            case 'BYMONTH':
                ruleObject.month = splitData[1].split(',').map(Number);
                ruleObject.validRules.push(splitData[0]);
                break;
            case 'BYYEARDAY':
                ruleObject.yearDay = splitData[1].split(',').map(Number);
                ruleObject.validRules.push(splitData[0]);
                break;
            case 'BYWEEKNO':
                ruleObject.weekNo = splitData[1].split(',').map(Number);
                ruleObject.validRules.push(splitData[0]);
                break;
            case 'INTERVAL':
                ruleObject.interval = parseInt(splitData[1], 10);
                break;
            case 'COUNT':
                ruleObject.count = parseInt(splitData[1], 10);
                break;
            case 'BYSETPOS':
                ruleObject.setPosition = parseInt(splitData[1], 10) > 4 ? -1 : parseInt(splitData[1], 10);
                break;
            case 'FREQ':
                ruleObject.freq = splitData[1];
                break;
            case 'WKST':
                ruleObject.wkst = splitData[1];
                break;
        }
    });
    if ((ruleObject.freq === 'MONTHLY') && (ruleObject.monthDay.length === 0)) {
        const index = ruleObject.validRules.indexOf('BYDAY');
        ruleObject.validRules.splice(index, 1);
    }
    return ruleObject;
}
/**
 * Internal method to validate proper date
 *
 * @param {Date} tempDate Accepts the date value
 * @param {number} data Accepts the data value
 * @param {Date} startDate Accepts the start date
 * @returns {boolean} Returns the result of date validate
 * @private
 */
function validateProperDate(tempDate, data, startDate) {
    const maxDate = calendarUtil.getMonthDaysCount(tempDate);
    return (data <= maxDate) && (tempDate >= startDate);
}
/**
 * Internal method to process week days
 *
 * @param {string[]} expectedDays Accepts the expection dates
 * @returns {Object} Returns the weekdays object
 * @private
 */
function processWeekDays(expectedDays) {
    const dayCycle = {};
    expectedDays.forEach((element, index) => {
        if (index === expectedDays.length - 1) {
            const startIndex = dayIndex.indexOf(element);
            let temp = startIndex;
            while (temp % 7 !== dayIndex.indexOf(expectedDays[0])) {
                temp++;
            }
            dayCycle[`${element}`] = temp - startIndex;
        }
        else {
            dayCycle[`${element}`] = dayIndex.indexOf(expectedDays[(index + 1)]) - dayIndex.indexOf(element);
        }
    });
    return dayCycle;
}
/**
 * Internal method to check date
 *
 * @param {Date} tempDate Accepts the date value
 * @param {number[]} expectedDate Accepts the exception dates
 * @returns {boolean} Returns the boolean value
 * @private
 */
function checkDate(tempDate, expectedDate) {
    const temp = expectedDate.slice(0);
    let data;
    const maxDate = calendarUtil.getMonthDaysCount(tempDate);
    data = temp.shift();
    while (data) {
        if (data < 0) {
            data = data + maxDate + 1;
        }
        if (data === tempDate.getDate()) {
            return false;
        }
        data = temp.shift();
    }
    return true;
}
/**
 * Internal method to check the year value
 *
 * @param {Date} tempDate Accepts the date value
 * @param {number[]} expectedyearDay Accepts the exception dates in year
 * @returns {boolean} Returns the boolean value
 * @private
 */
function checkYear(tempDate, expectedyearDay) {
    const temp = expectedyearDay.slice(0);
    let data;
    const yearDay = getYearDay(tempDate);
    data = temp.shift();
    while (data) {
        if (data < 0) {
            data = data + calendarUtil.getYearDaysCount(tempDate, 0) + 1;
        }
        if (data === yearDay) {
            return false;
        }
        data = temp.shift();
    }
    return true;
}
/**
 * Internal method to get the year day
 *
 * @param {Date} currentDate Accepts the date value
 * @returns {number} Returns the boolean value
 * @private
 */
function getYearDay(currentDate) {
    if (!startDateCollection[calendarUtil.getFullYear(currentDate)]) {
        startDateCollection[calendarUtil.getFullYear(currentDate)] = calendarUtil.getYearLastDate(currentDate, 0);
    }
    const tempDate = startDateCollection[calendarUtil.getFullYear(currentDate)];
    const diff = currentDate.getTime() - tempDate.getTime();
    return Math.ceil(diff / MS_PER_DAY);
}
/**
 * Internal method to validate monthly rule type
 *
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {MonthlyType} Returns the monthly type object
 * @private
 */
function validateMonthlyRuleType(ruleObject) {
    if (ruleObject.monthDay.length && !ruleObject.day.length) {
        return 'date';
    }
    else if (!ruleObject.monthDay.length && ruleObject.day.length) {
        return 'day';
    }
    return 'both';
}
/**
 * Internal method to re-order the week days based on first day of week
 *
 * @param {string[]} days Accepts the week days value
 * @returns {void}
 * @private
 */
function rotate(days) {
    const data = days.shift();
    days.push(data);
}
/**
 * Internal method to set first day of week
 *
 * @param {string} day Accepts the first day string
 * @returns {void}
 * @private
 */
function setFirstDayOfWeek(day) {
    while (dayIndex[0] !== day) {
        rotate(dayIndex);
    }
}
/**
 * Internal method to validate recurrence rule
 *
 * @param {Date} tempDate Accepts the date value
 * @param {RecRule} ruleObject Accepts the recurrence rule object
 * @returns {boolean} Returns the boolean value
 * @private
 */
function validateRules(tempDate, ruleObject) {
    let state = true;
    const expectedDays = ruleObject.day;
    const expectedMonth = ruleObject.month;
    const expectedDate = calendarUtil.getExpectedDays(tempDate, ruleObject.monthDay);
    const expectedyearDay = ruleObject.yearDay;
    ruleObject.validRules.forEach((rule) => {
        switch (rule) {
            case 'BYDAY':
                if (checkDayIndex(tempDate.getDay(), expectedDays)) {
                    state = false;
                }
                break;
            case 'BYMONTH':
                if (calendarUtil.checkMonth(tempDate, expectedMonth)) {
                    state = false;
                }
                break;
            case 'BYMONTHDAY':
                if (checkDate(tempDate, expectedDate)) {
                    state = false;
                }
                break;
            case 'BYYEARDAY':
                if (checkYear(tempDate, expectedyearDay)) {
                    state = false;
                }
                break;
        }
    });
    return state;
}
/**
 * Internal method to get calendar util
 *
 * @param {CalendarType} calendarMode Accepts the calendar type object
 * @returns {CalendarUtil} Returns the calendar util object
 * @private
 */
function getCalendarUtil(calendarMode) {
    if (calendarMode === 'Islamic') {
        return new Islamic();
    }
    return new Gregorian();
}
const startDateCollection = {};
let tempExcludeDate;
const dayIndex = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
let maxOccurrence;
let tempViewDate;
let calendarUtil;
const DAYINDEX = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
const MAXOCCURRENCE = 43;
const WEEKPOS = ['first', 'second', 'third', 'fourth', 'last'];
const TIMES = 'summaryTimes';
const ON = 'summaryOn';
const EVERY = 'every';
const UNTIL = 'summaryUntil';
const DAYS = 'summaryDay';
const WEEKS = 'summaryWeek';
const MONTHS = 'summaryMonth';
const YEARS = 'summaryYear';
const DAYINDEXOBJECT = {
    SU: 'sun',
    MO: 'mon',
    TU: 'tue',
    WE: 'wed',
    TH: 'thu',
    FR: 'fri',
    SA: 'sat'
};
// To check string has number
const HASNUMBER = /\d/;
// To find the numbers in string
const REMOVENUMBERINSTRING = /[^A-Z]+/;
// To split number and string
const SPLITNUMBERANDSTRING = /[a-z]+|[^a-z]+/gi;
/**
 * Method to generate string from date
 *
 * @param {Date} date Accepts the date value
 * @returns {string} Returns the string value
 */
function getRecurrenceStringFromDate(date) {
    return [date.getUTCFullYear(),
        roundDateValues(date.getUTCMonth() + 1),
        roundDateValues(date.getUTCDate()),
        'T',
        roundDateValues(date.getUTCHours()),
        roundDateValues(date.getUTCMinutes()),
        roundDateValues(date.getUTCSeconds()),
        'Z'].join('');
}
/**
 * Internal method to round the date values
 *
 * @param {string | number} date Accepts the date value in either string or number format
 * @returns {string} Returns the date value in string format
 * @private
 */
function roundDateValues(date) {
    return ('0' + date).slice(-2);
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable max-len */
/**
 * EventBase for appointment rendering
 */
class EventBase {
    /**
     * Constructor for EventBase
     *
     * @param {Schedule} parent Accepts the schedule instance
     */
    constructor(parent) {
        this.slots = [];
        this.isDoubleTapped = false;
        this.parent = parent;
    }
    processData(events, timeZonePropChanged, oldTimezone) {
        const start = this.parent.activeView.startDate();
        const end = this.parent.activeView.endDate();
        const fields = this.parent.eventFields;
        let processed = [];
        let temp = 1;
        let generateID = false;
        const resourceCollection = this.parent.resourceBase ? this.parent.resourceBase.resourceCollection : [];
        if (events.length > 0 && isNullOrUndefined(events[0][fields.id])) {
            generateID = true;
        }
        for (let event of events) {
            if (generateID) {
                event[fields.id] = temp++;
            }
            event = this.updateEventDateTime(event);
            if (timeZonePropChanged) {
                this.processTimezoneChange(event, oldTimezone);
            }
            else if (!this.parent.isPrinting && !this.parent.uiStateValues.isPreventTimezone) {
                event = this.processTimezone(event);
            }
            for (let level = 0; level < resourceCollection.length; level++) {
                if (event[resourceCollection[parseInt(level.toString(), 10)].field] === null || event[resourceCollection[parseInt(level.toString(), 10)].field] === 0) {
                    event[resourceCollection[parseInt(level.toString(), 10)].field] = undefined;
                }
            }
            if (!isNullOrUndefined(event[fields.recurrenceRule]) && event[fields.recurrenceRule] === '') {
                event[fields.recurrenceRule] = null;
            }
            if (!isNullOrUndefined(event[fields.recurrenceRule]) && isNullOrUndefined(event[fields.recurrenceID]) &&
                !(this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction)) {
                processed = processed.concat(this.generateOccurrence(event, null, oldTimezone, true));
            }
            else {
                if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction) {
                    if (!isNullOrUndefined(event[fields.recurrenceRule]) && isNullOrUndefined(event[fields.recurrenceID])) {
                        const recurrenceEvent = this.generateOccurrence(event, null, oldTimezone, true);
                        for (const occurrence of recurrenceEvent) {
                            const app = this.parent.eventsProcessed.filter((data) => data[fields.startTime].getTime() - occurrence[fields.startTime].getTime() === 0 &&
                                data[fields.id] === occurrence[fields.id]);
                            occurrence.Guid = (app.length > 0) ? app[0].Guid : this.generateGuid();
                            processed.push(occurrence);
                        }
                    }
                    else {
                        const app = this.parent.eventsProcessed.filter((data) => data[this.parent.eventFields.id] === event[this.parent.eventFields.id]);
                        event.Guid = (app.length > 0) ? app[0].Guid : this.generateGuid();
                        processed.push(event);
                    }
                }
                else {
                    event.Guid = this.generateGuid();
                    processed.push(event);
                }
            }
        }
        this.parent.eventsProcessed = [];
        const eventData = processed.filter((data) => !data[this.parent.eventFields.isBlock]);
        this.parent.eventsProcessed = this.filterEvents(start, end, eventData);
        const blockData = processed.filter((data) => data[this.parent.eventFields.isBlock]);
        for (const eventObj of blockData) {
            if (eventObj[fields.isAllDay]) {
                const isDifferentDate = resetTime(new Date(eventObj[fields.startTime].getTime())) <
                    resetTime(new Date(eventObj[fields.endTime].getTime()));
                if (!isDifferentDate) {
                    eventObj[fields.startTime] = resetTime(eventObj[fields.startTime]);
                    eventObj[fields.endTime] = addDays(resetTime(eventObj[fields.endTime]), 1);
                }
            }
        }
        this.parent.blockProcessed = blockData;
        return eventData;
    }
    updateEventDateTime(eventData) {
        if (typeof eventData[this.parent.eventFields.startTime] === 'string') {
            eventData[this.parent.eventFields.startTime] = getDateFromString(eventData[this.parent.eventFields.startTime]);
        }
        if (typeof eventData[this.parent.eventFields.endTime] === 'string') {
            eventData[this.parent.eventFields.endTime] = getDateFromString(eventData[this.parent.eventFields.endTime]);
        }
        return eventData;
    }
    getProcessedEvents(eventCollection = this.parent.eventsData) {
        let processed = [];
        for (const event of eventCollection) {
            if (!isNullOrUndefined(event[this.parent.eventFields.recurrenceRule]) &&
                isNullOrUndefined(event[this.parent.eventFields.recurrenceID])) {
                processed = processed.concat(this.generateOccurrence(event));
            }
            else {
                processed.push(event);
            }
        }
        return processed;
    }
    timezonePropertyChange(oldTimezone) {
        const data = this.parent.eventsData.concat(this.parent.blockData);
        const processed = this.processData(data, true, oldTimezone);
        this.parent.notify(dataReady, { processedData: processed });
    }
    timezoneConvert(eventData) {
        const fields = this.parent.eventFields;
        eventData[fields.startTimezone] = eventData[fields.startTimezone] || eventData[fields.endTimezone];
        eventData[fields.endTimezone] = eventData[fields.endTimezone] || eventData[fields.startTimezone];
        if (this.parent.timezone) {
            const startTz = eventData[fields.startTimezone];
            const endTz = eventData[fields.endTimezone];
            eventData[fields.startTime] = this.parent.tzModule.convert(eventData[fields.startTime], this.parent.timezone, startTz);
            eventData[fields.endTime] = this.parent.tzModule.convert(eventData[fields.endTime], this.parent.timezone, endTz);
        }
    }
    processTimezoneChange(event, oldTimezone) {
        const fields = this.parent.eventFields;
        if (event[fields.isAllDay]) {
            return;
        }
        if (oldTimezone && this.parent.timezone) {
            event[fields.startTime] = this.parent.tzModule.convert(event[fields.startTime], oldTimezone, this.parent.timezone);
            event[fields.endTime] = this.parent.tzModule.convert(event[fields.endTime], oldTimezone, this.parent.timezone);
        }
        else if (!oldTimezone && this.parent.timezone) {
            event[fields.startTime] = this.parent.tzModule.add(event[fields.startTime], this.parent.timezone);
            event[fields.endTime] = this.parent.tzModule.add(event[fields.endTime], this.parent.timezone);
        }
        else if (oldTimezone && !this.parent.timezone) {
            event[fields.startTime] = this.parent.tzModule.remove(event[fields.startTime], oldTimezone);
            event[fields.endTime] = this.parent.tzModule.remove(event[fields.endTime], oldTimezone);
        }
    }
    processTimezone(event, isReverse = false) {
        const fields = this.parent.eventFields;
        if (event[fields.startTimezone] || event[fields.endTimezone]) {
            const startTimezone = event[fields.startTimezone] || event[fields.endTimezone];
            const endTimezone = event[fields.endTimezone] || event[fields.startTimezone];
            if (isReverse) {
                if (this.parent.timezone) {
                    event[fields.startTime] = this.parent.tzModule.convert(event[fields.startTime], startTimezone, this.parent.timezone);
                    event[fields.endTime] = this.parent.tzModule.convert(event[fields.endTime], endTimezone, this.parent.timezone);
                    event[fields.startTime] = this.parent.tzModule.remove(event[fields.startTime], this.parent.timezone);
                    event[fields.endTime] = this.parent.tzModule.remove(event[fields.endTime], this.parent.timezone);
                }
                else {
                    event[fields.startTime] = this.parent.tzModule.remove(event[fields.startTime], startTimezone);
                    event[fields.endTime] = this.parent.tzModule.remove(event[fields.endTime], endTimezone);
                }
            }
            else {
                event[fields.startTime] = this.parent.tzModule.add(event[fields.startTime], startTimezone);
                event[fields.endTime] = this.parent.tzModule.add(event[fields.endTime], endTimezone);
                if (this.parent.timezone) {
                    event[fields.startTime] = this.parent.tzModule.convert(event[fields.startTime], startTimezone, this.parent.timezone);
                    event[fields.endTime] = this.parent.tzModule.convert(event[fields.endTime], endTimezone, this.parent.timezone);
                }
            }
        }
        else if (this.parent.timezone) {
            if (isReverse) {
                event[fields.startTime] = this.parent.tzModule.remove(event[fields.startTime], this.parent.timezone);
                event[fields.endTime] = this.parent.tzModule.remove(event[fields.endTime], this.parent.timezone);
            }
            else {
                event[fields.startTime] = this.parent.tzModule.add(event[fields.startTime], this.parent.timezone);
                event[fields.endTime] = this.parent.tzModule.add(event[fields.endTime], this.parent.timezone);
            }
        }
        return event;
    }
    filterBlockEvents(eventObj) {
        const fields = this.parent.eventFields;
        const eStart = eventObj[fields.startTime];
        const eEnd = eventObj[fields.endTime];
        let resourceData;
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            const data = this.getGroupIndexFromEvent(eventObj);
            resourceData = this.parent.resourceBase.lastResourceLevel[parseInt(data.toString(), 10)];
        }
        const blockEvents = extend([], this.parent.blockProcessed, null, true);
        for (const eventObj of blockEvents) {
            if (eventObj[fields.isAllDay]) {
                const isDifferentTime = eventObj[fields.endTime].getTime() >
                    resetTime(new Date(eventObj[fields.endTime].getTime())).getTime();
                if (isDifferentTime) {
                    eventObj[fields.startTime] = resetTime(eventObj[fields.startTime]);
                    eventObj[fields.endTime] = addDays(resetTime(eventObj[fields.endTime]), 1);
                }
            }
        }
        return this.filterEvents(eStart, eEnd, blockEvents, resourceData);
    }
    filterEvents(startDate, endDate, appointments = this.parent.eventsProcessed, resourceTdData) {
        const predicate = this.parent.dataModule.getStartEndQuery(startDate, endDate);
        let filter = new DataManager({ json: appointments }).executeLocal(new Query().where(predicate));
        if (resourceTdData) {
            filter = this.filterEventsByResource(resourceTdData, filter);
        }
        return this.sortByTime(filter);
    }
    filterEventsByRange(eventCollection, startDate, endDate) {
        let filteredEvents = [];
        if (startDate && endDate) {
            filteredEvents = this.filterEvents(startDate, endDate, eventCollection);
        }
        else if (startDate && !endDate) {
            filteredEvents = eventCollection.filter((e) => e[this.parent.eventFields.startTime] >= startDate);
        }
        else if (!startDate && endDate) {
            filteredEvents = eventCollection.filter((e) => e[this.parent.eventFields.endTime] <= endDate);
        }
        else {
            filteredEvents = eventCollection;
        }
        return this.sortByTime(filteredEvents);
    }
    filterEventsByResource(resourceTdData, appointments = this.parent.eventsProcessed) {
        const predicate = {};
        const resourceCollection = this.parent.resourceBase.resourceCollection;
        for (let level = 0; level < resourceCollection.length; level++) {
            predicate[resourceCollection[parseInt(level.toString(), 10)].field] = resourceTdData.groupOrder[parseInt(level.toString(), 10)];
        }
        const keys = Object.keys(predicate);
        const filteredCollection = appointments.filter((eventObj) => keys.every((key) => {
            if (eventObj[`${key}`] instanceof Array) {
                return eventObj[`${key}`].indexOf(predicate[`${key}`]) > -1;
            }
            else {
                return eventObj[`${key}`] === predicate[`${key}`];
            }
        }));
        return filteredCollection;
    }
    sortByTime(appointmentsCollection) {
        if (this.parent.eventSettings.sortComparer && (typeof (this.parent.eventSettings.sortComparer) === 'function' || typeof (this.parent.eventSettings.sortComparer) === 'string')) {
            appointmentsCollection = this.customSorting(appointmentsCollection);
        }
        else {
            const fieldMappings = this.parent.eventFields;
            appointmentsCollection.sort((a, b) => {
                const d1 = a[fieldMappings.startTime];
                const d2 = b[fieldMappings.startTime];
                return d1.getTime() - d2.getTime();
            });
        }
        return appointmentsCollection;
    }
    sortByDateTime(appointments) {
        if (this.parent.eventSettings.sortComparer && (typeof (this.parent.eventSettings.sortComparer) === 'function' || typeof (this.parent.eventSettings.sortComparer) === 'string')) {
            appointments = this.customSorting(appointments);
        }
        else {
            const fieldMapping = this.parent.eventFields;
            appointments.sort((object1, object2) => {
                const d3 = object1[fieldMapping.startTime];
                const d4 = object2[fieldMapping.startTime];
                const d5 = object1[fieldMapping.endTime];
                const d6 = object2[fieldMapping.endTime];
                const d1 = d5.getTime() - d3.getTime();
                const d2 = d6.getTime() - d4.getTime();
                return (d3.getTime() - d4.getTime() || d2 - d1);
            });
        }
        return appointments;
    }
    customSorting(appointments) {
        if (typeof (this.parent.eventSettings.sortComparer) === 'function') {
            return this.parent.eventSettings.sortComparer.call(this.parent, appointments);
        }
        else if (typeof (this.parent.eventSettings.sortComparer) === 'string') {
            const splits = this.parent.eventSettings.sortComparer.split('.');
            let sortFn;
            if (!isNullOrUndefined(window)) {
                sortFn = window[splits[splits.length - 1]];
            }
            if (sortFn) {
                return sortFn(appointments);
            }
        }
        return appointments;
    }
    getSmallestMissingNumber(array) {
        const large = Math.max(...array);
        for (let i = 0; i < large; i++) {
            if (array.indexOf(i) === -1) {
                return i;
            }
        }
        return large + 1;
    }
    splitEventByDay(event) {
        const eventFields = this.parent.eventFields;
        const data = [];
        const eventStartTime = event[eventFields.startTime];
        const eventEndTime = event[eventFields.endTime];
        const isDifferentDate = resetTime(new Date(eventStartTime.getTime())) <
            resetTime(new Date(eventEndTime.getTime()));
        if (isDifferentDate) {
            let start = new Date(eventStartTime.getTime());
            let end = addDays(resetTime(new Date(eventStartTime.getTime())), 1);
            const endDate = (eventEndTime.getHours() === 0 && eventEndTime.getMinutes() === 0) ?
                eventEndTime : addDays(eventEndTime, 1);
            let index = 1;
            const eventLength = getDaysCount(eventStartTime.getTime(), endDate.getTime());
            while (end <= eventEndTime && start.getTime() !== end.getTime()) {
                const app = extend({}, event);
                app[eventFields.startTime] = start;
                app[eventFields.endTime] = end;
                app.data = { index: index, count: eventLength };
                app.Guid = this.generateGuid();
                app.isSpanned = true;
                data.push(app);
                start = end;
                if ((resetTime(new Date(start.getTime())).getTime() === resetTime(new Date(eventEndTime.getTime())).getTime())
                    && !(end.getTime() === eventEndTime.getTime())) {
                    end = new Date(start.getTime());
                    end = new Date(end.setHours(eventEndTime.getHours(), eventEndTime.getMinutes(), eventEndTime.getSeconds()));
                }
                else {
                    end = addDays(resetTime(new Date(start.getTime())), 1);
                }
                index++;
            }
        }
        else {
            data.push(event);
        }
        return data;
    }
    splitEvent(event, dateRender) {
        const fields = this.parent.eventFields;
        let start = resetTime(event[fields.startTime]).getTime();
        let end = resetTime(event[fields.endTime]).getTime();
        if (getDateInMs(event[fields.endTime]) <= 0) {
            const temp = addDays(resetTime(event[fields.endTime]), -1).getTime();
            end = start > temp ? start : temp;
        }
        const orgStart = start;
        const orgEnd = end;
        const ranges = [];
        if (start !== end) {
            if (start < dateRender[0].getTime()) {
                start = dateRender[0].getTime();
            }
            if (end > dateRender[dateRender.length - 1].getTime()) {
                end = dateRender[dateRender.length - 1].getTime();
            }
            let cStart = start;
            for (let level = 0; level < this.slots.length; level++) {
                let slot = this.slots[parseInt(level.toString(), 10)];
                if (this.parent.currentView === 'WorkWeek' || this.parent.currentView === 'TimelineWorkWeek'
                    || this.parent.activeViewOptions.group.byDate || this.parent.activeViewOptions.showWeekend) {
                    const slotDates = [];
                    for (const s of slot) {
                        slotDates.push(new Date(s));
                    }
                    const renderedDates = this.getRenderedDates(slotDates);
                    if (!isNullOrUndefined(renderedDates) && renderedDates.length > 0) {
                        slot = [];
                        for (const date of renderedDates) {
                            slot.push(date.getTime());
                        }
                    }
                }
                if (typeof (slot) === 'number') {
                    const temp = slot;
                    slot = [];
                    slot.push(temp);
                }
                const firstSlot = slot[0];
                cStart = (cStart <= firstSlot && end >= firstSlot) ? firstSlot : cStart;
                if (cStart > end || firstSlot > end) {
                    break;
                }
                if (!this.parent.activeViewOptions.group.byDate && this.parent.activeViewOptions.showWeekend &&
                    this.parent.currentView !== 'WorkWeek' && this.parent.currentView !== 'TimelineWorkWeek') {
                    const startIndex = slot.indexOf(cStart);
                    if (startIndex !== -1) {
                        let endIndex = slot.indexOf(end);
                        const hasBreak = endIndex !== -1;
                        endIndex = hasBreak ? endIndex : slot.length - 1;
                        const count = ((endIndex - startIndex) + 1);
                        const isLeft = (slot[parseInt(startIndex.toString(), 10)] !== orgStart);
                        const isRight = (slot[parseInt(endIndex.toString(), 10)] !== orgEnd);
                        ranges.push(this.cloneEventObject(event, slot[parseInt(startIndex.toString(), 10)], slot[parseInt(endIndex.toString(), 10)], count, isLeft, isRight));
                        if (hasBreak) {
                            break;
                        }
                    }
                }
                else {
                    if (this.dateInRange(cStart, slot[0], slot[slot.length - 1])) {
                        const availSlot = [];
                        for (let i = 0; i < slot.length; i++) {
                            if (this.dateInRange(slot[parseInt(i.toString(), 10)], orgStart, orgEnd)) {
                                availSlot.push(slot[parseInt(i.toString(), 10)]);
                            }
                        }
                        if (availSlot.length > 0) {
                            if (!this.parent.activeViewOptions.group.byDate) {
                                const isLeft = (availSlot[0] !== orgStart);
                                const isRight = (availSlot[availSlot.length - 1] !== orgEnd);
                                ranges.push(this.cloneEventObject(event, availSlot[0], availSlot[availSlot.length - 1], availSlot.length, isLeft, isRight));
                            }
                            else {
                                for (const slot of availSlot) {
                                    ranges.push(this.cloneEventObject(event, slot, slot, 1, (slot !== orgStart), (slot !== orgEnd)));
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            ranges.push(this.cloneEventObject(event, start, end, 1, false, false));
        }
        return ranges;
    }
    cloneEventObject(event, start, end, count, isLeft, isRight) {
        const fields = this.parent.eventFields;
        const e = extend({}, event, null, true);
        const data = { count: count, isLeft: isLeft, isRight: isRight };
        data[fields.startTime] = event[fields.startTime];
        data[fields.endTime] = event[fields.endTime];
        e.data = data;
        e[fields.startTime] = new Date(start);
        e[fields.endTime] = new Date(end);
        return e;
    }
    dateInRange(date, start, end) {
        return start <= date && date <= end;
    }
    getSelectedEventElements(target) {
        this.removeSelectedAppointmentClass();
        if (this.parent.selectedElements.length <= 0) {
            this.parent.selectedElements.push(target);
        }
        else {
            const isAlreadySelected = this.parent.selectedElements.filter((element) => element.getAttribute('data-guid') === target.getAttribute('data-guid'));
            if (isAlreadySelected.length <= 0) {
                const elementSelector = 'div[data-guid="' + target.getAttribute('data-guid') + '"]';
                const focusElements = [].slice.call(this.parent.element.querySelectorAll(elementSelector));
                for (const element of focusElements) {
                    this.parent.selectedElements.push(element);
                }
            }
            else {
                const selectedElements = this.parent.selectedElements.filter((element) => element.getAttribute('data-guid') !== target.getAttribute('data-guid'));
                this.parent.selectedElements = selectedElements;
            }
        }
        if (target && this.parent.selectedElements.length > 0) {
            this.addSelectedAppointments(this.parent.selectedElements, false);
        }
        return this.parent.selectedElements;
    }
    getSelectedEvents() {
        const eventSelect = [];
        const elementSelect = [];
        const selectAppointments = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_BORDER));
        selectAppointments.filter((element) => {
            const isAlreadyAdded = eventSelect.filter((event) => {
                return event.Guid === element.getAttribute('data-guid');
            });
            if (isAlreadyAdded.length === 0) {
                eventSelect.push(this.getEventByGuid(element.getAttribute('data-guid')));
            }
            elementSelect.push(element);
        });
        return {
            event: eventSelect.length > 1 ? eventSelect : eventSelect[0],
            element: elementSelect.length > 1 ? elementSelect : elementSelect[0]
        };
    }
    removeSelectedAppointmentClass() {
        const selectedAppointments = this.getSelectedAppointments();
        removeClass(selectedAppointments, APPOINTMENT_BORDER);
        if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {
            removeClass(selectedAppointments, AGENDA_SELECTED_CELL);
        }
    }
    addSelectedAppointments(cells, preventFocus) {
        if (this.parent.currentView !== 'MonthAgenda') {
            this.parent.removeSelectedClass();
        }
        addClass(cells, APPOINTMENT_BORDER);
        if (cells.length > 0 && !preventFocus) {
            cells[cells.length - 1].focus();
        }
    }
    getSelectedAppointments() {
        return [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_BORDER + ',.' + APPOINTMENT_CLASS + ':focus'));
    }
    focusElement(isFocused) {
        if (this.parent.eventWindow.dialogObject && this.parent.eventWindow.dialogObject.visible) {
            return;
        }
        const activeEle = document.activeElement;
        const selectedCell = this.parent.getSelectedCells();
        if (selectedCell.length > 0 && ((activeEle && (this.parent.element.contains(activeEle) ||
            selectedCell.indexOf(activeEle) !== -1)) || isFocused)) {
            if (this.parent.keyboardInteractionModule) {
                const target = ((!isNullOrUndefined(this.parent.activeCellsData) &&
                    this.parent.activeCellsData.element) || selectedCell[selectedCell.length - 1]);
                this.parent.keyboardInteractionModule.selectCells(target instanceof Array, target);
            }
            return;
        }
        const selectedAppointments = this.getSelectedAppointments();
        if (selectedAppointments.length > 0) {
            if (this.parent.activeEventData && this.parent.activeEventData.element && selectedAppointments.indexOf(this.parent.activeEventData.element) > -1) {
                this.parent.activeEventData.element.focus();
                return;
            }
            selectedAppointments[selectedAppointments.length - 1].focus();
            return;
        }
    }
    selectWorkCellByTime(eventsData) {
        let target;
        if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {
            return target;
        }
        if (eventsData.length > 0) {
            const selectedObject = eventsData[eventsData.length - 1];
            const eventStartTime = selectedObject[this.parent.eventFields.startTime];
            let nearestTime = new Date(+eventStartTime).setMinutes(0, 0, 0);
            const isAllDay = this.isAllDayAppointment(selectedObject);
            if (this.parent.currentView === 'Month' || isAllDay) {
                nearestTime = new Date(+eventStartTime).setHours(0, 0, 0, 0);
            }
            let targetArea;
            if (isAllDay && ['Day', 'Week', 'WorkWeek'].indexOf(this.parent.currentView) !== -1) {
                targetArea = this.parent.getAllDayRow();
            }
            else {
                targetArea = this.parent.getContentTable();
            }
            let queryString = '[data-date="' + new Date(nearestTime).getTime() + '"]';
            if (this.parent.activeViewOptions.group.resources.length > 0) {
                queryString += '[data-group-index="' + this.getGroupIndexFromEvent(selectedObject) + '"]';
            }
            target = targetArea.querySelector(queryString);
            if (target) {
                this.parent.activeCellsData = this.parent.getCellDetails(target);
                if (this.parent.keyboardInteractionModule) {
                    this.parent.keyboardInteractionModule.selectCells(false, target);
                }
                return target;
            }
        }
        return target;
    }
    getGroupIndexFromEvent(eventData) {
        let levelIndex;
        let resource;
        let levelName;
        let idField;
        for (let i = this.parent.resourceBase.resourceCollection.length - 1; i >= 0; i--) {
            const resourceData = eventData[this.parent.resourceBase.resourceCollection[parseInt(i.toString(), 10)].field];
            if (!isNullOrUndefined(resourceData)) {
                resource = this.parent.resourceBase.resourceCollection[parseInt(i.toString(), 10)];
                levelIndex = i;
                levelName = resource.name;
                idField = resource.field;
                break;
            }
        }
        if (isNullOrUndefined(levelName) && isNullOrUndefined(levelIndex)) {
            levelName = this.parent.resourceCollection.slice(-1)[0].name;
            levelIndex = this.parent.resourceCollection.length - 1;
            idField = this.parent.resourceCollection.slice(-1)[0].field;
            resource = this.parent.resourceCollection.filter((e, index) => {
                if (e.name === levelName) {
                    levelIndex = index;
                    return e;
                }
                return null;
            })[0];
        }
        const id = ((eventData[`${idField}`] instanceof Array) ?
            eventData[`${idField}`][0] : eventData[`${idField}`]);
        if (levelIndex > 0) {
            const parentField = this.parent.resourceCollection[levelIndex - 1].field;
            return this.parent.resourceBase.getIndexFromResourceId(id, levelName, resource, eventData, parentField);
        }
        else {
            return this.parent.resourceBase.getIndexFromResourceId(id, levelName, resource);
        }
    }
    isAllDayAppointment(event) {
        const fieldMapping = this.parent.eventFields;
        const isAllDay = event[fieldMapping.isAllDay];
        const isFullDay = ((getUniversalTime(event[fieldMapping.endTime]) - getUniversalTime(event[fieldMapping.startTime]))
            / MS_PER_DAY) >= 1;
        return (isAllDay || (this.parent.eventSettings.spannedEventPlacement !== 'TimeSlot' && isFullDay)) ? true : false;
    }
    addEventListener() {
        this.parent.on(documentClick, this.appointmentBorderRemove, this);
    }
    removeEventListener() {
        this.parent.off(documentClick, this.appointmentBorderRemove);
    }
    appointmentBorderRemove(event) {
        const element = event.event.target;
        if (closest(element, '.' + APPOINTMENT_CLASS)) {
            if (this.parent.currentView !== 'MonthAgenda') {
                this.parent.removeSelectedClass();
            }
        }
        else if (!closest(element, '.' + POPUP_OPEN)) {
            this.removeSelectedAppointmentClass();
            this.parent.selectedElements = [];
        }
    }
    wireAppointmentEvents(element, event, isPreventCrud = false) {
        const isReadOnly = (!isNullOrUndefined(event)) ? event[this.parent.eventFields.isReadonly] : false;
        EventHandler.add(element, 'click', this.eventClick, this);
        if (!this.parent.isAdaptive && !this.parent.activeViewOptions.readonly && !isReadOnly) {
            EventHandler.add(element, 'touchstart', this.eventTouchClick, this);
            EventHandler.add(element, 'dblclick', this.eventDoubleClick, this);
        }
        if (!this.parent.activeViewOptions.readonly && !isReadOnly && !isPreventCrud) {
            if (this.parent.resizeModule) {
                this.parent.resizeModule.wireResizeEvent(element);
            }
            if (this.parent.dragAndDropModule) {
                this.parent.dragAndDropModule.wireDragEvent(element);
            }
        }
    }
    eventTouchClick(e) {
        setTimeout(() => this.isDoubleTapped = false, 250);
        e.preventDefault();
        if (this.isDoubleTapped) {
            this.eventDoubleClick(e);
        }
        else if (!this.isDoubleTapped) {
            this.isDoubleTapped = true;
            this.eventClick(e);
        }
    }
    renderResizeHandler(element, spanEvent, isReadOnly) {
        if (!this.parent.resizeModule || !this.parent.allowResizing || this.parent.activeViewOptions.readonly || isReadOnly) {
            return;
        }
        for (const resizeEdge of Object.keys(spanEvent)) {
            const resizeHandler = createElement('div', { className: EVENT_RESIZE_CLASS });
            switch (resizeEdge) {
                case 'isLeft':
                    if (!spanEvent.isLeft) {
                        resizeHandler.appendChild(createElement('div', { className: 'e-left-right-resize' }));
                        addClass([resizeHandler], this.parent.enableRtl ? RIGHT_RESIZE_HANDLER : LEFT_RESIZE_HANDLER);
                        prepend([resizeHandler], element);
                    }
                    break;
                case 'isRight':
                    if (!spanEvent.isRight) {
                        resizeHandler.appendChild(createElement('div', { className: 'e-left-right-resize' }));
                        addClass([resizeHandler], this.parent.enableRtl ? LEFT_RESIZE_HANDLER : RIGHT_RESIZE_HANDLER);
                        append([resizeHandler], element);
                    }
                    break;
                case 'isTop':
                    if (!spanEvent.isTop) {
                        resizeHandler.appendChild(createElement('div', { className: 'e-top-bottom-resize' }));
                        addClass([resizeHandler], TOP_RESIZE_HANDLER);
                        prepend([resizeHandler], element);
                    }
                    break;
                case 'isBottom':
                    if (!spanEvent.isBottom) {
                        resizeHandler.appendChild(createElement('div', { className: 'e-top-bottom-resize' }));
                        addClass([resizeHandler], BOTTOM_RESIZE_HANDLER);
                        append([resizeHandler], element);
                    }
                    break;
            }
        }
    }
    eventClick(eventData) {
        const target = eventData.target;
        if (target.classList.contains(DRAG_CLONE_CLASS) || target.classList.contains(RESIZE_CLONE_CLASS) ||
            target.classList.contains(INLINE_SUBJECT_CLASS)) {
            return;
        }
        if ((eventData.ctrlKey || eventData.metaKey) && eventData.which === 1 && this.parent.keyboardInteractionModule) {
            this.parent.quickPopup.quickPopup.hide();
            this.parent.selectedElements = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_BORDER));
            const target = closest(eventData.target, '.' + APPOINTMENT_CLASS);
            this.getSelectedEventElements(target);
            this.activeEventData(eventData, false);
            const selectArgs = {
                data: this.parent.activeEventData.event,
                element: this.parent.activeEventData.element,
                event: eventData, requestType: 'eventSelect'
            };
            this.parent.trigger(select, selectArgs);
            const args = extend(this.parent.activeEventData, { cancel: false, originalEvent: eventData });
            this.parent.trigger(eventClick, args);
        }
        else {
            this.removeSelectedAppointmentClass();
            this.activeEventData(eventData, true);
            const selectEventArgs = {
                data: this.parent.activeEventData.event,
                element: this.parent.activeEventData.element,
                event: eventData, requestType: 'eventSelect'
            };
            this.parent.trigger(select, selectEventArgs);
            const args = extend(this.parent.activeEventData, { cancel: false, originalEvent: eventData });
            this.parent.trigger(eventClick, args, (eventClickArgs) => {
                if (eventClickArgs.cancel) {
                    this.removeSelectedAppointmentClass();
                    this.parent.selectedElements = [];
                    if (this.parent.quickPopup) {
                        this.parent.quickPopup.quickPopupHide();
                    }
                }
                else {
                    if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {
                        addClass([this.parent.activeEventData.element], AGENDA_SELECTED_CELL);
                    }
                    if (this.parent.allowInline) {
                        const inlineArgs = {
                            data: eventClickArgs.event,
                            element: eventClickArgs.element,
                            type: 'Event'
                        };
                        this.parent.notify(inlineClick, inlineArgs);
                    }
                    else {
                        this.parent.notify(eventClick, eventClickArgs);
                    }
                }
            });
        }
    }
    eventDoubleClick(e) {
        if (this.parent.quickPopup) {
            this.parent.quickPopup.quickPopupHide(true);
        }
        if (e.type === 'touchstart') {
            this.activeEventData(e, true);
        }
        this.removeSelectedAppointmentClass();
        this.parent.selectedElements = [];
        if (this.parent.activeEventData.element.classList.contains(INLINE_APPOINTMENT_CLASS) ||
            this.parent.activeEventData.element.querySelector('.' + INLINE_SUBJECT_CLASS)) {
            return;
        }
        if (!isNullOrUndefined(this.parent.activeEventData.event) &&
            isNullOrUndefined(this.parent.activeEventData.event[this.parent.eventFields.recurrenceID])) {
            this.parent.eventWindow.openEditor(this.parent.activeEventData.event, 'Save');
        }
        else {
            this.parent.currentAction = 'EditOccurrence';
            this.parent.quickPopup.openRecurrenceAlert();
        }
    }
    getEventByGuid(guid) {
        return this.parent.eventsProcessed.filter((data) => data.Guid === guid)[0];
    }
    getEventById(id) {
        return this.parent.eventsData.filter((data) => data[this.parent.eventFields.id] === id)[0];
    }
    generateGuid() {
        return 'xyxxxxyx-xxxy-yxxx-xyxx-xxyxxxxyyxxx'.replace(/[xy]/g, (c) => {
            const r = Math.random() * 16 | 0;
            const v = (c === 'x') ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    getEventIDType() {
        if (this.parent.eventsData.length !== 0) {
            return typeof (this.parent.eventsData[0][this.parent.eventFields.id]);
        }
        if (this.parent.blockData.length !== 0) {
            return typeof (this.parent.blockData[0][this.parent.eventFields.id]);
        }
        return 'string';
    }
    getEventMaxID(resourceId) {
        if (this.parent.eventsData.length < 1 && this.parent.blockData.length < 1) {
            return 1;
        }
        let eventId;
        const idType = this.getEventIDType();
        if (idType === 'string') {
            eventId = this.generateGuid();
        }
        if (idType === 'number') {
            const datas = this.parent.eventsData.concat(this.parent.blockData);
            const appIds = datas.map((event) => event[this.parent.eventFields.id]);
            let maxId = appIds.reduce((a, b) => Math.max(a, b));
            maxId = isNullOrUndefined(resourceId) ? maxId : maxId + resourceId;
            eventId = maxId + 1;
        }
        return eventId;
    }
    activeEventData(eventData, isMultiple) {
        const target = closest(eventData.target, '.' + APPOINTMENT_CLASS);
        const guid = target.getAttribute('data-guid');
        if (isMultiple) {
            this.addSelectedAppointments([].slice.call(this.parent.element.querySelectorAll('div[data-guid="' + guid + '"]')), true);
            target.focus();
        }
        let eventObject = this.getEventByGuid(guid);
        if (eventObject && eventObject.isSpanned) {
            eventObject = this.parent.eventsData.filter((obj) => obj[this.parent.eventFields.id] === eventObject[this.parent.eventFields.id])[0];
        }
        this.parent.activeEventData = { event: eventObject, element: target };
    }
    generateOccurrence(event, viewDate, oldTimezone, isMaxCount) {
        const startDate = event[this.parent.eventFields.startTime];
        const endDate = event[this.parent.eventFields.endTime];
        const eventRule = event[this.parent.eventFields.recurrenceRule];
        const timeZoneDiff = endDate.getTimezoneOffset() - startDate.getTimezoneOffset();
        const duration = (endDate.getTime() - startDate.getTime()) - (timeZoneDiff * 60000);
        viewDate = new Date((viewDate || this.parent.activeView.startDate()).getTime() - duration);
        const exception = event[this.parent.eventFields.recurrenceException];
        let maxCount;
        if (this.parent.currentView !== 'Agenda' && isMaxCount) {
            maxCount = getDateCount(viewDate, this.parent.activeView.endDate()) + 1;
        }
        const newTimezone = this.parent.timezone || this.parent.tzModule.getLocalTimezoneName();
        const firstDay = this.parent.activeViewOptions.firstDayOfWeek;
        const calendarMode = this.parent.calendarMode;
        const dates = generate(startDate, eventRule, exception, firstDay, maxCount, viewDate, calendarMode, oldTimezone, newTimezone);
        if (this.parent.currentView === 'Agenda' && eventRule.indexOf('COUNT') === -1 && eventRule.indexOf('UNTIL') === -1) {
            if (isNullOrUndefined(event.generatedDates)) {
                event.generatedDates = { start: new Date(dates[0]), end: new Date(dates[dates.length - 1]) };
            }
            else {
                if (dates[0] < event.generatedDates.start.getTime()) {
                    event.generatedDates.start = new Date(dates[0]);
                }
                if (dates[dates.length - 1] > event.generatedDates.end.getTime()) {
                    event.generatedDates.end = new Date(dates[dates.length - 1]);
                }
            }
        }
        const occurrenceCollection = [];
        for (let date of dates) {
            const clonedObject = extend({}, event, null, true);
            date = this.getDSTAdjustedTime(date, clonedObject);
            clonedObject[this.parent.eventFields.startTime] = new Date(date);
            clonedObject[this.parent.eventFields.endTime] = new Date(new Date(date).setMilliseconds(duration));
            clonedObject[this.parent.eventFields.recurrenceID] = clonedObject[this.parent.eventFields.id];
            delete clonedObject[this.parent.eventFields.recurrenceException];
            delete clonedObject[this.parent.eventFields.followingID];
            clonedObject.Guid = this.generateGuid();
            occurrenceCollection.push(clonedObject);
        }
        return occurrenceCollection;
    }
    getDSTAdjustedTime(date, event) {
        let occurDate = date;
        if (this.parent.timezone &&
            (event[this.parent.eventFields.startTimezone] || event[this.parent.eventFields.endTimezone])) {
            const eventOffset = this.getDSTDiff(event[this.parent.eventFields.startTime], new Date(date), event[this.parent.eventFields.startTimezone]);
            const schOffset = this.getDSTDiff(event[this.parent.eventFields.startTime], new Date(date), this.parent.timezone);
            occurDate = (new Date(date).getTime() - (eventOffset - schOffset) * 60000);
        }
        return occurDate;
    }
    getDSTDiff(startDate, occurDate, timezone) {
        const startOffset = this.parent.tzModule.offset(new Date(startDate), timezone);
        const occurOffset = this.parent.tzModule.offset(new Date(occurDate), timezone);
        return startOffset - occurOffset;
    }
    getParentEvent(eventObj, isParent = false) {
        let parentEvent;
        do {
            eventObj = this.getFollowingEvent(eventObj);
            if (eventObj) {
                parentEvent = extend({}, eventObj, null, true);
            }
        } while (eventObj && isParent);
        if (isParent && parentEvent) {
            const collection = this.getEventCollections(parentEvent);
            let followObj = collection.follow.slice(-1)[0];
            if (collection.occurrence.length > 0 && !parentEvent[this.parent.eventFields.recurrenceException]) {
                followObj = collection.occurrence.slice(-1)[0];
            }
            if (followObj) {
                parentEvent[this.parent.eventFields.recurrenceRule] = followObj[this.parent.eventFields.recurrenceRule];
            }
        }
        return parentEvent;
    }
    getEventCollections(parentObj, childObj) {
        const followingCollection = [];
        let occurrenceCollection = [];
        let followingEvent = parentObj;
        do {
            followingEvent = this.getFollowingEvent(followingEvent, true);
            if (followingEvent) {
                followingCollection.push(followingEvent);
            }
            occurrenceCollection = occurrenceCollection.concat(this.getOccurrenceEvent(followingEvent || parentObj));
        } while (followingEvent);
        let collections = {};
        if (childObj) {
            const fields = this.parent.eventFields;
            collections = {
                follow: followingCollection.filter((eventData) => eventData[fields.startTime] >= childObj[fields.startTime]),
                occurrence: occurrenceCollection.filter((eventData) => eventData[fields.startTime] >= childObj[fields.startTime])
            };
        }
        else {
            collections = { follow: followingCollection, occurrence: occurrenceCollection };
        }
        return collections;
    }
    getFollowingEvent(parentObj, isReverse) {
        const fields = this.parent.eventFields;
        let fieldValue;
        if (isReverse) {
            fieldValue = parentObj[fields.id];
        }
        else {
            fieldValue = (parentObj[fields.recurrenceID] || parentObj[fields.followingID]);
        }
        const parentApp = this.parent.eventsData.filter((data) => data[isReverse ? fields.followingID : fields.id] === fieldValue);
        return parentApp.shift();
    }
    isFollowingEvent(parentObj, childObj) {
        const parentStart = parentObj[this.parent.eventFields.startTime];
        const childStart = childObj[this.parent.eventFields.startTime];
        return parentStart.getHours() === childStart.getHours() && parentStart.getMinutes() === childStart.getMinutes() &&
            parentStart.getSeconds() === childStart.getSeconds();
    }
    getOccurrenceEvent(eventObj, isGuid = false, isFollowing = false) {
        const idField = isGuid ? 'Guid' : (isFollowing) ? this.parent.eventFields.followingID : this.parent.eventFields.recurrenceID;
        const fieldKey = isGuid ? 'Guid' : this.parent.eventFields.id;
        const dataSource = isGuid ? this.parent.eventsProcessed : this.parent.eventsData;
        return dataSource.filter((data) => data[`${idField}`] === eventObj[`${fieldKey}`]);
    }
    getOccurrencesByID(id) {
        const fields = this.parent.eventFields;
        let occurrenceCollection = [];
        const parentObject = this.parent.eventsData.filter((obj) => obj[fields.id] === id);
        for (const event of parentObject) {
            if (!isNullOrUndefined(event[fields.recurrenceRule])) {
                occurrenceCollection = occurrenceCollection.concat(this.generateOccurrence(event));
            }
        }
        return occurrenceCollection;
    }
    getOccurrencesByRange(startTime, endTime) {
        const fields = this.parent.eventFields;
        let occurrenceCollection = [];
        for (const event of this.parent.eventsData) {
            if (!isNullOrUndefined(event[fields.recurrenceRule])) {
                occurrenceCollection = occurrenceCollection.concat(this.generateOccurrence(event));
            }
        }
        const filter = occurrenceCollection.filter((obj) => obj[fields.startTime] >= startTime && obj[fields.endTime] <= endTime && !isNullOrUndefined(obj[fields.recurrenceID]));
        return filter;
    }
    getDeletedOccurrences(recurrenceData) {
        const fields = this.parent.eventFields;
        let parentObject;
        const deletedOccurrences = [];
        if (typeof recurrenceData === 'string' || typeof recurrenceData === 'number') {
            parentObject = this.parent.eventsData.filter((obj) => obj[fields.id] === recurrenceData)[0];
        }
        else {
            parentObject = extend({}, recurrenceData, null, true);
        }
        if (parentObject[fields.recurrenceException]) {
            const exDateString = parentObject[fields.recurrenceException].split(',');
            for (let i = 0, len = exDateString.length; i < len; i++) {
                const edited = this.parent.eventsData.filter((eventObj) => eventObj[fields.recurrenceID] === parentObject[fields.id] && eventObj[fields.recurrenceException] === exDateString[parseInt(i.toString(), 10)]);
                if (edited.length === 0) {
                    const exDate = getDateFromRecurrenceDateString(exDateString[parseInt(i.toString(), 10)]);
                    const childObject = extend({}, recurrenceData, null, true);
                    childObject[fields.recurrenceID] = parentObject[fields.id];
                    delete childObject[fields.followingID];
                    childObject[fields.recurrenceException] = exDateString[parseInt(i.toString(), 10)];
                    const startDate = new Date(exDate.getTime());
                    const time = parentObject[fields.endTime].getTime() - parentObject[fields.startTime].getTime();
                    const endDate = new Date(startDate.getTime());
                    endDate.setMilliseconds(time);
                    childObject[fields.startTime] = new Date(startDate.getTime());
                    childObject[fields.endTime] = new Date(endDate.getTime());
                    deletedOccurrences.push(childObject);
                }
            }
        }
        return deletedOccurrences;
    }
    applyResourceColor(element, data, type, index, alpha) {
        if (!this.parent.resourceBase) {
            return;
        }
        const alphaColor = (color, alpha) => {
            color = color.replace('#', '');
            const r = parseInt(color.substring(0, color.length / 3), 16);
            const g = parseInt(color.substring(color.length / 3, 2 * color.length / 3), 16);
            const b = parseInt(color.substring(2 * color.length / 3, 3 * color.length / 3), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        };
        // index refers groupOrder
        const color = this.parent.resourceBase.getResourceColor(data, index);
        if (color) {
            element.style[type] = !isNullOrUndefined(alpha) ? alphaColor(color, alpha) : color;
        }
    }
    createBlockAppointmentElement(record, resIndex, isResourceEventTemplate) {
        const eventSubject = (record[this.parent.eventFields.subject] || this.parent.eventSettings.fields.subject.default);
        const appointmentWrapper = createElement('div', {
            className: BLOCK_APPOINTMENT_CLASS,
            attrs: {
                'data-id': 'Appointment_' + record[this.parent.eventFields.id],
                'aria-disabled': 'true'
            }
        });
        let templateElement;
        if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {
            const scheduleId = this.parent.element.id + '_';
            const viewName = this.parent.activeViewOptions.eventTemplateName;
            const templateId = scheduleId + viewName + 'eventTemplate';
            const templateName = 'eventTemplate' + (isResourceEventTemplate &&
                this.parent.currentView.indexOf('Year') === -1 ? '_' + resIndex : '');
            templateElement = this.parent.getAppointmentTemplate()(record, this.parent, templateName, templateId, false);
        }
        else {
            const appointmentSubject = createElement('div', { className: SUBJECT_CLASS });
            this.parent.sanitize(eventSubject, appointmentSubject);
            templateElement = [appointmentSubject];
        }
        append(templateElement, appointmentWrapper);
        this.setWrapperAttributes(appointmentWrapper, resIndex);
        return appointmentWrapper;
    }
    setWrapperAttributes(appointmentWrapper, resIndex) {
        if (!isNullOrUndefined(this.cssClass)) {
            addClass([appointmentWrapper], this.cssClass);
        }
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            appointmentWrapper.setAttribute('data-group-index', resIndex.toString());
        }
    }
    getReadonlyAttribute(event) {
        return (event[this.parent.eventFields.isReadonly] || this.parent.readonly).toString();
    }
    isBlockRange(eventData) {
        const eventCollection = (eventData instanceof Array) ? eventData : [eventData];
        let isBlockAlert = false;
        const fields = this.parent.eventFields;
        for (const event of eventCollection) {
            let dataCol = [];
            if (!isNullOrUndefined(event[fields.recurrenceRule]) &&
                (isNullOrUndefined(event[fields.recurrenceID]) || event[fields.id] === event[fields.recurrenceID])) {
                dataCol = this.generateOccurrence(event);
            }
            else {
                dataCol.push(event);
            }
            for (const data of dataCol) {
                const filterBlockEvents = this.filterBlockEvents(data);
                if (filterBlockEvents.length > 0) {
                    isBlockAlert = true;
                    break;
                }
            }
        }
        this.parent.uiStateValues.isBlock = isBlockAlert;
        return isBlockAlert;
    }
    getFilterEventsList(dataSource, query) {
        return new DataManager(dataSource).executeLocal(new Query().where(query));
    }
    getSeriesEvents(parentEvent, startTime) {
        const fields = this.parent.eventFields;
        startTime = isNullOrUndefined(startTime) ? parentEvent[fields.startTime] : startTime;
        let deleteFutureEditEvents;
        let futureEvents;
        const deleteFutureEditEventList = [];
        let delId = parentEvent[fields.id];
        let followingId = parentEvent[fields.followingID];
        let deleteFutureEvent;
        const startTimeQuery = this.parent.currentAction === 'EditSeries' ? 'greaterthan' : 'greaterthanorequal';
        do {
            deleteFutureEvent = ((new Predicate(fields.followingID, 'equal', delId))).
                and(new Predicate(fields.startTime, startTimeQuery, startTime));
            futureEvents = this.getFilterEventsList(this.parent.eventsData, deleteFutureEvent);
            deleteFutureEditEvents = futureEvents.slice(-1)[0];
            if (!isNullOrUndefined(deleteFutureEditEvents) && deleteFutureEditEvents[fields.id] !== followingId) {
                deleteFutureEditEventList.push(deleteFutureEditEvents);
                delId = deleteFutureEditEvents[fields.id];
                followingId = deleteFutureEditEvents[fields.followingID];
            }
            else {
                followingId = null;
            }
        } while (futureEvents.length === 1 && !isNullOrUndefined(deleteFutureEditEvents[fields.followingID]));
        return deleteFutureEditEventList;
    }
    getEditedOccurrences(deleteFutureEditEventList, startTime) {
        const fields = this.parent.eventFields;
        let deleteRecurrenceEventList = [];
        let delEditedEvents;
        for (const event of deleteFutureEditEventList) {
            let delEventQuery = new Predicate(fields.recurrenceID, 'equal', event[fields.id]).
                or(new Predicate(fields.recurrenceID, 'equal', event[fields.followingID]).
                and(new Predicate(fields.recurrenceID, 'notequal', undefined)).
                and(new Predicate(fields.recurrenceID, 'notequal', null)));
            if (this.parent.currentAction === 'EditFollowingEvents' || this.parent.currentAction === 'DeleteFollowingEvents') {
                delEventQuery = delEventQuery.and(new Predicate(fields.startTime, 'greaterthanorequal', startTime));
            }
            delEditedEvents = this.getFilterEventsList(this.parent.eventsData, delEventQuery);
            deleteRecurrenceEventList = deleteRecurrenceEventList.concat(delEditedEvents);
        }
        return deleteRecurrenceEventList;
    }
    getRenderedDates(dateRender) {
        let firstDate = 0;
        let lastDate = dateRender.length;
        let filteredDates;
        if (dateRender[0] < this.parent.minDate && dateRender[dateRender.length - 1] > this.parent.maxDate) {
            for (let i = 0; i < dateRender.length; i++) {
                if (resetTime(dateRender[parseInt(i.toString(), 10)]).getTime() === resetTime(new Date(this.parent.minDate)).getTime()) {
                    firstDate = i;
                }
                if (resetTime(dateRender[parseInt(i.toString(), 10)]).getTime() === resetTime(new Date(this.parent.maxDate)).getTime()) {
                    lastDate = i;
                }
            }
            filteredDates = dateRender.filter((date) => date >= dateRender[parseInt(firstDate.toString(), 10)] && date <= dateRender[parseInt(lastDate.toString(), 10)]);
        }
        return filteredDates;
    }
    isValidEvent(eventObj, start, end, schedule) {
        const isHourRange = end.getTime() > schedule.startHour.getTime() && start.getTime() < schedule.endHour.getTime();
        const isSameRange = schedule.startHour.getTime() <= start.getTime() &&
            eventObj[this.parent.eventFields.startTime].getTime() >= schedule.startHour.getTime() &&
            eventObj[this.parent.eventFields.endTime].getTime() < schedule.endHour.getTime() && start.getTime() === end.getTime();
        return isHourRange || isSameRange;
    }
    allDayExpandScroll(dateHeader) {
        let indentHeight = 0;
        const headerRows = [].slice.call(this.parent.element.querySelectorAll('.' + HEADER_ROW_CLASS));
        headerRows.forEach((element) => {
            const tdEle = [].slice.call(element.children);
            tdEle.forEach((ele) => { ele.style.top = indentHeight + 'px'; });
            indentHeight += element.offsetHeight;
        });
        indentHeight = dateHeader.offsetHeight - indentHeight;
        this.parent.element.querySelector('.' + ALLDAY_CELLS_CLASS).style.height = (indentHeight / 12) + 'em';
        if (this.parent.uiStateValues.expand) {
            addClass([dateHeader], ALLDAY_APPOINTMENT_SCROLL);
        }
        else {
            removeClass([dateHeader], ALLDAY_APPOINTMENT_SCROLL);
        }
    }
    updateEventMinimumDuration(startEndHours, startTime, endTime) {
        if (startTime.getTime() < endTime.getTime()) {
            const eventDuration = (getUniversalTime(endTime) - getUniversalTime(startTime)) / MS_PER_MINUTE;
            if (eventDuration < this.parent.eventSettings.minimumEventDuration) {
                const tempEnd = new Date(startTime);
                tempEnd.setMinutes(tempEnd.getMinutes() + this.parent.eventSettings.minimumEventDuration);
                endTime = tempEnd;
                if (endTime.getTime() > startEndHours.endHour.getTime()) {
                    const tempStart = new Date(startEndHours.endHour.getTime());
                    tempStart.setMinutes(tempStart.getMinutes() - this.parent.eventSettings.minimumEventDuration);
                    startTime = tempStart;
                    endTime = startEndHours.endHour;
                }
            }
        }
        return { startDate: startTime, endDate: endTime };
    }
    createEventWrapper(type = '', index = 0) {
        const tr = createElement('tr');
        const levels = this.parent.activeView.colLevels.slice(-1)[0];
        for (let i = 0, len = levels.length; i < len; i++) {
            const col = levels[parseInt(i.toString(), 10)];
            const appointmentWrap = createElement('td', {
                className: (type === 'allDay') ? ALLDAY_APPOINTMENT_WRAPPER_CLASS : (type === 'timeIndicator') ?
                    TIMELINE_WRAPPER_CLASS : DAY_WRAPPER_CLASS, attrs: { 'data-date': col.date.getTime().toString() }
            });
            if (!isNullOrUndefined(col.groupIndex)) {
                appointmentWrap.setAttribute('data-group-index', col.groupIndex.toString());
            }
            if (type === '') {
                const innerWrapper = createElement('div', {
                    id: APPOINTMENT_WRAPPER_CLASS + '-' + index.toString(),
                    className: APPOINTMENT_WRAPPER_CLASS
                });
                appointmentWrap.appendChild(innerWrapper);
            }
            tr.appendChild(appointmentWrap);
            index = index + 1;
        }
        return tr;
    }
    getPageCoordinates(e) {
        if (isNullOrUndefined(e)) {
            return e;
        }
        const eventArgs = e.event;
        return eventArgs && eventArgs.changedTouches ? eventArgs.changedTouches[0] : e.changedTouches ? e.changedTouches[0] :
            eventArgs || e;
    }
    renderSpannedIcon(element, spanEvent) {
        const iconElement = createElement('div', { className: EVENT_INDICATOR_CLASS + ' ' + ICON });
        if (spanEvent.isLeft) {
            const iconLeft = iconElement.cloneNode();
            addClass([iconLeft], EVENT_ICON_LEFT_CLASS);
            prepend([iconLeft], element);
        }
        if (spanEvent.isRight) {
            const iconRight = iconElement.cloneNode();
            addClass([iconRight], EVENT_ICON_RIGHT_CLASS);
            append([iconRight], element);
        }
        if (spanEvent.isTop) {
            const iconTop = iconElement.cloneNode();
            addClass([iconTop], EVENT_ICON_UP_CLASS);
            prepend([iconTop], element);
        }
        if (spanEvent.isBottom) {
            const iconBottom = iconElement.cloneNode();
            addClass([iconBottom], EVENT_ICON_DOWN_CLASS);
            append([iconBottom], element);
        }
    }
    unWireEvents() {
        const appElements = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));
        for (const element of appElements) {
            EventHandler.clearEvents(element);
        }
    }
    destroy() {
        this.unWireEvents();
        this.parent = null;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Vertical view appointment rendering
 */
class VerticalEvent extends EventBase {
    constructor(parent) {
        super(parent);
        this.dateRender = [];
        this.renderedEvents = [];
        this.renderedAllDayEvents = [];
        this.overlapEvents = [];
        this.moreEvents = [];
        this.overlapList = [];
        this.allDayEvents = [];
        this.slotCount = this.parent.activeViewOptions.timeScale.slotCount;
        this.interval = this.parent.activeViewOptions.timeScale.interval;
        this.allDayLevel = 0;
        this.startHour = this.parent.activeView.getStartHour();
        this.endHour = this.parent.activeView.getEndHour();
        this.element = this.parent.activeView.getPanel();
        this.fields = this.parent.eventFields;
        this.animation = new Animation({ progress: this.animationUiUpdate.bind(this) });
        this.addEventListener();
    }
    renderAppointments() {
        if (isNullOrUndefined(this.parent)) {
            return;
        }
        if (this.parent.dragAndDropModule) {
            this.parent.dragAndDropModule.setDragArea();
        }
        this.isResourceEventTemplate = this.parent.isSpecificResourceEvents();
        const wrapperElements = [].slice.call(this.parent.element.querySelectorAll('.' + BLOCK_APPOINTMENT_CLASS +
            ',.' + APPOINTMENT_CLASS + ',.' + ROW_COUNT_WRAPPER_CLASS));
        const isDragging = (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction) ? true : false;
        for (const wrapper of wrapperElements) {
            if (isDragging && !(wrapper.classList.contains(ALLDAY_APPOINTMENT_CLASS) ||
                wrapper.classList.contains(ROW_COUNT_WRAPPER_CLASS))) {
                const groupIndex = parseInt(wrapper.getAttribute('data-group-index'), 10);
                for (let j = 0, len = this.parent.crudModule.crudObj.sourceEvent.length; j < len; j++) {
                    if (groupIndex === this.parent.crudModule.crudObj.sourceEvent[parseInt(j.toString(), 10)].groupIndex ||
                        groupIndex === this.parent.crudModule.crudObj.targetEvent[parseInt(j.toString(), 10)].groupIndex) {
                        remove(wrapper);
                    }
                }
            }
            else {
                remove(wrapper);
            }
        }
        if (!this.element.querySelector('.' + WORK_CELLS_CLASS)) {
            return;
        }
        if (this.parent.virtualScrollModule) {
            this.parent.virtualScrollModule.updateFocusedWorkCell();
        }
        this.allDayElement = [].slice.call(this.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS));
        this.setAllDayRowHeight(0);
        if (this.parent.eventsProcessed.length === 0 && this.parent.blockProcessed.length === 0) {
            return;
        }
        const expandCollapse = this.element.querySelector('.' + ALLDAY_APPOINTMENT_SECTION_CLASS);
        EventHandler.remove(expandCollapse, 'click', this.rowExpandCollapse);
        EventHandler.add(expandCollapse, 'click', this.rowExpandCollapse, this);
        this.renderedEvents = [];
        this.renderedAllDayEvents = [];
        this.initializeValues();
        this.processBlockEvents();
        this.renderEvents('normalEvents');
        if (this.allDayEvents.length > 0) {
            this.allDayEvents = this.allDayEvents.filter((item, index, arr) => index === arr.map((item) => item.Guid).indexOf(item.Guid));
            removeClass(this.allDayElement, ALLDAY_ROW_ANIMATE_CLASS);
            this.slots.push(this.parent.activeView.renderDates.map((date) => +date));
            this.renderEvents('allDayEvents');
        }
        this.parent.notify(contentReady, {});
        addClass(this.allDayElement, ALLDAY_ROW_ANIMATE_CLASS);
        if (isDragging) {
            this.parent.crudModule.crudObj.isCrudAction = false;
        }
        this.parent.renderTemplates();
    }
    initializeValues() {
        this.resources = (this.parent.activeViewOptions.group.resources.length > 0) ? this.parent.uiStateValues.isGroupAdaptive ?
            [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] :
            this.parent.resourceBase.lastResourceLevel : [];
        if (this.resources.length > 0 && this.parent.activeViewOptions.allowVirtualScrolling && this.parent.virtualScrollModule) {
            this.resources = this.parent.resourceBase.renderedResources;
        }
        this.cellHeight =
            parseFloat(this.parent.element.querySelector('.e-content-wrap tbody tr').getBoundingClientRect().height.toFixed(2));
        this.dateRender[0] = this.parent.activeView.renderDates;
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            for (let i = 0, len = this.resources.length; i < len; i++) {
                this.dateRender[parseInt(i.toString(), 10)] = this.resources[parseInt(i.toString(), 10)].renderDates;
            }
        }
    }
    getHeight(start, end) {
        let appHeight = (getUniversalTime(end) - getUniversalTime(start)) /
            MS_PER_MINUTE * (this.cellHeight * this.slotCount) / this.interval;
        appHeight = (appHeight <= 0) ? this.cellHeight : appHeight;
        return appHeight;
    }
    appendEvent(eventObj, appointmentElement, index, appLeft) {
        const appointmentWrap = this.element.querySelector('.' + APPOINTMENT_WRAPPER_CLASS + '[id="' + APPOINTMENT_WRAPPER_CLASS + '-' + index + '"]');
        if (this.parent.enableRtl) {
            setStyleAttribute(appointmentElement, { 'right': appLeft });
        }
        else {
            setStyleAttribute(appointmentElement, { 'left': appLeft });
        }
        const eventType = appointmentElement.classList.contains(BLOCK_APPOINTMENT_CLASS) ? 'blockEvent' : 'event';
        const args = {
            data: extend({}, eventObj, null, true),
            element: appointmentElement, cancel: false, type: eventType
        };
        this.parent.trigger(eventRendered, args, (eventArgs) => {
            if (!eventArgs.cancel) {
                appointmentWrap.appendChild(appointmentElement);
            }
        });
    }
    processBlockEvents() {
        const resources = this.getResourceList();
        let dateCount = this.getStartCount();
        for (const resource of resources) {
            const renderDates = this.dateRender[parseInt(resource.toString(), 10)];
            for (let day = 0, length = renderDates.length; day < length; day++) {
                const startDate = new Date(renderDates[parseInt(day.toString(), 10)].getTime());
                const endDate = addDays(renderDates[parseInt(day.toString(), 10)], 1);
                const filterEvents = this.filterEvents(startDate, endDate, this.parent.blockProcessed, this.resources[parseInt(resource.toString(), 10)]);
                for (const event of filterEvents) {
                    if (this.parent.resourceBase) {
                        this.setValues(event, resource);
                    }
                    this.renderBlockEvents(event, day, resource, dateCount);
                    this.cssClass = null;
                    this.groupOrder = null;
                }
                dateCount += 1;
            }
        }
    }
    renderBlockEvents(eventObj, dayIndex, resource, dayCount) {
        const spannedData = this.isSpannedEvent(eventObj, dayIndex, resource);
        const eStart = spannedData[this.fields.startTime];
        const eEnd = spannedData[this.fields.endTime];
        const currentDate = resetTime(new Date(this.dateRender[parseInt(resource.toString(), 10)][parseInt(dayIndex.toString(), 10)].getTime()));
        const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);
        if (eStart <= eEnd && this.isValidEvent(eventObj, eStart, eEnd, schedule) && this.isWorkDayAvailable(resource, eStart)) {
            let blockTop;
            let blockHeight;
            if (spannedData[this.fields.isAllDay]) {
                const contentWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' table');
                blockHeight = formatUnit(contentWrap.offsetHeight);
                blockTop = formatUnit(0);
            }
            else {
                blockHeight = formatUnit(this.getHeight(eStart, eEnd));
                blockTop = formatUnit(this.getTopValue(eStart, dayIndex, resource));
            }
            const appointmentElement = this.createBlockAppointmentElement(eventObj, resource, this.isResourceEventTemplate);
            setStyleAttribute(appointmentElement, { 'width': '100%', 'height': blockHeight, 'top': blockTop });
            const index = this.getDayIndex(dayIndex, resource, dayCount);
            this.appendEvent(eventObj, appointmentElement, index, '0px');
        }
    }
    renderEvents(eventType) {
        removeClass(this.allDayElement, ALLDAY_ROW_ANIMATE_CLASS);
        const eventCollection = (eventType === 'allDayEvents') ? this.sortByDateTime(this.allDayEvents) : undefined;
        const resources = this.getResourceList();
        let dateCount = this.getStartCount();
        let isRender;
        for (const resource of resources) {
            isRender = true;
            if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction && eventType !== 'allDayEvents'
                && !this.parent.uiStateValues.isGroupAdaptive) {
                if (this.parent.crudModule.crudObj.sourceEvent.filter((data) => data.groupIndex === resource).length === 0 &&
                    this.parent.crudModule.crudObj.targetEvent.filter((data) => data.groupIndex === resource).length === 0) {
                    isRender = false;
                }
            }
            this.slots = [];
            const renderDates = this.dateRender[parseInt(resource.toString(), 10)];
            const renderedDate = this.getRenderedDates(renderDates) || renderDates;
            this.slots.push(renderDates.map((date) => { return +date; }));
            for (let day = 0, length = renderDates.length; day < length &&
                renderDates[parseInt(day.toString(), 10)] <= renderedDate[renderedDate.length - 1]; day++) {
                this.renderedEvents = [];
                const startDate = new Date(renderDates[parseInt(day.toString(), 10)].getTime());
                const endDate = addDays(renderDates[parseInt(day.toString(), 10)], 1);
                const filterEvents = this.filterEvents(startDate, endDate, eventCollection, this.resources[parseInt(resource.toString(), 10)]);
                if (isRender) {
                    for (const event of filterEvents) {
                        if (this.parent.resourceBase) {
                            this.setValues(event, resource);
                        }
                        if (eventType === 'allDayEvents') {
                            this.renderAllDayEvents(event, day, resource, dateCount);
                        }
                        else {
                            if (this.isAllDayAppointment(event)) {
                                this.allDayEvents.push(extend({}, event, null, true));
                            }
                            else {
                                if (this.parent.eventSettings.enableMaxHeight) {
                                    if (this.getOverlapIndex(event, day, false, resource) > 0) {
                                        continue;
                                    }
                                }
                                this.renderNormalEvents(event, day, resource, dateCount);
                            }
                        }
                        this.cssClass = null;
                        this.groupOrder = null;
                    }
                }
                else {
                    for (const event of filterEvents) {
                        if (this.isAllDayAppointment(event)) {
                            this.allDayEvents.push(extend({}, event, null, true));
                        }
                    }
                }
                dateCount += 1;
            }
        }
    }
    getStartCount() {
        return this.parent.virtualScrollModule && this.parent.activeViewOptions.allowVirtualScrolling && this.parent.timeScale.enable ?
            parseInt(this.element.querySelector('.' + APPOINTMENT_WRAPPER_CLASS).getAttribute('id').split('-').slice(-1)[0], 10) : 0;
    }
    getDayIndex(dayIndex, resource, dayCount) {
        if (!this.parent.activeViewOptions.group.byDate) {
            return dayCount;
        }
        if (this.parent.activeViewOptions.group.byDate && !this.parent.activeViewOptions.group.hideNonWorkingDays) {
            const renderedIndex = this.parent.resourceBase.lastResourceLevel[0].renderDates.indexOf(this.dateRender[parseInt(resource.toString(), 10)][parseInt(dayIndex.toString(), 10)]);
            return (this.resources.length * renderedIndex) + resource;
        }
        let dateIndex = 0;
        const firstColumn = this.parent.activeView.colLevels[0];
        const currentDate = this.dateRender[parseInt(resource.toString(), 10)][parseInt(dayIndex.toString(), 10)].getTime();
        let currentResources = [];
        for (let i = 0; i < firstColumn.length; i++) {
            currentResources = this.parent.resourceBase.resourceDateTree[parseInt(i.toString(), 10)];
            if (currentDate === firstColumn[parseInt(i.toString(), 10)].date.getTime()) {
                break;
            }
            dateIndex = dateIndex + firstColumn[parseInt(i.toString(), 10)].colSpan;
        }
        const resIndex = currentResources.findIndex((x) => x.groupOrder.toString() ===
            this.resources[parseInt(resource.toString(), 10)].groupOrder.toString());
        if (resIndex < 0) {
            return dateIndex;
        }
        return dateIndex + resIndex;
    }
    setValues(event, resourceIndex) {
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            this.cssClass = this.resources[parseInt(resourceIndex.toString(), 10)].cssClass;
            this.groupOrder = this.resources[parseInt(resourceIndex.toString(), 10)].groupOrder;
        }
        else {
            this.cssClass = this.parent.resourceBase.getCssClass(event);
        }
    }
    getResourceList() {
        // eslint-disable-next-line prefer-spread
        const resources = Array.apply(null, {
            length: (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) ?
                this.resources.length : 1
        }).map((value, index) => { return index; });
        return resources;
    }
    // eslint-disable-next-line max-len
    createAppointmentElement(record, isAllDay, data, resource) {
        const fieldMapping = this.parent.eventFields;
        const recordSubject = (record[fieldMapping.subject] || this.parent.eventSettings.fields.subject.default
            || this.parent.localeObj.getConstant('addTitle'));
        const appointmentWrapper = createElement('div', {
            className: APPOINTMENT_CLASS,
            attrs: {
                'data-id': 'Appointment_' + record[fieldMapping.id],
                'data-guid': record.Guid,
                'role': 'button',
                'tabindex': '0',
                'aria-disabled': this.parent.eventBase.getReadonlyAttribute(record),
                'aria-label': this.parent.getAnnouncementString(record)
            }
        });
        if (record[this.fields.isReadonly]) {
            addClass([appointmentWrapper], 'e-read-only');
        }
        const appointmentDetails = createElement('div', { className: APPOINTMENT_DETAILS });
        appointmentWrapper.appendChild(appointmentDetails);
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            const resourceIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex : resource;
            appointmentWrapper.setAttribute('data-group-index', resourceIndex.toString());
        }
        let templateElement;
        const eventData = data;
        if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {
            const elementId = this.parent.element.id + '_';
            const viewName = this.parent.activeViewOptions.eventTemplateName;
            const templateId = elementId + viewName + 'eventTemplate';
            const resIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex : resource;
            const templateName = 'eventTemplate' + (this.isResourceEventTemplate ? '_' + resIndex : '');
            templateElement = this.parent.getAppointmentTemplate()(record, this.parent, templateName, templateId, false);
        }
        else {
            const appointmentSubject = createElement('div', { className: SUBJECT_CLASS });
            this.parent.sanitize(recordSubject, appointmentSubject);
            if (isAllDay) {
                if (record[fieldMapping.isAllDay]) {
                    templateElement = [appointmentSubject];
                }
                else {
                    templateElement = [];
                    const appointmentStartTime = createElement('div', {
                        className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),
                        innerHTML: this.parent.getTimeString(record[fieldMapping.startTime])
                    });
                    const appointmentEndTime = createElement('div', {
                        className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),
                        innerHTML: this.parent.getTimeString(record[fieldMapping.endTime])
                    });
                    addClass([appointmentSubject], 'e-text-center');
                    if (!eventData.isLeft) {
                        templateElement.push(appointmentStartTime);
                    }
                    templateElement.push(appointmentSubject);
                    if (!eventData.isRight) {
                        templateElement.push(appointmentEndTime);
                    }
                }
            }
            else {
                const timeStr = this.parent.getTimeString(record[fieldMapping.startTime]) + ' - ' +
                    this.parent.getTimeString(record[fieldMapping.endTime]);
                const appointmentTime = createElement('div', {
                    className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),
                    innerHTML: timeStr
                });
                const appointmentLocation = createElement('div', { className: LOCATION_CLASS });
                this.parent.sanitize((record[fieldMapping.location] || this.parent.eventSettings.fields.location.default || ''), appointmentLocation);
                templateElement = [appointmentSubject, appointmentTime, appointmentLocation];
            }
        }
        append(templateElement, appointmentDetails);
        if (!this.parent.isAdaptive &&
            (!isNullOrUndefined(record[fieldMapping.recurrenceRule]) || !isNullOrUndefined(record[fieldMapping.recurrenceID]))) {
            const iconClass = (record[fieldMapping.id] === record[fieldMapping.recurrenceID]) ?
                EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;
            const recurrenceIcon = createElement('div', { className: ICON + ' ' + iconClass });
            if (isAllDay) {
                appointmentDetails.appendChild(recurrenceIcon);
            }
            else {
                appointmentWrapper.appendChild(recurrenceIcon);
            }
        }
        this.parent.eventBase.renderSpannedIcon(isAllDay ? appointmentDetails : appointmentWrapper, eventData);
        if (!isNullOrUndefined(this.cssClass)) {
            addClass([appointmentWrapper], this.cssClass);
        }
        this.applyResourceColor(appointmentWrapper, record, 'backgroundColor', this.groupOrder);
        this.renderResizeHandler(appointmentWrapper, eventData, record[this.fields.isReadonly]);
        return appointmentWrapper;
    }
    createMoreIndicator(allDayRow, count, currentDay) {
        const index = currentDay + count;
        const countWrapper = allDayRow[parseInt(index.toString(), 10)];
        if (countWrapper.childElementCount <= 0) {
            const innerCountWrap = createElement('div', {
                className: ROW_COUNT_WRAPPER_CLASS,
                id: ROW_COUNT_WRAPPER_CLASS + '-' + index.toString()
            });
            const moreIndicatorElement = createElement('div', {
                className: MORE_INDICATOR_CLASS,
                attrs: { 'tabindex': '0', 'data-index': index.toString(), 'data-count': '1' },
                innerHTML: '+1&nbsp;' + (this.parent.isAdaptive ? '' : this.parent.localeObj.getConstant('more'))
            });
            innerCountWrap.appendChild(moreIndicatorElement);
            countWrapper.appendChild(innerCountWrap);
            EventHandler.add(moreIndicatorElement, 'click', this.rowExpandCollapse, this);
        }
        else {
            const countCell = countWrapper.querySelector('.' + MORE_INDICATOR_CLASS);
            const moreCount = parseInt(countCell.getAttribute('data-count'), 10) + 1;
            countCell.setAttribute('data-count', moreCount.toString());
            countCell.innerHTML = '+' + this.parent.globalize.formatNumber(moreCount) + '&nbsp;' + (this.parent.isAdaptive ? '' : this.parent.localeObj.getConstant('more'));
        }
    }
    isSpannedEvent(record, day, resource) {
        let currentDate = resetTime(this.dateRender[parseInt(resource.toString(), 10)][parseInt(day.toString(), 10)]);
        const renderedDate = this.getRenderedDates(this.dateRender[parseInt(resource.toString(), 10)]) || [currentDate];
        const currentDay = renderedDate.filter((date) => date.getDay() === day);
        if (currentDay.length === 0) {
            currentDate = resetTime(renderedDate[0]);
        }
        const field = this.parent.eventFields;
        const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);
        const event = extend({}, record, null, true);
        event.isSpanned = { isBottom: false, isTop: false };
        if (record[field.startTime].getTime() < schedule.startHour.getTime()) {
            event[field.startTime] = schedule.startHour;
            event.isSpanned.isTop = true;
        }
        if (record[field.endTime].getTime() > schedule.endHour.getTime()) {
            event[field.endTime] = schedule.endHour;
            event.isSpanned.isBottom = true;
        }
        const eventDates = this.updateEventMinimumDuration(schedule, event[field.startTime], event[field.endTime]);
        event[field.startTime] = eventDates.startDate;
        event[field.endTime] = eventDates.endDate;
        return event;
    }
    isWorkDayAvailable(resource, start) {
        if (this.parent.activeViewOptions.group.hideNonWorkingDays && this.resources.length > 0) {
            const workDays = this.resources[parseInt(resource.toString(), 10)].
                resourceData[this.resources[parseInt(resource.toString(), 10)].resource.workDaysField] ||
                this.parent.activeViewOptions.workDays;
            return workDays && workDays.indexOf(start.getDay()) >= 0;
        }
        return true;
    }
    renderAllDayEvents(eventObj, dayIndex, resource, dayCount, inline) {
        let currentDates = this.getRenderedDates(this.dateRender[parseInt(resource.toString(), 10)]) ||
            this.dateRender[parseInt(resource.toString(), 10)];
        if (this.parent.activeViewOptions.group.byDate) {
            this.slots[0] = [this.dateRender[parseInt(resource.toString(), 10)][parseInt(dayIndex.toString(), 10)].getTime()];
            currentDates = [this.dateRender[parseInt(resource.toString(), 10)][parseInt(dayIndex.toString(), 10)]];
        }
        const record = this.splitEvent(eventObj, currentDates)[0];
        const allDayRowCell = this.element.querySelector('.' + ALLDAY_CELLS_CLASS + ':first-child');
        const cellTop = allDayRowCell.offsetTop;
        const eStart = new Date(record[this.parent.eventFields.startTime].getTime());
        const eEnd = new Date(record[this.parent.eventFields.endTime].getTime());
        let appWidth = 0;
        let topValue = 1;
        const isDateRange = currentDates[0].getTime() <= eStart.getTime() &&
            addDays(currentDates.slice(-1)[0], 1).getTime() >= eStart.getTime();
        if (eStart <= eEnd && isDateRange && this.isWorkDayAvailable(resource, eStart)) {
            let isAlreadyRendered = [];
            if (this.renderedAllDayEvents[parseInt(resource.toString(), 10)]) {
                isAlreadyRendered = this.renderedAllDayEvents[parseInt(resource.toString(), 10)].filter((event) => event.Guid === eventObj.Guid);
                if (this.parent.activeViewOptions.group.byDate) {
                    isAlreadyRendered = isAlreadyRendered.filter((event) => event[this.parent.eventFields.startTime] >= currentDates[parseInt(dayIndex.toString(), 10)] &&
                        event[this.parent.eventFields.endTime] <=
                            addDays(new Date(+currentDates[parseInt(dayIndex.toString(), 10)]), 1));
                }
            }
            if (isAlreadyRendered.length === 0) {
                const allDayDifference = record.data.count;
                const allDayIndex = this.getOverlapIndex(record, dayIndex, true, resource);
                record.Index = allDayIndex;
                this.allDayLevel = (this.allDayLevel < allDayIndex) ? allDayIndex : this.allDayLevel;
                const widthAdjustment = record.data.isRight ? 0 :
                    this.parent.currentView === 'Day' ? 4 : 7;
                if (allDayDifference >= 0) {
                    appWidth = (allDayDifference * 100) - widthAdjustment;
                }
                if (isNullOrUndefined(this.renderedAllDayEvents[parseInt(resource.toString(), 10)])) {
                    this.renderedAllDayEvents[parseInt(resource.toString(), 10)] = [];
                }
                this.renderedAllDayEvents[parseInt(resource.toString(), 10)].push(extend({}, record, null, true));
                const allDayRow = [].slice.call(this.element.querySelector('.' + ALLDAY_ROW_CLASS).children);
                const wIndex = this.getDayIndex(dayIndex, resource, dayCount);
                const eventWrapper = this.element.querySelector('.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS +
                    ':nth-child(' + (wIndex + 1) + ')');
                let appointmentElement;
                if (inline) {
                    appointmentElement = this.parent.inlineModule.createInlineAppointmentElement(eventObj);
                }
                else {
                    appointmentElement = this.createAppointmentElement(eventObj, true, record.data, resource);
                }
                addClass([appointmentElement], ALLDAY_APPOINTMENT_CLASS);
                const eventData = extend({}, record.data, null, true);
                eventObj.data = eventData;
                const args = { data: eventObj, element: appointmentElement, cancel: false };
                this.parent.trigger(eventRendered, args, (eventArgs) => {
                    if (!eventArgs.cancel) {
                        eventWrapper.appendChild(appointmentElement);
                        const appHeight = appointmentElement.offsetHeight;
                        topValue += (allDayIndex === 0 ? cellTop : (cellTop + (allDayIndex * appHeight))) + 1;
                        setStyleAttribute(appointmentElement, { 'width': appWidth + '%', 'top': formatUnit(topValue) });
                        if (allDayIndex > 1) {
                            this.moreEvents.push(appointmentElement);
                            for (let count = 0, length = allDayDifference; count < length; count++) {
                                this.createMoreIndicator(allDayRow, count, wIndex);
                            }
                        }
                        allDayRowCell.setAttribute('data-count', this.allDayLevel.toString());
                        const allDayRowHeight = ((!this.parent.uiStateValues.expand && this.allDayLevel > 2) ?
                            (3 * appHeight) : ((this.allDayLevel + 1) * appHeight)) + 4;
                        this.setAllDayRowHeight(allDayRowHeight);
                        this.addOrRemoveClass();
                        this.wireAppointmentEvents(appointmentElement, eventObj);
                    }
                });
            }
        }
    }
    renderNormalEvents(eventObj, dayIndex, resource, dayCount, inline) {
        const record = this.isSpannedEvent(eventObj, dayIndex, resource);
        const eStart = record[this.fields.startTime];
        const eEnd = record[this.fields.endTime];
        let appWidth = '0%';
        const appLeft = '0%';
        let topValue = 0;
        const currentDate = resetTime(new Date(this.dateRender[parseInt(resource.toString(), 10)][parseInt(dayIndex.toString(), 10)].getTime()));
        const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);
        const isValidEvent = this.isValidEvent(eventObj, eStart, eEnd, schedule);
        if ((eStart.getTime() < this.parent.minDate.getTime()) || (eEnd.getTime() > this.parent.maxDate.getTime())) {
            return;
        }
        if (eStart <= eEnd && isValidEvent && this.isWorkDayAvailable(resource, eStart)) {
            const appHeight = this.getHeight(eStart, eEnd);
            if (eStart.getTime() > schedule.startHour.getTime()) {
                topValue = this.getTopValue(eStart, dayIndex, resource);
            }
            const appIndex = this.getOverlapIndex(record, dayIndex, false, resource);
            record.Index = appIndex;
            this.overlapList.push(record);
            if (this.overlapList.length > 1) {
                if (isNullOrUndefined(this.overlapEvents[parseInt(appIndex.toString(), 10)])) {
                    this.overlapEvents[parseInt(appIndex.toString(), 10)] = [];
                }
                this.overlapEvents[parseInt(appIndex.toString(), 10)].push(record);
            }
            else {
                this.overlapEvents = [];
                this.overlapEvents.push([record]);
            }
            appWidth = this.getEventWidth();
            const argsData = {
                index: appIndex, left: appLeft, width: appWidth,
                day: dayCount, dayIndex: dayIndex, record: record, resource: resource
            };
            const tempData = this.adjustOverlapElements(argsData);
            appWidth = (tempData.appWidth);
            if (isNullOrUndefined(this.renderedEvents[parseInt(resource.toString(), 10)])) {
                this.renderedEvents[parseInt(resource.toString(), 10)] = [];
            }
            this.renderedEvents[parseInt(resource.toString(), 10)].push(extend({}, record, null, true));
            let appointmentElement;
            if (inline) {
                appointmentElement = this.parent.inlineModule.createInlineAppointmentElement(eventObj);
            }
            else {
                appointmentElement = this.createAppointmentElement(eventObj, false, record.isSpanned, resource);
            }
            setStyleAttribute(appointmentElement, {
                'width': (this.parent.eventSettings.enableMaxHeight ? '100%' : tempData.appWidth),
                'height': appHeight + 'px', 'top': topValue + 'px'
            });
            const iconHeight = appointmentElement.querySelectorAll('.' + EVENT_INDICATOR_CLASS).length * 15;
            const maxHeight = appHeight - 40 - iconHeight;
            const subjectElement = appointmentElement.querySelector('.' + SUBJECT_CLASS);
            if (!this.parent.isAdaptive && subjectElement) {
                subjectElement.style.maxHeight = formatUnit(maxHeight);
            }
            const index = this.getDayIndex(dayIndex, resource, dayCount);
            const eventData = {};
            eventData[this.fields.startTime] = eventObj[this.fields.startTime];
            eventData[this.fields.endTime] = eventObj[this.fields.endTime];
            record.data = eventData;
            this.appendEvent(record, appointmentElement, index, tempData.appLeft);
            this.wireAppointmentEvents(appointmentElement, eventObj);
        }
    }
    getEventWidth() {
        const width = this.parent.currentView === 'Day' ? 97 : 94;
        const tempWidth = ((width - this.overlapEvents.length) / this.overlapEvents.length);
        return (tempWidth < 0 ? 0 : tempWidth) + '%';
    }
    getEventLeft(appWidth, index) {
        const tempLeft = (parseFloat(appWidth) + 1) * index;
        return (tempLeft > 99 ? 99 : tempLeft) + '%';
    }
    getTopValue(date, day, resource) {
        const startEndHours = getStartEndHours(resetTime(this.dateRender[parseInt(resource.toString(), 10)][parseInt(day.toString(), 10)]), this.startHour, this.endHour);
        const startHour = startEndHours.startHour;
        const diffInMinutes = ((date.getHours() - startHour.getHours()) * 60) + (date.getMinutes() - startHour.getMinutes());
        return (this.parent.activeViewOptions.timeScale.enable) ? ((diffInMinutes * this.cellHeight * this.slotCount) / this.interval) : 0;
    }
    getOverlapIndex(record, day, isAllDay, resource) {
        const fieldMapping = this.parent.eventFields;
        let eventsList = [];
        let appIndex = -1;
        this.overlapEvents = [];
        if (isAllDay) {
            if (!isNullOrUndefined(this.renderedAllDayEvents[parseInt(resource.toString(), 10)])) {
                const date = resetTime(new Date(this.dateRender[parseInt(resource.toString(), 10)][parseInt(day.toString(), 10)].getTime()));
                eventsList = this.renderedAllDayEvents[parseInt(resource.toString(), 10)].filter((app) => resetTime(app[fieldMapping.startTime]).getTime() <= date.getTime() &&
                    resetTime(app[fieldMapping.endTime]).getTime() >= date.getTime());
                if (this.parent.activeViewOptions.group.resources.length > 0) {
                    eventsList = this.filterEventsByResource(this.resources[parseInt(resource.toString(), 10)], eventsList);
                }
            }
        }
        else {
            const appointmentList = !isNullOrUndefined(this.renderedEvents[parseInt(resource.toString(), 10)]) ?
                this.renderedEvents[parseInt(resource.toString(), 10)] : [];
            let appointment = [];
            const recordStart = record[fieldMapping.startTime];
            const recordEnd = record[fieldMapping.endTime];
            this.overlapList = appointmentList.filter((data) => (data[fieldMapping.endTime] > recordStart && data[fieldMapping.startTime] <= recordEnd) ||
                (data[fieldMapping.startTime] >= recordEnd && data[fieldMapping.endTime] <= recordStart) ||
                (data[fieldMapping.endTime].getTime() === data[fieldMapping.startTime].getTime() &&
                    data[fieldMapping.startTime].getTime() === recordStart.getTime() && data[fieldMapping.endTime] < recordEnd));
            if (this.parent.activeViewOptions.group.resources.length > 0) {
                this.overlapList = this.filterEventsByResource(this.resources[parseInt(resource.toString(), 10)], this.overlapList);
            }
            this.overlapList.forEach((obj) => {
                let filterList = appointmentList.filter((data) => data[fieldMapping.endTime] > obj[fieldMapping.startTime] && data[fieldMapping.startTime] <= obj[fieldMapping.endTime]);
                if (this.parent.activeViewOptions.group.resources.length > 0) {
                    filterList = this.filterEventsByResource(this.resources[parseInt(resource.toString(), 10)], filterList);
                }
                const collection = filterList.filter((val) => this.overlapList.indexOf(val) === -1);
                if (collection.length > 0) {
                    appointment = appointment.concat(collection);
                }
            });
            for (let i = 0; i < appointment.length - 1; i++) {
                for (let j = i + 1; j < appointment.length; j++) {
                    if (appointment[parseInt(i.toString(), 10)][fieldMapping.id] ===
                        appointment[parseInt(j.toString(), 10)][fieldMapping.id]) {
                        appointment.splice(j, 1);
                        j--;
                    }
                }
            }
            this.overlapList = this.overlapList.concat(appointment);
            eventsList = this.overlapList;
            for (const event of eventsList) {
                const record = event;
                const index = record.Index;
                if (isNullOrUndefined(this.overlapEvents[parseInt(index.toString(), 10)])) {
                    this.overlapEvents[parseInt(index.toString(), 10)] = [event];
                }
                else {
                    this.overlapEvents[parseInt(index.toString(), 10)].push(event);
                }
            }
        }
        if (!isAllDay) {
            eventsList = eventsList.filter((obj) => (obj[fieldMapping.startTime] === record[fieldMapping.startTime] &&
                obj[fieldMapping.endTime] > record[fieldMapping.endTime] || obj[fieldMapping.endTime] > record[fieldMapping.startTime] &&
                obj[fieldMapping.startTime] < record[fieldMapping.endTime] || obj[fieldMapping.endTime] === record[fieldMapping.startTime]
                && obj[fieldMapping.startTime] === record[fieldMapping.endTime]) ||
                ((obj[fieldMapping.startTime].getTime() === record[fieldMapping.startTime].getTime() &&
                    obj[fieldMapping.endTime].getTime() === record[fieldMapping.endTime].getTime())
                    || (obj[fieldMapping.startTime].getTime() === record[fieldMapping.startTime].getTime() &&
                        obj[fieldMapping.endTime].getTime() < record[fieldMapping.endTime].getTime() ||
                        obj[fieldMapping.endTime].getTime() > record[fieldMapping.endTime].getTime())));
        }
        if (eventsList.length > 0) {
            const appLevel = eventsList.map((obj) => obj.Index);
            appIndex = (appLevel.length > 0) ? this.getSmallestMissingNumber(appLevel) : 0;
        }
        return (appIndex === -1) ? 0 : appIndex;
    }
    adjustOverlapElements(args) {
        const data = { appWidth: args.width, appLeft: args.left };
        for (let i = 0, length1 = this.overlapEvents.length; i < length1; i++) {
            if (!isNullOrUndefined(this.overlapEvents[parseInt(i.toString(), 10)])) {
                for (let j = 0, length2 = this.overlapEvents[parseInt(i.toString(), 10)].length; j < length2; j++) {
                    const dayCount = this.getDayIndex(args.dayIndex, args.resource, args.day);
                    const element = this.element.querySelector('#e-appointment-wrapper-' + dayCount);
                    if (element && element.childElementCount > 0) {
                        const eleGuid = this.overlapEvents[parseInt(i.toString(), 10)][parseInt(j.toString(), 10)].Guid;
                        if (element.querySelectorAll('div[data-guid="' + eleGuid + '"]').length > 0 && eleGuid !== args.record.Guid) {
                            const apps = element.querySelector('div[data-guid="' + eleGuid + '"]');
                            if (parseFloat(args.width) <= parseFloat(apps.style.width)) {
                                if (this.parent.enableRtl) {
                                    apps.style.right = this.getEventLeft(args.width, i);
                                }
                                else {
                                    apps.style.left = this.getEventLeft(args.width, i);
                                }
                                apps.style.width = ((parseFloat(args.width))) + '%';
                                data.appWidth = apps.style.width;
                            }
                            else {
                                data.appWidth = apps.style.width;
                            }
                        }
                        else {
                            let appWidth = args.width;
                            if (isNullOrUndefined(this.overlapEvents[i - 1])) {
                                appWidth = this.getEventWidth();
                            }
                            data.appWidth = appWidth;
                            data.appLeft = this.getEventLeft(appWidth, args.index);
                        }
                    }
                }
            }
        }
        return data;
    }
    setAllDayRowHeight(height) {
        const dateHeader = this.parent.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);
        if (this.parent.height === 'auto' || !this.parent.enableAllDayScroll) {
            addClass([dateHeader], ALLDAY_APPOINTMENT_AUTO);
        }
        const allDayRow = this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS);
        allDayRow.style.height = '';
        if (this.parent.uiStateValues.expand && this.parent.height !== 'auto' && this.parent.enableAllDayScroll) {
            allDayRow.style.height = (height / 12) + 'em';
            this.parent.eventBase.allDayExpandScroll(dateHeader);
        }
        else {
            dateHeader.scrollTop = 0;
            for (const element of this.allDayElement) {
                element.style.height = (height / 12) + 'em';
            }
            removeClass([dateHeader], ALLDAY_APPOINTMENT_SCROLL);
        }
        this.animation.animate(this.allDayElement[0]);
    }
    addOrRemoveClass() {
        this.moreEvents.filter((element) => {
            if (!this.parent.uiStateValues.expand && this.allDayLevel > 2) {
                addClass([element], EVENT_COUNT_CLASS);
                element.setAttribute('tabindex', '-1');
            }
            else {
                removeClass([element], EVENT_COUNT_CLASS);
                element.setAttribute('tabindex', '0');
            }
        });
        const moreEventCount = this.element.querySelector('.' + ALLDAY_APPOINTMENT_SECTION_CLASS);
        if (this.parent.uiStateValues.expand) {
            removeClass([moreEventCount], APPOINTMENT_ROW_EXPAND_CLASS);
            addClass([moreEventCount], APPOINTMENT_ROW_COLLAPSE_CLASS);
        }
        else {
            removeClass([moreEventCount], APPOINTMENT_ROW_COLLAPSE_CLASS);
            addClass([moreEventCount], APPOINTMENT_ROW_EXPAND_CLASS);
        }
        if (this.allDayLevel > 2) {
            removeClass([moreEventCount], DISABLE_CLASS);
        }
        else {
            addClass([moreEventCount], DISABLE_CLASS);
        }
        const countCell = [].slice.call(this.element.querySelectorAll('.' + ROW_COUNT_WRAPPER_CLASS));
        countCell.forEach((element) => {
            if (!this.parent.uiStateValues.expand && this.allDayLevel > 2) {
                removeClass([element], DISABLE_CLASS);
            }
            else {
                addClass([element], DISABLE_CLASS);
            }
        });
    }
    getEventHeight() {
        const eventElement = createElement('div', { className: APPOINTMENT_CLASS, styles: 'visibility:hidden' });
        const eventWrapper = this.element.querySelector('.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS + ':first-child');
        eventWrapper.appendChild(eventElement);
        const height = eventElement.offsetHeight;
        remove(eventElement);
        return height;
    }
    rowExpandCollapse() {
        const target = this.element.querySelector('.' + ALLDAY_APPOINTMENT_SECTION_CLASS);
        this.parent.uiStateValues.expand = target.classList.contains(APPOINTMENT_ROW_EXPAND_CLASS);
        let rowHeight;
        if (this.parent.uiStateValues.expand) {
            target.setAttribute('title', this.parent.localeObj.getConstant('collapseAllDaySection'));
            target.setAttribute('aria-label', 'Collapse section');
            rowHeight = ((this.allDayLevel + 1) * this.getEventHeight()) + 4;
        }
        else {
            target.setAttribute('title', this.parent.localeObj.getConstant('expandAllDaySection'));
            target.setAttribute('aria-label', 'Expand section');
            rowHeight = (3 * this.getEventHeight()) + 4;
        }
        this.setAllDayRowHeight(rowHeight);
        this.addOrRemoveClass();
        this.animation.animate(target);
    }
    animationUiUpdate() {
        this.parent.notify(contentReady, {});
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.removeEventListener();
        this.allDayElement = null;
        this.renderedAllDayEvents = null;
        this.renderedEvents = null;
        this.slotCount = null;
        this.interval = null;
        this.startHour = null;
        this.endHour = null;
        this.element = null;
        this.fields = null;
        this.animation = null;
        super.destroy();
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
const EVENT_GAP = 0;
/**
 * Month view events render
 */
class MonthEvent extends EventBase {
    constructor(parent) {
        super(parent);
        this.renderedEvents = [];
        this.monthHeaderHeight = 0;
        this.moreIndicatorHeight = 19;
        this.renderType = 'day';
        this.element = this.parent.activeView.getPanel();
        this.fields = this.parent.eventFields;
        this.maxHeight = this.parent.eventSettings.enableMaxHeight && !this.parent.eventSettings.enableIndicator
            && !this.parent.rowAutoHeight;
        this.withIndicator = this.parent.eventSettings.enableMaxHeight && this.parent.eventSettings.enableIndicator
            && !this.parent.rowAutoHeight;
        this.maxOrIndicator = (this.maxHeight || this.withIndicator);
        this.moreIndicatorHeight =
            (this.parent.rowAutoHeight && this.parent.eventSettings.ignoreWhitespace) ? 0 : this.moreIndicatorHeight;
        this.addEventListener();
    }
    removeEventWrapper(appElement) {
        if (appElement.length > 0) {
            appElement = (this.parent.currentView === 'Month' || (!this.parent.activeView.isTimelineView() &&
                !this.parent.activeViewOptions.timeScale.enable)) ? appElement : [appElement[0]];
            for (const wrap of appElement) {
                if (wrap.parentElement && wrap.parentElement.parentNode) {
                    remove(wrap.parentElement);
                }
            }
        }
    }
    renderAppointments() {
        if (this.parent.dragAndDropModule) {
            this.parent.dragAndDropModule.setDragArea();
        }
        this.isResourceEventTemplate = this.parent.isSpecificResourceEvents();
        const conWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        if (this.parent.rowAutoHeight) {
            this.parent.uiStateValues.top = conWrap.scrollTop;
            this.parent.uiStateValues.left = conWrap.scrollLeft;
        }
        const appointmentWrapper = [].slice.call(this.element.querySelectorAll('.' + APPOINTMENT_WRAPPER_CLASS));
        if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction) {
            for (let i = 0, len = this.parent.crudModule.crudObj.sourceEvent.length; i < len; i++) {
                const appElement = [].slice.call(this.element.querySelectorAll('.e-appointment-wrapper ' + '[data-group-index="' +
                    this.parent.crudModule.crudObj.sourceEvent[parseInt(i.toString(), 10)].groupIndex + '"]'));
                this.removeEventWrapper(appElement);
                if (this.parent.crudModule.crudObj.targetEvent[parseInt(i.toString(), 10)] &&
                    this.parent.crudModule.crudObj.sourceEvent[parseInt(i.toString(), 10)].groupIndex !==
                        this.parent.crudModule.crudObj.targetEvent[parseInt(i.toString(), 10)].groupIndex) {
                    const ele = [].slice.call(this.element.querySelectorAll('.e-appointment-wrapper ' + '[data-group-index="' +
                        this.parent.crudModule.crudObj.targetEvent[parseInt(i.toString(), 10)].groupIndex + '"]'));
                    this.removeEventWrapper(ele);
                }
            }
        }
        else {
            for (const wrap of appointmentWrapper) {
                remove(wrap);
            }
        }
        this.removeHeightProperty(CONTENT_TABLE_CLASS);
        if (!this.element.querySelector('.' + WORK_CELLS_CLASS)) {
            return;
        }
        if (this.parent.currentView === 'Month') {
            const wrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
            const cellTd = this.parent.element.querySelector('.' + WORK_CELLS_CLASS);
            cellTd.appendChild(wrapper);
            this.monthHeaderHeight = wrapper.offsetTop - cellTd.offsetTop;
            cellTd.removeChild(wrapper);
        }
        this.eventHeight = getElementHeightFromClass(this.element, APPOINTMENT_CLASS);
        const scrollTop = conWrap.scrollTop;
        if (this.parent.rowAutoHeight && this.parent.virtualScrollModule && !this.parent.virtualScrollModule.isHorizontalScroll
            && !isNullOrUndefined(this.parent.currentAction)) {
            conWrap.scrollTop = conWrap.scrollTop - 1;
        }
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            this.renderResourceEvents();
            if (this.parent.virtualScrollModule) {
                this.parent.virtualScrollModule.updateFocusedWorkCell();
            }
        }
        else {
            this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays);
        }
        if (this.parent.rowAutoHeight) {
            this.updateBlockElements();
            const data = {
                cssProperties: this.parent.getCssProperties(),
                module: this.parent.getModuleName(),
                isPreventScrollUpdate: true,
                scrollPosition: { left: this.parent.uiStateValues.left, top: this.parent.uiStateValues.top }
            };
            if (this.parent.virtualScrollModule && !this.parent.virtualScrollModule.isHorizontalScroll) {
                if (this.parent.currentAction) {
                    conWrap.scrollTop = scrollTop;
                    this.parent.currentAction = null;
                }
                else {
                    this.parent.virtualScrollModule.updateVirtualScrollHeight();
                }
            }
            if (!this.parent.enablePersistence) {
                this.parent.notify(contentReady, {});
            }
            this.parent.notify(scrollUiUpdate, data);
            if (this.parent.currentView === 'Month' && this.parent.showWeekNumber) {
                const totalCells = [].slice.call(this.parent.element.querySelectorAll('.e-content-wrap table tr td:first-child'));
                const weekNumberCells = [].slice.call(this.parent.element.querySelectorAll('.' + WEEK_NUMBER_CLASS));
                weekNumberCells.forEach((cell, i) => {
                    const height = totalCells[parseInt(i.toString(), 10)].offsetHeight;
                    setStyleAttribute(cell, { 'height': height + 'px' });
                });
                this.parent.element.querySelector('.' + WEEK_NUMBER_WRAPPER_CLASS).scrollTop =
                    this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS).scrollTop;
            }
        }
        this.parent.renderTemplates();
    }
    renderEventsHandler(dateRender, workDays, resData) {
        this.renderedEvents = [];
        let eventsList;
        let blockList;
        let resIndex = 0;
        if (resData) {
            resIndex = resData.groupIndex;
            this.cssClass = resData.cssClass;
            this.groupOrder = resData.groupOrder;
            eventsList = this.parent.eventBase.filterEventsByResource(resData, this.parent.eventsProcessed);
            blockList = this.parent.eventBase.filterEventsByResource(resData, this.parent.blockProcessed);
            this.workCells = [].slice.call(this.element.querySelectorAll('.' + WORK_CELLS_CLASS + '[data-group-index="' + resIndex + '"]'));
        }
        else {
            eventsList = this.parent.eventsProcessed;
            blockList = this.parent.blockProcessed;
            this.workCells = [].slice.call(this.element.querySelectorAll('.' + WORK_CELLS_CLASS));
        }
        this.sortByDateTime(eventsList);
        this.sortByDateTime(blockList);
        if (this.parent.currentView === 'Month' && this.parent.rowAutoHeight && this.parent.activeViewOptions.group.resources.length === 0) {
            const totalCells = [].slice.call(this.parent.element.querySelectorAll('.e-content-wrap table tr td:first-child'));
            const height = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS).clientHeight / totalCells.length;
            totalCells.forEach((cell) => {
                setStyleAttribute(cell, { 'height': height + 'px' });
            });
        }
        const cellDetail = this.workCells[this.parent.activeView.isTimelineView() ?
            0 : this.workCells.length - 1].getBoundingClientRect();
        this.cellWidth = cellDetail.width;
        this.cellHeight = cellDetail.height;
        this.dateRender = dateRender;
        const filteredDates = this.getRenderedDates(dateRender);
        this.getSlotDates(workDays || this.parent.activeViewOptions.workDays);
        this.processBlockEvents(blockList, resIndex, resData);
        let events = [];
        for (const event of eventsList) {
            if (this.parent.resourceBase && !resData) {
                this.cssClass = this.parent.resourceBase.getCssClass(event);
            }
            events = events.concat(this.splitEvent(event, filteredDates || this.dateRender));
        }
        for (let level = 0; level < this.slots.length; level++) {
            this.renderedEvents = [];
            const slot = this.slots[parseInt(level.toString(), 10)];
            const endDate = addDays(new Date(slot[slot.length - 1]), 1);
            const spannedEvents = this.filterEvents(new Date(slot[0]), endDate, events);
            for (const event of spannedEvents) {
                if (this.maxHeight) {
                    const sDate = this.parent.currentView === 'Month' ? event[this.fields.startTime] :
                        this.getStartTime(event, event.data);
                    if (this.getIndex(sDate) > 0) {
                        continue;
                    }
                }
                this.updateIndicatorIcon(event);
                this.renderEvents(event, resIndex, eventsList);
            }
        }
        this.cssClass = null;
        this.groupOrder = null;
    }
    processBlockEvents(blockEvents, resIndex, resData) {
        for (const event of blockEvents) {
            if (this.parent.resourceBase && !resData) {
                this.cssClass = this.parent.resourceBase.getCssClass(event);
            }
            const blockSpannedList = [];
            if (this.renderType === 'day' && !event[this.fields.isAllDay]) {
                const temp = extend({}, event, null, true);
                let isSameDate = this.isSameDate(temp[this.fields.startTime], temp[this.fields.endTime]);
                temp.isBlockIcon = isSameDate;
                if (!isSameDate && getDateInMs(temp[this.fields.startTime]) > 0) {
                    const e = extend({}, event, null, true);
                    e[this.fields.endTime] = addDays(resetTime(new Date(event[this.fields.startTime] + '')), 1);
                    e.isBlockIcon = true;
                    temp[this.fields.startTime] = e[this.fields.endTime];
                    blockSpannedList.push(e);
                }
                isSameDate = this.isSameDate(temp[this.fields.startTime], temp[this.fields.endTime]);
                if (!isSameDate && getDateInMs(temp[this.fields.endTime]) > 0) {
                    const e = extend({}, event, null, true);
                    e[this.fields.startTime] = resetTime(new Date(event[this.fields.endTime] + ''));
                    e.isBlockIcon = true;
                    blockSpannedList.push(e);
                    temp[this.fields.endTime] = e[this.fields.startTime];
                }
                blockSpannedList.push(temp);
            }
            else {
                blockSpannedList.push(event);
            }
            for (const blockEvent of blockSpannedList) {
                const spannedEvents = this.splitEvent(blockEvent, this.dateRender);
                for (const event of spannedEvents) {
                    this.renderBlockEvents(event, resIndex, !!blockEvent.isBlockIcon);
                }
            }
        }
    }
    isSameDate(start, end) {
        return new Date(+start).setHours(0, 0, 0, 0) === new Date(+end).setHours(0, 0, 0, 0);
    }
    renderBlockEvents(event, resIndex, isIcon) {
        const eventData = event.data;
        const startTime = this.getStartTime(event, eventData);
        const endTime = this.getEndTime(event, eventData);
        const day = this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime())));
        if (day < 0 || startTime > endTime) {
            return;
        }
        const cellTd = this.getCellTd(day);
        const position = this.getPosition(startTime, endTime, event[this.fields.isAllDay], day);
        if (!isIcon) {
            const diffInDays = eventData.count;
            let appWidth = this.getEventWidth(startTime, endTime, event[this.fields.isAllDay], diffInDays);
            appWidth = (appWidth <= 0) ? this.cellWidth : appWidth;
            const appLeft = (this.parent.enableRtl) ? 0 : position;
            const appRight = (this.parent.enableRtl) ? position : 0;
            const appHeight = this.cellHeight - this.monthHeaderHeight;
            const appTop = this.getRowTop(resIndex);
            const blockElement = this.createBlockAppointmentElement(event, resIndex, this.isResourceEventTemplate);
            setStyleAttribute(blockElement, {
                'width': appWidth + 'px', 'height': appHeight + 'px', 'left': appLeft + 'px',
                'right': appRight + 'px', 'top': appTop + 'px'
            });
            this.renderEventElement(event, blockElement, cellTd);
        }
        else {
            this.renderBlockIndicator(cellTd, position, resIndex);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    renderBlockIndicator(cellTd, position, resIndex) {
        const blockIndicator = createElement('div', { className: 'e-icons ' + BLOCK_INDICATOR_CLASS });
        if (isNullOrUndefined(cellTd.querySelector('.' + BLOCK_INDICATOR_CLASS))) {
            cellTd.appendChild(blockIndicator);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getStartTime(event, eventData) {
        return event[this.fields.startTime];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getEndTime(event, eventData) {
        return event[this.fields.endTime];
    }
    getCellTd(day) {
        return this.workCells[parseInt(day.toString(), 10)];
    }
    getEventWidth(startDate, endDate, isAllDay, count) {
        return count * this.cellWidth - 1;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPosition(startTime, endTime, isAllDay, day) {
        return 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getRowTop(resIndex) {
        return 0;
    }
    updateIndicatorIcon(event) {
        if (this.parent.currentView.indexOf('Timeline') === -1 || this.parent.currentView === 'TimelineMonth'
            || event[this.fields.isAllDay]) {
            return;
        }
        const cloneData = event.data;
        const start = this.parent.activeView.getStartHour();
        const end = this.parent.activeView.getEndHour();
        const startHour = getStartEndHours(event[this.fields.startTime], start, end);
        const endHour = getStartEndHours(event[this.fields.endTime], start, end);
        const actualStartTime = cloneData[this.fields.startTime];
        const actualEndTime = cloneData[this.fields.endTime];
        cloneData.isLeft = cloneData.isLeft || actualStartTime.getTime() < startHour.startHour.getTime();
        cloneData.isRight = cloneData.isRight || actualEndTime.getTime() > endHour.endHour.getTime();
        if (resetTime(actualStartTime).getTime() !== resetTime(actualEndTime).getTime()) {
            const actualStartHour = startHour.startHour;
            const actualEndHour = endHour.endHour;
            const startTime = new Date(resetTime(actualStartTime));
            startTime.setHours(actualEndHour.getHours(), actualEndHour.getMinutes(), actualEndHour.getSeconds());
            cloneData.isLeft = cloneData.isLeft || actualStartTime.getTime() >= (actualStartHour.getDate() === startHour.endHour.getDate() ?
                startTime.getTime() : addDays(startTime, 1).getTime());
            if (actualEndTime.getTime() !== resetTime(actualEndTime).getTime()) {
                const endTime = new Date(resetTime(actualEndTime));
                cloneData.isRight = cloneData.isRight || actualEndTime.getTime() <=
                    endTime.setHours(actualStartHour.getHours(), actualStartHour.getMinutes(), actualStartHour.getSeconds());
            }
        }
    }
    renderResourceEvents() {
        const resources = this.parent.uiStateValues.isGroupAdaptive ?
            [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] :
            this.parent.resourceBase.renderedResources;
        if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction) {
            for (let i = 0, len = this.parent.crudModule.crudObj.sourceEvent.length; i < len; i++) {
                const sourceRes = this.parent.crudModule.crudObj.sourceEvent[parseInt(i.toString(), 10)];
                this.renderEventsHandler(sourceRes.renderDates, sourceRes.workDays, sourceRes);
                if (this.parent.crudModule.crudObj.sourceEvent[parseInt(i.toString(), 10)].groupIndex !==
                    this.parent.crudModule.crudObj.targetEvent[parseInt(i.toString(), 10)].groupIndex) {
                    const target = this.parent.crudModule.crudObj.targetEvent[parseInt(i.toString(), 10)];
                    this.renderEventsHandler(target.renderDates, target.workDays, target);
                }
            }
            this.parent.crudModule.crudObj.isCrudAction = false;
        }
        else {
            for (const slotData of resources) {
                this.renderEventsHandler(slotData.renderDates, slotData.workDays, slotData);
            }
        }
    }
    getSlotDates(workDays) {
        this.slots = [];
        const dates = this.dateRender.map((date) => { return +date; });
        const noOfDays = !this.parent.activeViewOptions.showWeekend || (this.parent.activeViewOptions.group.byDate &&
            this.parent.activeViewOptions.group.hideNonWorkingDays) ? workDays.length : WEEK_LENGTH;
        while (dates.length > 0) {
            this.slots.push(dates.splice(0, noOfDays));
        }
    }
    createAppointmentElement(record, resIndex, isCloneElement = false) {
        const eventSubject = (record[this.fields.subject] || this.parent.eventSettings.fields.subject.default ||
            this.parent.localeObj.getConstant('addTitle'));
        const newRecord = extend({}, record, record.data, true);
        const attrs = {
            'data-id': 'Appointment_' + record[this.fields.id],
            'role': 'button', 'tabindex': '0',
            'aria-disabled': this.parent.eventBase.getReadonlyAttribute(record),
            'aria-label': this.parent.getAnnouncementString(newRecord, eventSubject)
        };
        if (!isCloneElement) {
            attrs['data-guid'] = record.Guid;
        }
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            attrs['data-group-index'] = resIndex.toString();
        }
        const appointmentWrapper = createElement('div', { className: APPOINTMENT_CLASS, attrs: attrs });
        if (!isNullOrUndefined(this.cssClass)) {
            addClass([appointmentWrapper], this.cssClass);
        }
        if (record[this.fields.isReadonly]) {
            addClass([appointmentWrapper], 'e-read-only');
        }
        const appointmentDetails = createElement('div', { className: APPOINTMENT_DETAILS });
        appointmentWrapper.appendChild(appointmentDetails);
        let templateElement;
        const eventData = record.data;
        const eventObj = this.getEventData(record);
        if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {
            const scheduleId = this.parent.element.id + '_';
            const viewName = this.parent.activeViewOptions.eventTemplateName;
            const templateId = scheduleId + viewName + 'eventTemplate';
            const eventTemplate = 'eventTemplate' + (this.isResourceEventTemplate ? '_' + resIndex : '');
            templateElement = this.parent.getAppointmentTemplate()(eventObj, this.parent, eventTemplate, templateId, false);
        }
        else {
            const eventLocation = (record[this.fields.location] || this.parent.eventSettings.fields.location.default || '');
            const appointmentSubject = createElement('div', { className: SUBJECT_CLASS });
            this.parent.sanitize((eventSubject + (eventLocation ? '; ' + eventLocation : '')), appointmentSubject);
            const appointmentStartTime = createElement('div', {
                className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),
                innerHTML: this.parent.getTimeString(eventData[this.fields.startTime])
            });
            const appointmentEndTime = createElement('div', {
                className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),
                innerHTML: this.parent.getTimeString(eventData[this.fields.endTime])
            });
            if (this.parent.currentView === 'Month') {
                if (record[this.fields.isAllDay]) {
                    templateElement = [appointmentSubject];
                    addClass([appointmentSubject], 'e-text-center');
                }
                else if (eventData.count <= 1 && !eventData.isLeft && !eventData.isRight) {
                    templateElement = [appointmentStartTime, appointmentSubject];
                }
                else {
                    templateElement = [];
                    addClass([appointmentSubject], 'e-text-center');
                    if (!eventData.isLeft) {
                        templateElement.push(appointmentStartTime);
                    }
                    templateElement.push(appointmentSubject);
                    if (!eventData.isRight) {
                        templateElement.push(appointmentEndTime);
                    }
                }
            }
            else {
                let innerElement;
                if (record[this.fields.isAllDay]) {
                    const allDayString = createElement('div', {
                        className: APPOINTMENT_TIME, innerHTML: this.parent.localeObj.getConstant('allDay')
                    });
                    innerElement = [appointmentSubject, allDayString];
                }
                else {
                    const timeString = this.parent.getTimeString(eventData[this.fields.startTime])
                        + ' - ' + this.parent.getTimeString(eventData[this.fields.endTime]);
                    const appTime = createElement('div', {
                        className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''), innerHTML: timeString
                    });
                    const appLocation = createElement('div', { className: LOCATION_CLASS });
                    this.parent.sanitize(eventLocation, appLocation);
                    innerElement = [appointmentSubject, appTime, appLocation];
                }
                const wrap = createElement('div', { className: 'e-inner-wrap' });
                append(innerElement, wrap);
                templateElement = [wrap];
            }
        }
        append(templateElement, appointmentDetails);
        this.appendEventIcons(record, appointmentDetails);
        this.renderResizeHandler(appointmentWrapper, record.data, record[this.fields.isReadonly]);
        return appointmentWrapper;
    }
    appendEventIcons(record, appointmentDetails) {
        const eventData = record.data;
        if (!isNullOrUndefined(record[this.fields.recurrenceRule]) || !isNullOrUndefined(record[this.fields.recurrenceID])) {
            const iconClass = (record[this.fields.id] === record[this.fields.recurrenceID]) ?
                EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;
            appointmentDetails.appendChild(createElement('div', {
                className: ICON + ' ' + iconClass + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : '')
            }));
        }
        if (eventData.isLeft) {
            const iconLeft = createElement('div', {
                className: EVENT_INDICATOR_CLASS + ' ' + ICON + ' ' + EVENT_ICON_LEFT_CLASS
            });
            prepend([iconLeft], appointmentDetails);
        }
        if (eventData.isRight) {
            const iconRight = createElement('div', {
                className: EVENT_INDICATOR_CLASS + ' ' + ICON + ' ' + EVENT_ICON_RIGHT_CLASS
            });
            append([iconRight], appointmentDetails);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    renderEvents(event, resIndex, eventsList) {
        const startTime = event[this.fields.startTime];
        const endTime = event[this.fields.endTime];
        const day = this.parent.getIndexOfDate(this.dateRender, resetTime(startTime));
        if ((day < 0) || (startTime.getTime() < this.parent.minDate.getTime()) || (endTime.getTime() > this.parent.maxDate.getTime())) {
            return;
        }
        const overlapCount = this.getIndex(startTime);
        event.Index = overlapCount;
        const diffInDays = event.data.count;
        if (startTime.getTime() <= endTime.getTime()) {
            const appWidth = (diffInDays * this.cellWidth) - 5;
            const cellTd = this.workCells[parseInt(day.toString(), 10)];
            const appTop = (overlapCount * (this.eventHeight + EVENT_GAP));
            const height = this.monthHeaderHeight + ((overlapCount + 1) * (this.eventHeight + EVENT_GAP)) + this.moreIndicatorHeight;
            const enableAppRender = this.maxOrIndicator ? overlapCount < 1 ? true : false : this.cellHeight > height;
            if (this.parent.rowAutoHeight || enableAppRender) {
                this.renderedEvents.push(extend({}, event, null, true));
                let appointmentElement;
                if (this.inlineValue) {
                    appointmentElement = this.parent.inlineModule.createInlineAppointmentElement();
                }
                else {
                    appointmentElement = this.createAppointmentElement(event, resIndex);
                }
                this.applyResourceColor(appointmentElement, event, 'backgroundColor', this.groupOrder);
                this.wireAppointmentEvents(appointmentElement, event);
                setStyleAttribute(appointmentElement, { 'width': appWidth + 'px', 'top': appTop + 'px' });
                this.renderEventElement(event, appointmentElement, cellTd);
                if (this.parent.rowAutoHeight) {
                    const firstChild = cellTd.parentElement.firstElementChild;
                    this.updateCellHeight(firstChild, height);
                }
            }
            else {
                for (let i = 0; i < diffInDays; i++) {
                    if (this.workCells[day + i]) {
                        const indicator = this.workCells[day + i].querySelector('.' + MORE_INDICATOR_CLASS);
                        if (indicator) {
                            const count = parseInt(indicator.getAttribute('data-count'), 10) + 1;
                            indicator.setAttribute('data-count', count.toString());
                            indicator.innerHTML = this.getMoreIndicatorText(count);
                        }
                        else {
                            const startDate = new Date(this.dateRender[day + i].getTime());
                            const endDate = addDays(this.dateRender[day + i], 1);
                            const groupIndex = this.workCells[day + i].getAttribute('data-group-index');
                            const moreIndicatorElement = this.getMoreIndicatorElement(1, startDate, endDate);
                            if (!isNullOrUndefined(groupIndex)) {
                                moreIndicatorElement.setAttribute('data-group-index', groupIndex);
                            }
                            moreIndicatorElement.style.top = (this.cellHeight - this.monthHeaderHeight - this.moreIndicatorHeight) + 'px';
                            moreIndicatorElement.style.width = this.cellWidth - 2 + 'px';
                            this.renderElement(this.workCells[day + i], moreIndicatorElement);
                            EventHandler.add(moreIndicatorElement, 'click', this.moreIndicatorClick, this);
                        }
                    }
                }
            }
        }
    }
    updateCellHeight(cell, height) {
        if ((height > cell.offsetHeight)) {
            setStyleAttribute(cell, { 'height': height + 'px' });
        }
    }
    updateBlockElements() {
        const blockElement = [].slice.call(this.element.querySelectorAll('.' + BLOCK_APPOINTMENT_CLASS));
        for (const element of blockElement) {
            const target = closest(element, 'tr');
            this.monthHeaderHeight = element.offsetParent.offsetTop - target.offsetTop;
            element.style.height = ((target.offsetHeight - 1) - this.monthHeaderHeight) + 'px';
            const firstChild = target.firstElementChild;
            const width = Math.round(element.offsetWidth / firstChild.offsetWidth);
            element.style.width = (firstChild.offsetWidth * width) + 'px';
        }
    }
    // eslint-disable-next-line max-len
    getFilteredEvents(startDate, endDate, groupIndex, eventsList) {
        let filteredEvents;
        if (isNullOrUndefined(groupIndex)) {
            filteredEvents = this.filterEvents(startDate, endDate);
        }
        else {
            const data = this.parent.resourceBase.lastResourceLevel[parseInt(groupIndex, 10)];
            filteredEvents = this.filterEvents(startDate, endDate, isNullOrUndefined(eventsList) ? undefined : eventsList, data);
        }
        return filteredEvents;
    }
    getOverlapEvents(date, appointments) {
        const appointmentsList = [];
        const dateTime = resetTime(date).getTime();
        for (const app of appointments) {
            if ((resetTime(app[this.fields.startTime]).getTime() <= dateTime) &&
                (resetTime(app[this.fields.endTime]).getTime() >= dateTime)) {
                appointmentsList.push(app);
            }
        }
        return appointmentsList;
    }
    getIndex(date) {
        let appIndex = -1;
        const appointments = this.renderedEvents;
        if (appointments.length > 0) {
            const appointmentsList = this.getOverlapEvents(date, appointments);
            const appLevel = appointmentsList.map((obj) => obj.Index);
            appIndex = (appLevel.length > 0) ? this.getSmallestMissingNumber(appLevel) : 0;
        }
        return (appIndex === -1) ? 0 : appIndex;
    }
    moreIndicatorClick(event) {
        const target = closest(event.target, '.' + MORE_INDICATOR_CLASS);
        const startDate = new Date(parseInt(target.getAttribute('data-start-date'), 10));
        const endDate = new Date(parseInt(target.getAttribute('data-end-date'), 10));
        const groupIndex = target.getAttribute('data-group-index');
        const moreArgs = {
            cancel: false, event: event, element: target, isPopupOpen: true,
            startTime: startDate, endTime: endDate, viewName: this.parent.getNavigateView()
        };
        if (groupIndex) {
            moreArgs.groupIndex = parseInt(groupIndex, 10);
        }
        this.parent.trigger(moreEventsClick, moreArgs, (clickArgs) => {
            if (!clickArgs.cancel) {
                if (clickArgs.isPopupOpen) {
                    const filteredEvents = this.getFilteredEvents(startDate, endDate, groupIndex);
                    const moreArgs = { date: startDate, event: filteredEvents, element: event.target };
                    this.parent.quickPopup.moreEventClick(moreArgs, endDate, groupIndex);
                }
                else {
                    this.parent.setProperties({ selectedDate: startDate }, true);
                    this.parent.changeView(clickArgs.viewName, event);
                }
            }
        });
    }
    renderEventElement(event, appointmentElement, cellTd) {
        const eventType = appointmentElement.classList.contains(BLOCK_APPOINTMENT_CLASS) ? 'blockEvent' : 'event';
        const isAppointment = appointmentElement.classList.contains(APPOINTMENT_CLASS);
        const eventObj = this.getEventData(event);
        const args = { data: eventObj, element: appointmentElement, cancel: false, type: eventType };
        this.parent.trigger(eventRendered, args, (eventArgs) => {
            if (eventArgs.cancel) {
                this.renderedEvents.pop();
            }
            else {
                this.renderElement(cellTd, appointmentElement, isAppointment);
            }
        });
    }
    getEventData(event) {
        const eventObj = extend({}, event, null, true);
        eventObj[this.fields.startTime] = event.data[this.fields.startTime];
        eventObj[this.fields.endTime] = event.data[this.fields.endTime];
        return eventObj;
    }
    renderElement(cellTd, element, isAppointment = false) {
        if (this.maxOrIndicator && isAppointment) {
            this.setMaxEventHeight(element, cellTd);
        }
        const wrapperEle = cellTd.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);
        if (wrapperEle) {
            wrapperEle.appendChild(element);
        }
        else {
            const wrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
            wrapper.appendChild(element);
            cellTd.appendChild(wrapper);
        }
    }
    getMoreIndicatorElement(count, startDate, endDate) {
        const moreIndicatorElement = createElement('div', {
            className: MORE_INDICATOR_CLASS,
            innerHTML: this.getMoreIndicatorText(count),
            attrs: {
                'tabindex': '0',
                'data-count': count.toString(),
                'data-start-date': startDate.getTime().toString(),
                'data-end-date': endDate.getTime().toString()
            }
        });
        return moreIndicatorElement;
    }
    getMoreIndicatorText(count) {
        return '+' + this.parent.globalize.formatNumber(count) + '&nbsp;' + (this.parent.isAdaptive ? '' : this.parent.localeObj.getConstant('more'));
    }
    removeHeightProperty(selector) {
        const rows = [].slice.call(this.element.querySelectorAll('.' + selector + ' tbody tr'));
        for (const row of rows) {
            row.firstElementChild.style.height = '';
        }
    }
    setMaxEventHeight(event, cell) {
        const headerHeight = getOuterHeight(cell.querySelector('.' + DATE_HEADER_CLASS));
        const height = (cell.offsetHeight - headerHeight) - (this.maxHeight ? 0 : this.moreIndicatorHeight);
        setStyleAttribute(event, { 'height': height + 'px', 'align-items': 'center' });
    }
    destroy() {
        this.element = null;
        this.fields = null;
        this.maxHeight = null;
        this.withIndicator = null;
        this.maxOrIndicator = null;
        this.moreIndicatorHeight = null;
        this.removeEventListener();
        super.destroy();
    }
}

/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/no-explicit-any */
const EVENT_GAP$1 = 2;
const BLOCK_INDICATOR_WIDTH = 22;
const BLOCK_INDICATOR_HEIGHT = 18;
/**
 * Timeline view events render
 */
class TimelineEvent extends MonthEvent {
    constructor(parent, type) {
        super(parent);
        this.startHour = this.parent.activeView.getStartHour();
        this.endHour = this.parent.activeView.getEndHour();
        this.slotCount = this.parent.activeViewOptions.timeScale.slotCount;
        this.interval = this.parent.activeViewOptions.timeScale.interval;
        this.day = 0;
        this.rowIndex = 0;
        this.cellTops = [];
        this.renderType = type;
        this.eventContainers = [].slice.call(this.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));
        const tr = [].slice.call(this.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody tr'));
        this.dayLength = tr.length === 0 ? 0 : tr[0].children.length;
        this.content = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS);
    }
    getSlotDates() {
        this.slots = [];
        this.slots.push(this.parent.activeView.renderDates.map((date) => { return +date; }));
        if (this.parent.activeViewOptions.headerRows.length > 0 &&
            this.parent.activeViewOptions.headerRows.slice(-1)[0].option !== 'Hour') {
            this.renderType = 'day';
            this.cellWidth = this.content.offsetWidth / this.dateRender.length;
            this.slotsPerDay = 1;
        }
        else {
            this.slotsPerDay = (this.dayLength / this.dateRender.length);
        }
    }
    getOverlapEvents(date, appointments) {
        const appointmentsList = [];
        if (this.renderType === 'day') {
            for (const app of appointments) {
                if ((resetTime(app[this.fields.startTime]).getTime() <= resetTime(new Date(date.getTime())).getTime()) &&
                    (resetTime(app[this.fields.endTime]).getTime() >= resetTime(new Date(date.getTime())).getTime())) {
                    appointmentsList.push(app);
                }
            }
        }
        else {
            for (const app of appointments) {
                const eventData = app.data;
                if (eventData.trimStartTime.getTime() <= date.getTime() &&
                    eventData.trimEndTime.getTime() > date.getTime()) {
                    appointmentsList.push(app);
                }
            }
        }
        return appointmentsList;
    }
    getSortComparerIndex(startDate, endDate) {
        let appIndex = -1;
        const appointments = this.renderedEvents;
        if (appointments.length > 0) {
            const appointmentsList = this.getOverlapSortComparerEvents(startDate, endDate, appointments);
            const appLevel = appointmentsList.map((obj) => obj.Index);
            appIndex = (appLevel.length > 0) ? this.getSmallestMissingNumber(appLevel) : 0;
        }
        return (appIndex === -1) ? 0 : appIndex;
    }
    getOverlapSortComparerEvents(startDate, endDate, appointmentsCollection) {
        const appointments = [];
        for (const app of appointmentsCollection) {
            if (this.renderType === 'day') {
                if ((resetTime(app[this.fields.startTime]).getTime() <= resetTime(new Date(startDate.getTime())).getTime()) &&
                    (resetTime(app[this.fields.endTime]).getTime() >= resetTime(new Date(startDate.getTime())).getTime())) {
                    appointments.push(app);
                }
            }
            else {
                const eventData = app.data;
                if (((eventData.trimStartTime.getTime() <= startDate.getTime()) && (startDate.getTime() < eventData.trimEndTime.getTime())) ||
                    ((startDate.getTime() <= eventData.trimStartTime.getTime()) && (eventData.trimStartTime.getTime() < endDate.getTime()))) {
                    appointments.push(app);
                }
            }
        }
        return appointments;
    }
    renderResourceEvents() {
        this.removeHeightProperty(RESOURCE_COLUMN_TABLE_CLASS);
        const resources = this.parent.uiStateValues.isGroupAdaptive ?
            [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] :
            this.parent.resourceBase.renderedResources;
        if (this.parent.crudModule && this.parent.crudModule.crudObj.isCrudAction) {
            for (let i = 0, len = this.parent.crudModule.crudObj.sourceEvent.length; i < len; i++) {
                const source = this.parent.crudModule.crudObj.sourceEvent[parseInt(i.toString(), 10)];
                this.rowIndex = source.groupIndex;
                this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays, source);
                if (this.parent.crudModule.crudObj.targetEvent[parseInt(i.toString(), 10)] && this.parent.crudModule.crudObj.sourceEvent[parseInt(i.toString(), 10)].groupIndex !==
                    this.parent.crudModule.crudObj.targetEvent[parseInt(i.toString(), 10)].groupIndex) {
                    const target = this.parent.crudModule.crudObj.targetEvent[parseInt(i.toString(), 10)];
                    this.rowIndex = target.groupIndex;
                    this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays, target);
                }
            }
            this.parent.crudModule.crudObj.isCrudAction = false;
        }
        else {
            for (let i = 0; i < resources.length; i++) {
                this.rowIndex = i;
                this.renderEventsHandler(this.parent.activeView.renderDates, this.parent.activeViewOptions.workDays, resources[parseInt(i.toString(), 10)]);
            }
        }
    }
    renderEvents(event, resIndex, appointmentsList) {
        let startTime = event[this.fields.startTime];
        let endTime = event[this.fields.endTime];
        if ((startTime.getTime() < this.parent.minDate.getTime()) || (endTime.getTime() > this.parent.maxDate.getTime())) {
            return;
        }
        const eventData = event.data;
        startTime = this.getStartTime(event, eventData);
        endTime = this.getEndTime(event, eventData);
        const startEndHours = getStartEndHours(event[this.fields.startTime], this.startHour, this.endHour);
        const eventDates = this.updateEventMinimumDuration(startEndHours, startTime, endTime);
        startTime = eventDates.startDate;
        endTime = eventDates.endDate;
        this.day = this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime())));
        if (this.day < 0) {
            return;
        }
        const cellTd = this.getCellTd();
        const overlapCount = (isNullOrUndefined(this.parent.eventSettings.sortComparer)) ? this.getIndex(startTime) : this.getSortComparerIndex(startTime, endTime);
        event.Index = overlapCount;
        const appHeight = this.eventHeight;
        const diffInDays = eventData.count;
        const eventObj = extend({}, event, null, true);
        eventObj[this.fields.startTime] = eventData[this.fields.startTime];
        eventObj[this.fields.endTime] = eventData[this.fields.endTime];
        const currentDate = resetTime(new Date(this.dateRender[this.day].getTime()));
        const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);
        let isValidEvent = true;
        if (this.isDayProcess() || eventObj[this.fields.isAllDay]) {
            isValidEvent = true;
        }
        else {
            isValidEvent = this.isValidEvent(eventObj, startTime, endTime, schedule);
        }
        if (startTime <= endTime && isValidEvent) {
            let appWidth = this.getEventWidth(startTime, endTime, event[this.fields.isAllDay], diffInDays);
            appWidth = this.renderType === 'day' ? appWidth - 2 : appWidth;
            let appLeft = 0;
            let appRight = 0;
            const position = this.getPosition(startTime, endTime, event[this.fields.isAllDay], this.day);
            appWidth = (appWidth <= 0) ? this.cellWidth : appWidth; // appWidth 0 when start and end time as same
            this.renderedEvents.push(extend({}, event, null, true));
            if (isNullOrUndefined(this.cellTops[parseInt(resIndex.toString(), 10)])) {
                this.cellTops[parseInt(resIndex.toString(), 10)] = this.getRowTop(resIndex);
            }
            const top = this.cellTops[parseInt(resIndex.toString(), 10)];
            const appTop = (top + (this.maxHeight ? 0 : EVENT_GAP$1)) + (overlapCount * (appHeight + EVENT_GAP$1));
            appLeft = (this.parent.enableRtl) ? 0 : position;
            appRight = (this.parent.enableRtl) ? position : 0;
            const height = ((overlapCount + 1) * (appHeight + EVENT_GAP$1)) + this.moreIndicatorHeight;
            const renderApp = this.maxOrIndicator ? overlapCount < 1 ? true : false : this.cellHeight > height;
            if (this.parent.rowAutoHeight || renderApp) {
                let appointmentElement;
                if (isNullOrUndefined(this.inlineValue)) {
                    appointmentElement = this.createAppointmentElement(event, resIndex);
                }
                else {
                    appointmentElement = this.parent.inlineModule.createInlineAppointmentElement();
                }
                this.applyResourceColor(appointmentElement, event, 'backgroundColor', this.groupOrder);
                setStyleAttribute(appointmentElement, {
                    'width': appWidth + 'px', 'left': appLeft + 'px', 'right': appRight + 'px', 'top': appTop + 'px'
                });
                this.wireAppointmentEvents(appointmentElement, event);
                this.renderEventElement(event, appointmentElement, cellTd);
                if (this.parent.rowAutoHeight) {
                    const firstChild = this.getFirstChild(resIndex);
                    this.updateCellHeight(firstChild, height);
                }
            }
            else {
                for (let i = 0; i < diffInDays; i++) {
                    const moreIndicator = cellTd.querySelector('.' + MORE_INDICATOR_CLASS);
                    let appPos = (this.parent.enableRtl) ? appRight : appLeft;
                    appPos = (Math.floor(appPos / this.cellWidth) * this.cellWidth);
                    const interval = this.interval / this.slotCount;
                    let startDate = (this.parent.activeViewOptions.option === 'TimelineMonth' || this.renderType === 'day' || i !== 0) ?
                        new Date(this.dateRender[this.day + i].getTime()) : new Date(startTime);
                    let endDate = addDays(this.dateRender[this.day + i], 1);
                    if (this.parent.activeViewOptions.option === 'TimelineMonth' || this.renderType === 'day') {
                        const position = this.getPosition(startDate, endDate, event[this.fields.isAllDay], (this.day + i));
                        this.renderTimelineMoreIndicator(startTime, startDate, endDate, appHeight, interval, resIndex, appointmentsList, top, appLeft, appRight, cellTd, moreIndicator, appPos, position);
                    }
                    else {
                        const slotCount = (getUniversalTime(endTime) - getUniversalTime(startTime)) / MS_PER_MINUTE *
                            this.slotCount / this.interval;
                        for (let k = 0; k < slotCount; k++) {
                            startDate = (k === 0) ? new Date(startDate.getTime()) : new Date(startDate.getTime() + (60000 * interval));
                            endDate = new Date(startDate.getTime() + (60000 * interval));
                            if (endDate.getTime() > endTime.getTime()) {
                                break;
                            }
                            const position = this.getPosition(startDate, endDate, false, (this.day + i));
                            if (appPos > position) {
                                break;
                            }
                            appPos = position;
                            this.renderTimelineMoreIndicator(startTime, startDate, endDate, appHeight, interval, resIndex, appointmentsList, top, appLeft, appRight, cellTd, moreIndicator, appPos, position);
                        }
                    }
                }
            }
        }
        this.parent.renderTemplates();
    }
    renderTimelineMoreIndicator(startTime, startDate, endDate, appHeight, interval, resIndex, appointmentsList, top, appLeft, appRight, cellTd, moreIndicator, appPos, position) {
        appLeft = (this.parent.enableRtl) ? appRight = position : position;
        appPos = (this.parent.enableRtl) ? appRight : appLeft;
        appPos = (Math.round(appPos / this.cellWidth) * this.cellWidth);
        if ((cellTd && isNullOrUndefined(moreIndicator)) ||
            (!this.isAlreadyAvail(appPos, cellTd))) {
            const startDateTime = (this.parent.activeViewOptions.option === 'TimelineMonth' || this.renderType === 'day') ? new Date(+startTime) : startDate;
            const slotStartTime = (new Date(startDateTime.setMinutes(Math.floor(startDateTime.getMinutes() / interval) * interval)));
            const slotEndTime = new Date(slotStartTime.getTime() + (60000 * interval));
            let groupIndex;
            if (this.parent.activeViewOptions.group.resources.length > 0 && !isNullOrUndefined(resIndex)) {
                groupIndex = resIndex.toString();
            }
            const filterEvents = this.getFilterEvents(startDate, endDate, slotStartTime, slotEndTime, groupIndex, appointmentsList);
            const appArea = this.cellHeight - this.moreIndicatorHeight;
            appHeight = this.withIndicator ? appArea - EVENT_GAP$1 : appHeight;
            const renderedAppCount = Math.floor(appArea / (appHeight + EVENT_GAP$1));
            const count = (filterEvents.length - renderedAppCount) <= 0 ? 1 : (filterEvents.length - renderedAppCount);
            let moreIndicatorElement;
            if (this.renderType === 'day') {
                moreIndicatorElement = this.getMoreIndicatorElement(count, startDate, endDate);
            }
            else {
                moreIndicatorElement = this.getMoreIndicatorElement(count, slotStartTime, slotEndTime);
            }
            if (!isNullOrUndefined(groupIndex)) {
                moreIndicatorElement.setAttribute('data-group-index', groupIndex);
            }
            moreIndicatorElement.style.top = top + appArea + 'px';
            moreIndicatorElement.style.width = this.cellWidth + 'px';
            moreIndicatorElement.style.left = ((appLeft / this.cellWidth) * this.cellWidth) + 'px';
            moreIndicatorElement.style.right = ((appRight / this.cellWidth) * this.cellWidth) + 'px';
            this.renderElement(cellTd, moreIndicatorElement);
            EventHandler.add(moreIndicatorElement, 'click', this.moreIndicatorClick, this);
        }
    }
    updateCellHeight(cell, height) {
        const cellHeight = cell.style.height === '' ? this.cellHeight : parseInt(cell.style.height, 10);
        if (height > cellHeight) {
            setStyleAttribute(cell, { 'height': height + 'px' });
            if (this.parent.activeViewOptions.group.resources.length > 0) {
                const resourceCell = this.parent.element.querySelector('.' + RESOURCE_COLUMN_TABLE_CLASS + ' ' + 'tbody td[data-group-index="' +
                    cell.getAttribute('data-group-index') + '"]');
                if (resourceCell) {
                    setStyleAttribute(resourceCell, { 'height': height + 'px' });
                }
            }
            const monthHeader = this.parent.element.querySelector('.e-month-header-wrapper table tr:nth-child(' +
                (cell.parentElement.rowIndex + 1) + ') td');
            if (monthHeader) {
                setStyleAttribute(monthHeader, { 'height': height + 'px' });
            }
        }
    }
    getFirstChild(index) {
        const query = '.' + CONTENT_TABLE_CLASS + ' tbody td';
        let groupIndex = '';
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            groupIndex = '[data-group-index="' + index.toString() + '"]';
        }
        const td = this.parent.element.querySelector(query + groupIndex);
        return td;
    }
    updateBlockElements() {
        const blockElement = [].slice.call(this.element.querySelectorAll('.' + BLOCK_APPOINTMENT_CLASS));
        for (const element of blockElement) {
            const resIndex = parseInt(element.getAttribute('data-group-index'), 10);
            const firstChild = this.getFirstChild(resIndex);
            element.style.height = firstChild.offsetHeight + 'px';
            const width = Math.round(element.offsetWidth / firstChild.offsetWidth);
            element.style.width = (firstChild.offsetWidth * width) + 'px';
        }
        const blockIndicator = [].slice.call(this.element.querySelectorAll('.' + BLOCK_INDICATOR_CLASS));
        for (const element of blockIndicator) {
            const resIndex = parseInt(element.getAttribute('data-group-index'), 10);
            element.style.top = this.getRowTop(resIndex) +
                this.getFirstChild(resIndex).offsetHeight - BLOCK_INDICATOR_HEIGHT + 'px';
        }
    }
    getStartTime(event, eventData) {
        let startTime = event[this.fields.startTime];
        const schedule = getStartEndHours(startTime, this.startHour, this.endHour);
        if (this.isDayProcess()) {
            startTime = event[this.fields.startTime];
        }
        else {
            if (schedule.startHour.getTime() >= eventData[this.fields.startTime]) {
                startTime = schedule.startHour;
            }
            else if (schedule.endHour.getTime() <= eventData[this.fields.startTime]) {
                startTime = this.getNextDay(schedule.startHour, eventData);
            }
            else {
                startTime = eventData[this.fields.startTime];
            }
        }
        // To overcome the overflow
        eventData.trimStartTime = (event[this.fields.isAllDay]) ? schedule.startHour : eventData[this.fields.startTime];
        return startTime;
    }
    getNextDay(startTime, eventData) {
        let startDate;
        for (let i = 1; i <= this.dateRender.length; i++) {
            startDate = addDays(startTime, i);
            if (this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime()))) !== -1) {
                eventData.count = eventData.count - 1;
                return startDate;
            }
        }
        return startDate;
    }
    getEndTime(event, eventData) {
        let endTime = event[this.fields.endTime];
        const schedule = getStartEndHours(endTime, this.startHour, this.endHour);
        if (this.isDayProcess()) {
            endTime = eventData[this.fields.endTime];
        }
        else {
            endTime = eventData[this.fields.endTime];
            if (schedule.endHour.getTime() <= eventData[this.fields.endTime] || event[this.fields.isAllDay]) {
                endTime = schedule.endHour;
            }
            if (schedule.startHour.getTime() >= eventData[this.fields.endTime].getTime() && !event[this.fields.isAllDay]) {
                endTime = this.getPreviousDay(schedule.startHour, schedule.endHour, eventData);
            }
        }
        // To overcome the overflow
        eventData.trimEndTime = (event[this.fields.isAllDay]) ? schedule.endHour : eventData[this.fields.endTime];
        return endTime;
    }
    getPreviousDay(startTime, endTime, eventData) {
        for (let i = 1; i <= this.dateRender.length; i++) {
            let endDate = addDays(endTime, -i);
            if (this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime()))) !== -1) {
                endDate = resetTime(new Date(endDate.getTime()));
                endDate.setHours(endTime.getHours(), endTime.getMinutes(), endTime.getSeconds());
                const count = eventData.count;
                const actualEndTime = eventData[this.fields.endTime];
                eventData.count = actualEndTime.getHours() !== 0 || actualEndTime.getMinutes() !== 0 ? count - 1 : count;
                return endDate;
            }
        }
        return eventData[this.fields.endTime];
    }
    getEventWidth(startDate, endDate, isAllDay, count) {
        if (this.renderType === 'day' || isAllDay) {
            return (count * this.slotsPerDay) * this.cellWidth;
        }
        if (this.isSameDay(startDate, endDate)) {
            return this.getSameDayEventsWidth(startDate, endDate);
        }
        else {
            return this.getSpannedEventsWidth(startDate, endDate, count);
        }
    }
    getSameDayEventsWidth(startDate, endDate) {
        return ((getUniversalTime(endDate) - getUniversalTime(startDate)) /
            MS_PER_MINUTE * (this.cellWidth * this.slotCount) / this.interval);
    }
    getSpannedEventsWidth(startDate, endDate, diffInDays) {
        const width = (diffInDays * this.slotsPerDay) * this.cellWidth;
        let endWidth;
        const start = getStartEndHours(resetTime(new Date(startDate.getTime())), this.startHour, this.endHour);
        const startWidth = this.getSameDayEventsWidth(start.startHour, startDate);
        if (this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(endDate.getTime()))) === -1) {
            endWidth = 0;
        }
        else {
            const end = getStartEndHours(resetTime(new Date(endDate.getTime())), this.startHour, this.endHour);
            endWidth = this.getSameDayEventsWidth(endDate, end.endHour);
            endWidth = ((this.slotsPerDay * this.cellWidth) === endWidth) ? 0 : endWidth;
        }
        const spannedWidth = startWidth + endWidth;
        return (width > spannedWidth) ? width - spannedWidth : width - startWidth;
    }
    isSameDay(startTime, endTime) {
        const startDay = this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(startTime.getTime())));
        const endDay = this.parent.getIndexOfDate(this.dateRender, resetTime(new Date(endTime.getTime())));
        return (startDay === endDay);
    }
    getAppointmentLeft(schedule, startTime, day) {
        const slotTd = (this.isSameDay(startTime, schedule.startHour)) ?
            ((getUniversalTime(startTime) - getUniversalTime(schedule.startHour)) /
                (MS_PER_MINUTE * this.interval)) * this.slotCount : 0;
        if (day === 0) {
            return slotTd;
        }
        else {
            const daySlot = Math.round((((getUniversalTime(schedule.endHour) - getUniversalTime(schedule.startHour)) /
                MS_PER_MINUTE) / this.interval) * this.slotCount);
            return (daySlot * day) + slotTd;
        }
    }
    getPosition(startTime, endTime, isAllDay, day) {
        if (this.renderType === 'day' || isAllDay) {
            return (day * this.slotsPerDay) * this.cellWidth;
        }
        const currentDate = resetTime(new Date(this.dateRender[parseInt(day.toString(), 10)].getTime()));
        const schedule = getStartEndHours(currentDate, this.startHour, this.endHour);
        let cellIndex;
        if (schedule.endHour.getTime() <= endTime.getTime() && schedule.startHour.getTime() >= startTime.getTime()) {
            cellIndex = this.getAppointmentLeft(schedule, schedule.startHour, day);
        }
        else if (schedule.endHour.getTime() <= endTime.getTime()) {
            cellIndex = this.getAppointmentLeft(schedule, startTime, day);
        }
        else if (schedule.startHour.getTime() >= startTime.getTime()) {
            cellIndex = this.getAppointmentLeft(schedule, schedule.startHour, day);
        }
        else {
            cellIndex = this.getAppointmentLeft(schedule, startTime, day);
        }
        return cellIndex * this.cellWidth;
    }
    getFilterEvents(startDate, endDate, startTime, endTime, gIndex, eventsList) {
        if (this.renderType === 'day') {
            return this.getFilteredEvents(startDate, endDate, gIndex, eventsList);
        }
        else {
            return this.getFilteredEvents(startTime, endTime, gIndex, eventsList);
        }
    }
    isAlreadyAvail(appPos, cellTd) {
        const moreIndicator = [].slice.call(cellTd.querySelectorAll('.' + MORE_INDICATOR_CLASS));
        for (let i = 0; i < moreIndicator.length; i++) {
            let indicatorPos;
            if (moreIndicator) {
                indicatorPos = (this.parent.enableRtl) ? moreIndicator[parseInt(i.toString(), 10)].style.right : moreIndicator[parseInt(i.toString(), 10)].style.left;
            }
            if (parseInt(indicatorPos, 10) === Math.floor(appPos)) {
                return true;
            }
        }
        return false;
    }
    getRowTop(resIndex) {
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            return this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS +
                ' ' + 'tbody td[data-group-index="' + resIndex.toString() + '"]').offsetTop;
        }
        return 0;
    }
    getCellTd() {
        const wrapIndex = this.parent.uiStateValues.isGroupAdaptive ? 0 : this.rowIndex;
        return this.eventContainers[parseInt(wrapIndex.toString(), 10)];
    }
    renderBlockIndicator(cellTd, position, resIndex) {
        // No need to render block icon for Year, Month and Week header rows
        if (this.parent.headerRows.length > 0 &&
            (this.parent.headerRows[this.parent.headerRows.length - 1].option !== 'Hour' ||
                this.parent.headerRows[this.parent.headerRows.length - 1].option !== 'Date')) {
            return;
        }
        position = (Math.floor(position / this.cellWidth) * this.cellWidth) + this.cellWidth - BLOCK_INDICATOR_WIDTH;
        if (!this.isAlreadyAvail(position, cellTd)) {
            const blockIndicator = createElement('div', { className: 'e-icons ' + BLOCK_INDICATOR_CLASS });
            if (this.parent.activeViewOptions.group.resources.length > 0) {
                blockIndicator.setAttribute('data-group-index', resIndex.toString());
            }
            if (this.parent.enableRtl) {
                blockIndicator.style.right = position + 'px';
            }
            else {
                blockIndicator.style.left = position + 'px';
            }
            blockIndicator.style.top = this.getRowTop(resIndex) + this.cellHeight - BLOCK_INDICATOR_HEIGHT + 'px';
            this.renderElement(cellTd, blockIndicator);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setMaxEventHeight(event, cell) {
        setStyleAttribute(event, {
            'height': (this.cellHeight - (this.maxHeight ? 0 : EVENT_GAP$1) - (this.maxHeight ? 0 : this.moreIndicatorHeight)) + 'px'
        });
    }
    isDayProcess() {
        if (this.parent.currentView === 'TimelineMonth' || !this.parent.activeViewOptions.timeScale.enable ||
            (this.parent.activeViewOptions.headerRows.length > 0 &&
                this.parent.activeViewOptions.headerRows.slice(-1)[0].option !== 'Hour')) {
            return true;
        }
        return false;
    }
    destroy() {
        this.renderType = null;
        this.eventContainers = null;
        this.dayLength = null;
        this.content = null;
        super.destroy();
        this.parent = null;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Inline Edit interactions
 */
class InlineEdit {
    constructor(parent) {
        this.parent = parent;
        this.parent.on(inlineClick, this.inlineEdit, this);
    }
    inlineEdit(args) {
        if (this.parent.quickPopup) {
            this.parent.quickPopup.quickPopupHide();
        }
        if (args.type === 'Cell') {
            const moreWrapper = this.parent.element.querySelector('.' + MORE_POPUP_WRAPPER_CLASS);
            if (moreWrapper && moreWrapper.classList.contains(POPUP_OPEN)) {
                this.parent.quickPopup.morePopup.hide();
            }
            this.removeInlineAppointmentElement();
            this.cellEdit(args);
        }
        else {
            if (this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS) !==
                args.element.querySelector('.' + INLINE_SUBJECT_CLASS)) {
                this.removeInlineAppointmentElement();
            }
            this.eventEdit(args);
        }
    }
    cellEdit(args) {
        const saveObj = this.generateEventData();
        let cellIndex = args.element.cellIndex;
        let count = this.getEventDaysCount(saveObj);
        if (count > 1) {
            count = Math.round(count);
            count--;
            cellIndex = cellIndex - count;
        }
        const start = resetTime(new Date('' + saveObj[this.parent.eventFields.startTime])).getTime();
        const end = resetTime(new Date('' + saveObj[this.parent.eventFields.endTime])).getTime();
        const resIndex = args.groupIndex || 0;
        const isVertical = this.parent.currentView === 'Day' || this.parent.currentView === 'Week' || this.parent.currentView === 'WorkWeek';
        if (this.parent.activeViewOptions.timeScale.enable && isVertical) {
            const dayIndex = saveObj[this.parent.eventFields.startTime].getDay();
            this.createVerticalViewInline(saveObj, dayIndex, resIndex, cellIndex);
        }
        else if (this.parent.currentView === 'Month' || (!this.parent.activeViewOptions.timeScale.enable && isVertical)) {
            this.createMonthViewInline(saveObj, resIndex, start, end);
        }
        else {
            this.createTimelineViewInline(saveObj, start, end, resIndex);
        }
        const inlineSubject = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);
        if (inlineSubject) {
            inlineSubject.focus();
        }
    }
    eventEdit(args) {
        let inlineSubject = args.element.querySelector('.' + INLINE_SUBJECT_CLASS);
        let subject;
        if (inlineSubject) {
            subject = inlineSubject.value;
        }
        else {
            const subEle = args.element.querySelector('.' + SUBJECT_CLASS);
            if (!isNullOrUndefined(subEle)) {
                addClass([subEle], DISABLE_CLASS);
                subject = subEle.innerText;
            }
            else {
                subject = args.data[this.parent.eventFields.subject];
            }
            inlineSubject = createElement('input', { className: INLINE_SUBJECT_CLASS, attrs: { value: subject } });
            if (closest(args.element, '.' + MORE_POPUP_WRAPPER_CLASS)) {
                args.element.insertBefore(inlineSubject, subEle);
            }
            else if (['Agenda', 'MonthAgenda'].indexOf(this.parent.currentView) > -1) {
                let subjectWrap = args.element.querySelector('.' + SUBJECT_WRAP);
                if (isNullOrUndefined(subjectWrap)) {
                    subjectWrap = createElement('div', { className: SUBJECT_WRAP });
                    args.element.prepend(subjectWrap);
                }
                subjectWrap.insertBefore(inlineSubject, subjectWrap.firstChild);
            }
            else {
                args.element.querySelector('.e-appointment-details').prepend(inlineSubject);
            }
            inlineSubject.focus();
        }
        inlineSubject.setSelectionRange(subject.length, subject.length);
    }
    createVerticalViewInline(saveObj, dayIndex, resIndex, daysCount) {
        const count = this.getEventDaysCount(saveObj);
        const verticalEvent = new VerticalEvent(this.parent);
        verticalEvent.initializeValues();
        const index = verticalEvent.dateRender[parseInt(resIndex.toString(), 10)].map((date) => date.getDay()).indexOf(dayIndex);
        if (count >= 1) {
            verticalEvent.allDayElement = [].slice.call(this.parent.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS));
            verticalEvent.slots.push(...this.parent.activeView.renderDates.map((date) => +date));
            const allDayElements = [].slice.call(this.parent.element.querySelectorAll('.' + ALLDAY_APPOINTMENT_CLASS));
            let allDayLevel = 0;
            if (allDayElements.length > 0) {
                allDayLevel = Math.floor(this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS).getBoundingClientRect().height /
                    allDayElements[0].offsetHeight) - 1;
            }
            verticalEvent.allDayLevel = allDayLevel;
            verticalEvent.renderAllDayEvents(saveObj, index, resIndex, daysCount, this.parent.allowInline);
        }
        else {
            verticalEvent.renderNormalEvents(saveObj, index, resIndex, daysCount, this.parent.allowInline);
        }
    }
    createMonthViewInline(saveObj, index, start, end) {
        const count = this.getEventDaysCount(saveObj);
        const saveObject = this.parent.eventBase.cloneEventObject(saveObj, start, end, count, false, false);
        const monthEvent = new MonthEvent(this.parent);
        monthEvent.dateRender = this.parent.activeView.renderDates;
        monthEvent.inlineValue = this.parent.allowInline;
        let renderDates = this.parent.activeView.renderDates;
        let workDays = this.parent.activeViewOptions.workDays;
        let monthCellSelector = '.' + WORK_CELLS_CLASS;
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            monthCellSelector += '[data-group-index="' + index + '"]';
            const resourceData = this.parent.resourceBase.lastResourceLevel[parseInt(index.toString(), 10)];
            renderDates = resourceData.renderDates;
            workDays = resourceData.workDays;
        }
        monthEvent.dateRender = renderDates;
        monthEvent.workCells = [].slice.call(this.parent.element.querySelectorAll(monthCellSelector));
        monthEvent.cellWidth = monthEvent.workCells[0].offsetWidth;
        monthEvent.cellHeight = monthEvent.workCells[0].offsetHeight;
        monthEvent.eventHeight =
            getElementHeightFromClass(this.parent.monthModule.element || monthEvent.element, APPOINTMENT_CLASS);
        monthEvent.getSlotDates(workDays);
        const filteredDates = monthEvent.getRenderedDates(renderDates);
        const spannedEvents = monthEvent.splitEvent(saveObject, filteredDates || renderDates);
        for (const eventData of spannedEvents) {
            monthEvent.renderEvents(eventData, index);
        }
        const inlineSubject = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);
        inlineSubject.focus();
    }
    createTimelineViewInline(saveObj, start, end, resIndex) {
        const count = this.getEventDaysCount(saveObj);
        const saveObject = this.parent.eventBase.cloneEventObject(saveObj, start, end, count, false, false);
        const timelineView = new TimelineEvent(this.parent, this.parent.activeViewOptions.timeScale.enable ? 'hour' : 'day');
        timelineView.dateRender = this.parent.activeView.renderDates;
        timelineView.eventContainers = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));
        const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS);
        timelineView.inlineValue = this.parent.allowInline;
        timelineView.cellWidth = workCell.offsetWidth;
        timelineView.cellHeight = workCell.offsetHeight;
        const dayLength = this.parent.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody tr').length === 0 ?
            0 : this.parent.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody tr')[0].children.length;
        timelineView.slotsPerDay = dayLength / timelineView.dateRender.length;
        timelineView.eventHeight = getElementHeightFromClass(timelineView.element, APPOINTMENT_CLASS);
        timelineView.renderEvents(saveObject, resIndex);
    }
    getEventDaysCount(saveObj) {
        const startDate = saveObj[this.parent.eventFields.startTime];
        const endDate = saveObj[this.parent.eventFields.endTime];
        const daysCount = Math.abs(endDate.getTime() - startDate.getTime()) / MS_PER_DAY;
        return daysCount;
    }
    generateEventData(target) {
        const inlineElement = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);
        const subject = inlineElement ? inlineElement.value : target ? target.innerHTML : '';
        const saveObj = {};
        saveObj[this.parent.eventFields.id] = this.parent.eventBase.getEventMaxID();
        saveObj[this.parent.eventFields.subject] = subject;
        saveObj[this.parent.eventFields.startTime] = this.parent.activeCellsData.startTime;
        saveObj[this.parent.eventFields.endTime] = this.parent.activeCellsData.endTime;
        saveObj[this.parent.eventFields.isAllDay] = this.parent.activeCellsData.isAllDay;
        this.parent.eventWindow.setDefaultValueToObject(saveObj);
        if (this.parent.resourceBase) {
            this.parent.resourceBase.setResourceValues(saveObj, this.parent.activeCellsData.groupIndex);
        }
        return saveObj;
    }
    documentClick() {
        const target = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);
        if (target && target.value !== '') {
            this.inlineCrudActions(target);
        }
        else {
            this.removeInlineAppointmentElement();
        }
    }
    inlineCrudActions(target) {
        if (closest(target, '.' + INLINE_APPOINTMENT_CLASS)) {
            const saveObj = this.generateEventData(target);
            this.parent.addEvent(saveObj);
        }
        else {
            const eventTarget = closest(target, '.' + APPOINTMENT_CLASS);
            const eventDetails = this.parent.getEventDetails(eventTarget);
            eventDetails[this.parent.eventFields.subject] = target.value;
            let currentAction;
            if (eventDetails[this.parent.eventFields.id] === eventDetails[this.parent.eventFields.recurrenceID]) {
                currentAction = 'EditOccurrence';
                eventDetails[this.parent.eventFields.id] = this.parent.eventBase.getEventMaxID();
            }
            this.parent.saveEvent(eventDetails, currentAction);
        }
        this.removeInlineAppointmentElement();
    }
    createInlineAppointmentElement(inlineData) {
        const inlineAppointmentElement = createElement('div', {
            className: APPOINTMENT_CLASS + ' ' + INLINE_APPOINTMENT_CLASS
        });
        const inlineDetails = createElement('div', { className: APPOINTMENT_DETAILS });
        inlineAppointmentElement.appendChild(inlineDetails);
        const inline = createElement('input', { className: INLINE_SUBJECT_CLASS });
        inlineDetails.appendChild(inline);
        if (inlineData) {
            this.parent.eventBase.applyResourceColor(inlineAppointmentElement, inlineData, 'backgroundColor');
        }
        return inlineAppointmentElement;
    }
    removeInlineAppointmentElement() {
        const inlineAppointment = [].slice.call(this.parent.element.querySelectorAll('.' + INLINE_APPOINTMENT_CLASS));
        if (inlineAppointment.length > 0) {
            inlineAppointment.forEach((node) => remove(node));
        }
        const inlineSubject = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);
        if (inlineSubject) {
            const appointmentSubject = closest(inlineSubject, '.' + APPOINTMENT_CLASS);
            const subject = appointmentSubject.querySelector('.' + SUBJECT_CLASS);
            if (!isNullOrUndefined(subject)) {
                removeClass([subject], DISABLE_CLASS);
            }
            remove(inlineSubject);
        }
    }
    destroy() {
        this.parent.off(inlineClick, this.inlineEdit);
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Appointment window field validation
 */
class FieldValidator {
    renderFormValidator(form, rules, element, locale) {
        this.element = element;
        this.formObj = new FormValidator(form, {
            locale: locale,
            customPlacement: (inputElement, error) => {
                this.errorPlacement(inputElement, error);
            },
            rules: rules,
            validationComplete: (args) => {
                this.validationComplete(args);
            },
            focusout: (args) => {
                this.focusOut(args);
            }
        });
    }
    focusOut(args) {
        const target = args.relatedTarget;
        if (target && (target.classList.contains('e-dlg-closeicon-btn') || target.classList.contains('e-close')
            || target.classList.contains(ALLDAY_CELLS_CLASS) || target.classList.contains(HEADER_CELLS_CLASS)
            || target.classList.contains(QUICK_POPUP_EVENT_DETAILS_CLASS) || target.classList.contains(WORK_CELLS_CLASS)
            || target.classList.contains(EVENT_WINDOW_CANCEL_BUTTON_CLASS))) {
            this.ignoreError = true;
        }
        else {
            this.ignoreError = false;
        }
    }
    validationComplete(args) {
        const elem = this.element.querySelector('#' + args.inputName + '_Error');
        if (elem) {
            elem.style.display = (args.status === 'failure') ? '' : 'none';
        }
    }
    errorPlacement(inputElement, error) {
        const id = error.getAttribute('for');
        const elem = this.element.querySelector('#' + id + '_Error');
        if (!elem && !this.ignoreError) {
            this.createTooltip(inputElement, error, id, '');
        }
        if (!isNullOrUndefined(elem)) {
            elem.querySelector('.e-error').innerHTML = error.innerHTML;
        }
    }
    createTooltip(element, error, name, display) {
        let dlgContent;
        let client;
        const inputClient = element.getBoundingClientRect();
        if (this.element.classList.contains(POPUP_WRAPPER_CLASS)) {
            dlgContent = this.element;
            client = this.element.getBoundingClientRect();
        }
        else {
            dlgContent = this.element.querySelector('.e-schedule-dialog .e-dlg-content');
            client = dlgContent.getBoundingClientRect();
        }
        const div = createElement('div', {
            className: 'e-tooltip-wrap e-popup ' + ERROR_VALIDATION_CLASS,
            id: name + '_Error',
            styles: 'display:' + display + ';top:' +
                (inputClient.bottom - client.top + dlgContent.scrollTop + 9) + 'px;left:' +
                (inputClient.left - client.left + dlgContent.scrollLeft + inputClient.width / 2) + 'px;'
        });
        const content = createElement('div', { className: 'e-tip-content' });
        content.appendChild(error);
        const arrow = createElement('div', { className: 'e-arrow-tip e-tip-top' });
        arrow.appendChild(createElement('div', { className: 'e-arrow-tip-outer e-tip-top' }));
        arrow.appendChild(createElement('div', { className: 'e-arrow-tip-inner e-tip-top' }));
        div.appendChild(content);
        div.appendChild(arrow);
        dlgContent.appendChild(div);
        div.style.left = (parseInt(div.style.left, 10) - div.offsetWidth / 2) + 'px';
    }
    destroyToolTip() {
        if (this.element) {
            const elements = [].slice.call(this.element.querySelectorAll('.' + ERROR_VALIDATION_CLASS));
            for (const elem of elements) {
                remove(elem);
            }
        }
        if (this.formObj && this.formObj.element) {
            this.formObj.reset();
        }
    }
    destroy() {
        if (this.formObj && this.formObj.element && !this.formObj.isDestroyed) {
            this.formObj.destroy();
        }
        this.formObj = null;
        this.element = null;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
const EVENT_FIELD = 'e-field';
/**
 * Quick Popups interactions
 */
class QuickPopups {
    constructor(parent) {
        this.isMultipleEventSelect = false;
        this.isCrudAction = false;
        this.parent = parent;
        this.l10n = this.parent.localeObj;
        this.fieldValidator = new FieldValidator();
        this.render();
        this.addEventListener();
    }
    render() {
        this.renderQuickPopup();
        this.renderMorePopup();
        this.renderQuickDialog();
    }
    renderQuickPopup() {
        const quickPopupWrapper = createElement('div', { className: POPUP_WRAPPER_CLASS + ' e-popup-close' });
        if (this.parent.isAdaptive) {
            document.body.appendChild(quickPopupWrapper);
            addClass([quickPopupWrapper], DEVICE_CLASS);
        }
        else {
            this.parent.element.appendChild(quickPopupWrapper);
        }
        this.quickPopup = new Popup(quickPopupWrapper, {
            targetType: (this.parent.isAdaptive ? 'container' : 'relative'),
            enableRtl: this.parent.enableRtl,
            open: this.quickPopupOpen.bind(this),
            close: this.quickPopupClose.bind(this),
            hideAnimation: (this.parent.isAdaptive ? { name: 'ZoomOut' } : { name: 'FadeOut', duration: 150 }),
            showAnimation: (this.parent.isAdaptive ? { name: 'ZoomIn' } : { name: 'FadeIn', duration: 150 }),
            collision: (this.parent.isAdaptive ? { X: 'fit', Y: 'fit' } :
                (this.parent.enableRtl ? { X: 'flip', Y: 'fit' } : { X: 'none', Y: 'fit' })),
            position: (this.parent.isAdaptive || this.parent.enableRtl ? { X: 'left', Y: 'top' } : { X: 'right', Y: 'top' }),
            viewPortElement: (this.parent.isAdaptive ? document.body : this.parent.element),
            zIndex: (this.parent.isAdaptive ? 1004 : 3)
        });
    }
    renderMorePopup() {
        const moreEventPopup = `<div class="${MORE_EVENT_POPUP_CLASS}"><div class="${MORE_EVENT_HEADER_CLASS}">` +
            `<div class="${MORE_EVENT_CLOSE_CLASS}" title="${this.l10n.getConstant('close')}" tabindex="0"></div>` +
            `<div class="${MORE_EVENT_DATE_HEADER_CLASS}"><div class="${MORE_EVENT_HEADER_DAY_CLASS}"></div>` +
            `<div class="${MORE_EVENT_HEADER_DATE_CLASS} ${NAVIGATE_CLASS}" tabindex="0"></div></div></div></div>`;
        const moreEventWrapper = createElement('div', {
            className: MORE_POPUP_WRAPPER_CLASS + ' e-popup-close',
            innerHTML: moreEventPopup
        });
        if (this.parent.isAdaptive) {
            document.body.appendChild(moreEventWrapper);
            addClass([moreEventWrapper], DEVICE_CLASS);
        }
        else {
            this.parent.element.appendChild(moreEventWrapper);
        }
        this.morePopup = new Popup(moreEventWrapper, {
            targetType: (this.parent.isAdaptive ? 'container' : 'relative'),
            enableRtl: this.parent.enableRtl,
            hideAnimation: { name: 'ZoomOut', duration: 300 },
            showAnimation: { name: 'ZoomIn', duration: 300 },
            open: this.morePopupOpen.bind(this),
            close: this.morePopupClose.bind(this),
            collision: (this.parent.isAdaptive ? { X: 'fit', Y: 'fit' } :
                (this.parent.enableRtl ? { X: 'flip', Y: 'fit' } : { X: 'flip', Y: 'flip' })),
            viewPortElement: (this.parent.isAdaptive ? document.body : this.parent.element),
            zIndex: (this.parent.isAdaptive ? 1002 : 2)
        });
        const closeButton = this.morePopup.element.querySelector('.' + MORE_EVENT_CLOSE_CLASS);
        this.renderButton('e-round', ICON + ' ' + CLOSE_ICON_CLASS, false, closeButton, this.closeClick);
        EventHandler.add(this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DATE_CLASS), 'click', this.navigationClick, this);
    }
    renderQuickDialog() {
        const buttonModel = [
            { buttonModel: { cssClass: 'e-quick-alertok e-flat', isPrimary: true }, click: this.dialogButtonClick.bind(this) },
            { buttonModel: { cssClass: 'e-quick-alertcancel e-flat', isPrimary: false }, click: this.dialogButtonClick.bind(this) },
            {
                buttonModel: { cssClass: 'e-quick-dialog-cancel e-disable e-flat', isPrimary: false },
                click: this.dialogButtonClick.bind(this)
            }
        ];
        if (this.parent.eventSettings.editFollowingEvents) {
            const followingSeriesButton = {
                buttonModel: { cssClass: 'e-quick-alertfollowing e-flat', isPrimary: false }, click: this.dialogButtonClick.bind(this)
            };
            buttonModel.splice(1, 0, followingSeriesButton);
        }
        this.quickDialog = new Dialog({
            animationSettings: { effect: 'Zoom' },
            buttons: buttonModel,
            cssClass: QUICK_DIALOG_CLASS,
            closeOnEscape: true,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            beforeClose: this.beforeQuickDialogClose.bind(this),
            isModal: true,
            position: { X: 'center', Y: 'center' },
            showCloseIcon: true,
            target: document.body,
            visible: false,
            width: 'auto'
        });
        const dialogElement = createElement('div', { id: this.parent.element.id + 'QuickDialog' });
        this.parent.element.appendChild(dialogElement);
        this.quickDialog.appendTo(dialogElement);
        const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);
        if (okButton) {
            okButton.setAttribute('aria-label', this.l10n.getConstant('occurrence'));
            okButton.setAttribute('aria-label', okButton.innerHTML);
        }
        const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);
        if (cancelButton) {
            cancelButton.setAttribute('aria-label', this.l10n.getConstant('series'));
            cancelButton.setAttribute('aria-label', cancelButton.innerHTML);
        }
        if (this.quickDialog.element.querySelector('.e-dlg-closeicon-btn')) {
            this.quickDialog.element.querySelector('.e-dlg-closeicon-btn').setAttribute('title', this.l10n.getConstant('close'));
        }
    }
    // eslint-disable-next-line max-len
    renderButton(className, iconName, isDisabled, element, clickEvent) {
        const buttonObj = new Button({
            cssClass: className,
            disabled: isDisabled,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            iconCss: iconName
        });
        buttonObj.appendTo(element);
        EventHandler.add(element, 'click', clickEvent, this);
        removeClass([element], ICON);
    }
    quickDialogClass(action) {
        const classList$$1 = [
            QUICK_DIALOG_OCCURRENCE_CLASS, QUICK_DIALOG_SERIES_CLASS, QUICK_DIALOG_DELETE_CLASS,
            QUICK_DIALOG_CANCEL_CLASS, QUICK_DIALOG_ALERT_BTN_CLASS, DISABLE_CLASS
        ];
        const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);
        const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);
        const followingEventButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_FOLLOWING);
        removeClass([okButton, cancelButton], classList$$1);
        addClass([this.quickDialog.element.querySelector('.' + QUICK_DIALOG_CANCEL_CLASS)], DISABLE_CLASS);
        if (this.parent.eventSettings.editFollowingEvents) {
            addClass([followingEventButton], DISABLE_CLASS);
            removeClass([this.quickDialog.element], FOLLOWING_EVENTS_DIALOG);
        }
        switch (action) {
            case 'Recurrence':
                addClass([okButton], QUICK_DIALOG_OCCURRENCE_CLASS);
                addClass([cancelButton], QUICK_DIALOG_SERIES_CLASS);
                if (this.parent.eventSettings.editFollowingEvents) {
                    removeClass([followingEventButton], DISABLE_CLASS);
                    addClass([this.quickDialog.element], FOLLOWING_EVENTS_DIALOG);
                    addClass([followingEventButton], QUICK_DIALOG_FOLLOWING_EVENTS_CLASS);
                }
                break;
            case 'Delete':
                addClass([okButton], QUICK_DIALOG_DELETE_CLASS);
                addClass([cancelButton], QUICK_DIALOG_CANCEL_CLASS);
                break;
            case 'Alert':
                addClass([okButton], [QUICK_DIALOG_ALERT_OK, QUICK_DIALOG_ALERT_BTN_CLASS]);
                addClass([cancelButton], [QUICK_DIALOG_ALERT_CANCEL, DISABLE_CLASS]);
                break;
        }
    }
    applyFormValidation() {
        const form = this.quickPopup.element.querySelector('.' + FORM_CLASS);
        const rules = {};
        rules[this.parent.eventSettings.fields.subject.name] = this.parent.eventSettings.fields.subject.validation;
        this.fieldValidator.renderFormValidator(form, rules, this.quickPopup.element, this.parent.locale);
    }
    openRecurrenceAlert() {
        const editDeleteOnly = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);
        if (editDeleteOnly) {
            editDeleteOnly.innerHTML = this.l10n.getConstant(this.parent.currentAction === 'Delete' ? 'deleteEvent' : 'editEvent');
            editDeleteOnly.setAttribute('aria-label', editDeleteOnly.innerHTML);
        }
        const editFollowingEventsOnly = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_FOLLOWING);
        if (editFollowingEventsOnly) {
            editFollowingEventsOnly.innerHTML = this.l10n.getConstant('editFollowingEvent');
            editFollowingEventsOnly.setAttribute('aria-label', editFollowingEventsOnly.innerHTML);
        }
        const editDeleteSeries = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);
        if (editDeleteSeries) {
            editDeleteSeries.innerHTML = this.l10n.getConstant(this.parent.currentAction === 'Delete' ? 'deleteSeries' : 'editSeries');
            editDeleteSeries.setAttribute('aria-label', editDeleteSeries.innerHTML);
        }
        this.quickDialog.content = this.l10n.getConstant('editContent');
        this.quickDialog.header = this.l10n.getConstant(this.parent.currentAction === 'Delete' ? 'deleteTitle' : 'editTitle');
        this.quickDialogClass('Recurrence');
        const activeEvent = this.parent.activeEventData.event;
        if (this.parent.eventSettings.editFollowingEvents && this.parent.currentAction === 'EditOccurrence'
            && !isNullOrUndefined(activeEvent[this.parent.eventFields.recurrenceID]) && activeEvent[this.parent.eventFields.recurrenceID]
            !== activeEvent[this.parent.eventFields.id]) {
            const followingEventButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_FOLLOWING);
            addClass([followingEventButton], DISABLE_CLASS);
        }
        this.showQuickDialog('RecurrenceAlert');
    }
    openRecurrenceValidationAlert(type) {
        this.quickDialogClass('Alert');
        const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);
        okButton.innerHTML = this.l10n.getConstant('ok');
        okButton.setAttribute('aria-label', okButton.innerHTML);
        const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);
        cancelButton.innerHTML = this.l10n.getConstant('cancel');
        cancelButton.setAttribute('aria-label', cancelButton.innerHTML);
        this.quickDialog.header = this.l10n.getConstant('alert');
        let dialogCancel;
        switch (type) {
            case 'wrongPattern':
                addClass([cancelButton], DISABLE_CLASS);
                this.quickDialog.content = this.l10n.getConstant('wrongPattern');
                break;
            case 'createError':
                addClass([cancelButton], DISABLE_CLASS);
                this.quickDialog.content = this.l10n.getConstant('createError');
                break;
            case 'sameDayAlert':
                addClass([cancelButton], DISABLE_CLASS);
                this.quickDialog.content = this.l10n.getConstant('sameDayAlert');
                break;
            case 'seriesChangeAlert':
                dialogCancel = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_CANCEL_CLASS);
                removeClass([cancelButton, dialogCancel], DISABLE_CLASS);
                this.quickDialog.content = this.l10n.getConstant('seriesChangeAlert');
                okButton.innerHTML = this.l10n.getConstant('yes');
                cancelButton.innerHTML = this.l10n.getConstant('no');
                dialogCancel.innerHTML = this.l10n.getConstant('cancel');
                break;
            case 'occurrenceAlert':
                addClass([cancelButton], DISABLE_CLASS);
                this.quickDialog.content = this.l10n.getConstant('occurenceAlert');
                break;
        }
        if ((!this.parent.enableRecurrenceValidation && type === 'wrongPattern') || this.parent.enableRecurrenceValidation) {
            this.showQuickDialog('RecurrenceValidationAlert');
        }
    }
    openDeleteAlert() {
        if (this.parent.activeViewOptions.readonly) {
            return;
        }
        const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);
        if (okButton) {
            okButton.innerHTML = this.l10n.getConstant('delete');
            okButton.setAttribute('aria-label', okButton.innerHTML);
        }
        const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);
        if (cancelButton) {
            cancelButton.innerHTML = this.l10n.getConstant('cancel');
            cancelButton.setAttribute('aria-label', cancelButton.innerHTML);
        }
        this.quickDialog.content = (this.parent.activeEventData.event.length > 1) ?
            this.l10n.getConstant('deleteMultipleContent') : this.l10n.getConstant('deleteContent');
        this.quickDialog.header = (this.parent.activeEventData.event.length > 1) ?
            this.l10n.getConstant('deleteMultipleEvent') : this.l10n.getConstant('deleteEvent');
        this.quickDialogClass('Delete');
        this.showQuickDialog('DeleteAlert');
    }
    openValidationError(type, eventData) {
        this.quickDialog.header = this.l10n.getConstant('alert');
        this.quickDialog.content = this.l10n.getConstant(type);
        const okButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_OK);
        if (okButton) {
            okButton.innerHTML = this.l10n.getConstant('ok');
            okButton.setAttribute('aria-label', okButton.innerHTML);
        }
        const cancelButton = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);
        if (cancelButton) {
            cancelButton.innerHTML = this.l10n.getConstant('cancel');
            okButton.setAttribute('aria-label', cancelButton.innerHTML);
        }
        this.quickDialogClass('Alert');
        this.showQuickDialog('ValidationAlert', eventData);
    }
    showQuickDialog(popupType, eventData) {
        this.quickDialog.dataBind();
        const eventProp = {
            type: popupType, cancel: false, element: this.quickDialog.element,
            data: extend({}, (eventData || this.parent.activeEventData.event), null, true)
        };
        this.parent.trigger(popupOpen, eventProp, (popupArgs) => {
            if (!popupArgs.cancel) {
                this.quickDialog.show();
            }
        });
    }
    createMoreEventList(eventCollection, groupOrder, groupIndex) {
        const fields = this.parent.eventFields;
        const moreEventContentEle = createElement('div', { className: MORE_EVENT_CONTENT_CLASS });
        let moreEventWrapperEle = createElement('div', { className: MORE_EVENT_WRAPPER_CLASS });
        if (eventCollection.length === 0) {
            moreEventWrapperEle = createElement('div', {
                className: MORE_EVENT_CONTENT_CLASS,
                innerHTML: this.l10n.getConstant('emptyContainer')
            });
        }
        else {
            for (const eventData of eventCollection) {
                const eventText = (eventData[fields.subject] || this.parent.eventSettings.fields.subject.default
                    || this.parent.localeObj.getConstant('addTitle'));
                const appointmentElement = createElement('div', {
                    className: APPOINTMENT_CLASS,
                    attrs: {
                        'data-id': '' + eventData[fields.id],
                        'data-guid': eventData.Guid, 'role': 'button', 'tabindex': '0',
                        'aria-disabled': this.parent.eventBase.getReadonlyAttribute(eventData),
                        'aria-label': this.parent.getAnnouncementString(eventData)
                    }
                });
                let templateElement;
                if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {
                    const tempId = this.parent.element.id + '_' + this.parent.activeViewOptions.eventTemplateName + 'eventTemplate';
                    templateElement = this.parent.getAppointmentTemplate()(eventData, this.parent, 'eventTemplate', tempId, false);
                    append(templateElement, appointmentElement);
                }
                else {
                    appointmentElement.appendChild(createElement('div', { className: SUBJECT_CLASS }));
                    this.parent.sanitize(eventText, appointmentElement.firstElementChild);
                }
                if (!isNullOrUndefined(groupIndex)) {
                    appointmentElement.setAttribute('data-group-index', groupIndex);
                }
                if (!isNullOrUndefined(eventData[fields.recurrenceRule])) {
                    const iconClass = (eventData[fields.id] === eventData[fields.recurrenceID]) ?
                        EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;
                    appointmentElement.appendChild(createElement('div', { className: ICON + ' ' + iconClass }));
                }
                const args = {
                    data: extend({}, eventData, null, true),
                    element: appointmentElement, cancel: false
                };
                this.parent.trigger(eventRendered, args, (eventArgs) => {
                    if (!eventArgs.cancel) {
                        moreEventWrapperEle.appendChild(appointmentElement);
                        const isPreventCrud = this.parent.isAdaptive || this.parent.currentView === 'Year';
                        this.parent.eventBase.wireAppointmentEvents(appointmentElement, eventData, isPreventCrud);
                        this.parent.eventBase.applyResourceColor(appointmentElement, eventData, 'backgroundColor', groupOrder);
                    }
                });
            }
        }
        moreEventContentEle.appendChild(moreEventWrapperEle);
        return moreEventContentEle;
    }
    tapHoldEventPopup(e) {
        const target = closest(e.target, '.' + APPOINTMENT_CLASS);
        this.isMultipleEventSelect = false;
        this.parent.selectedElements = [];
        this.isMultipleEventSelect = true;
        this.parent.eventBase.getSelectedEventElements(target);
        this.parent.activeEventData = this.parent.eventBase.getSelectedEvents();
        const guid = target.getAttribute('data-guid');
        const eventObj = this.parent.eventBase.getEventByGuid(guid);
        if (isNullOrUndefined(eventObj)) {
            return;
        }
        const eventTitle = (eventObj[this.parent.eventFields.subject] || this.l10n.getConstant('noTitle'));
        const eventTemplate = `<div class="${MULTIPLE_EVENT_POPUP_CLASS}"><div class="${POPUP_HEADER_CLASS}">` +
            `<button class="${CLOSE_CLASS}" title="${this.l10n.getConstant('close')}"></button>` +
            `<div class="${SUBJECT_CLASS}">${eventTitle}</div>` +
            `<button class="${EDIT_CLASS}" title="${this.l10n.getConstant('edit')}"></button>` +
            `<button class="${DELETE_CLASS}" title="${this.l10n.getConstant('delete')}"></button></div></div>`;
        this.quickPopup.element.innerHTML = eventTemplate;
        const closeIcon = this.quickPopup.element.querySelector('.' + CLOSE_CLASS);
        this.renderButton('e-flat e-round e-small', ICON + ' ' + CLOSE_ICON_CLASS, false, closeIcon, this.closeClick);
        const readonly = this.parent.activeViewOptions.readonly || eventObj[this.parent.eventFields.isReadonly];
        const editAction = !this.parent.eventSettings.allowEditing || readonly;
        const deleteAction = !this.parent.eventSettings.allowDeleting || readonly;
        const editIcon = this.quickPopup.element.querySelector('.' + EDIT_CLASS);
        if (editIcon) {
            this.renderButton('e-flat e-round e-small', ICON + ' ' + EDIT_ICON_CLASS, editAction, editIcon, this.editClick);
        }
        const deleteIcon = this.quickPopup.element.querySelector('.' + DELETE_CLASS);
        if (deleteIcon) {
            this.renderButton('e-flat e-round e-small', ICON + ' ' + DELETE_ICON_CLASS, deleteAction, deleteIcon, this.deleteClick);
        }
        this.beforeQuickPopupOpen(target, this.parent.eventBase.getPageCoordinates(e));
    }
    isCellBlocked(args) {
        const tempObj = {};
        tempObj[this.parent.eventFields.startTime] = this.parent.activeCellsData.startTime;
        tempObj[this.parent.eventFields.endTime] = this.parent.activeCellsData.endTime;
        tempObj[this.parent.eventFields.isAllDay] = this.parent.activeCellsData.isAllDay;
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            const targetCell = args.element instanceof Array ? args.element[0] : args.element;
            const groupIndex = parseInt(targetCell.getAttribute('data-group-index'), 10);
            this.parent.resourceBase.setResourceValues(tempObj, isNaN(groupIndex) ? null : groupIndex);
        }
        return this.parent.eventBase.isBlockRange(tempObj);
    }
    cellClick(args) {
        const date = new Date(args.startTime.getTime());
        if (!this.parent.showQuickInfo || !this.parent.eventSettings.allowAdding ||
            this.parent.currentView === 'MonthAgenda' || this.isCellBlocked(args) ||
            !this.parent.isMinMaxDate(new Date(date.setHours(0, 0, 0, 0)))) {
            this.quickPopupHide();
            return;
        }
        const targetEle = !isNullOrUndefined(args.event) ? args.event.target : args.element;
        if (this.parent.isAdaptive) {
            this.quickPopupHide();
            let newEventClone = this.parent.element.querySelector('.' + NEW_EVENT_CLASS);
            if (isNullOrUndefined(newEventClone)) {
                newEventClone = createElement('div', {
                    className: NEW_EVENT_CLASS,
                    innerHTML: `<div class="e-title">+ ${this.l10n.getConstant('newEvent')}</div>`
                });
            }
            const targetCell = closest(targetEle, '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS);
            if (targetCell) {
                targetCell.appendChild(newEventClone);
            }
            return;
        }
        const target = closest(targetEle, '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' +
            HEADER_CELLS_CLASS);
        if (isNullOrUndefined(target) || targetEle.classList.contains(MORE_INDICATOR_CLASS)) {
            return;
        }
        const isSameTarget = this.quickPopup.relateTo === target;
        if (isSameTarget && this.quickPopup.element.classList.contains(POPUP_OPEN)) {
            const subjectElement = this.quickPopup.element.querySelector('.' + SUBJECT_CLASS);
            if (subjectElement) {
                subjectElement.focus();
            }
            return;
        }
        else if (this.quickPopup.element) {
            this.destroyPopupButtons('quickPopup');
        }
        const temp = {};
        temp[this.parent.eventFields.startTime] = this.parent.activeCellsData.startTime;
        temp[this.parent.eventFields.endTime] = this.parent.activeCellsData.endTime;
        temp[this.parent.eventFields.isAllDay] = this.parent.activeCellsData.isAllDay;
        const quickCellPopup = createElement('div', { className: CELL_POPUP_CLASS });
        quickCellPopup.appendChild(this.getPopupHeader('Cell', temp));
        quickCellPopup.appendChild(this.getPopupContent('Cell', args, temp));
        quickCellPopup.appendChild(this.getPopupFooter('Cell', temp));
        const subjectElement = quickCellPopup.querySelector('.' + SUBJECT_CLASS);
        if (subjectElement) {
            Input.createInput({ element: subjectElement, properties: { placeholder: this.l10n.getConstant('addTitle') } });
        }
        if (!isNullOrUndefined(this.parent.eventSettings.fields.subject.default)) {
            subjectElement.value = this.parent.eventSettings.fields.subject.default;
        }
        const closeIcon = quickCellPopup.querySelector('.' + CLOSE_CLASS);
        if (closeIcon) {
            this.renderButton('e-flat e-round e-small', ICON + ' ' + CLOSE_ICON_CLASS, false, closeIcon, this.popupClose);
        }
        const moreButton = quickCellPopup.querySelector('.' + QUICK_POPUP_EVENT_DETAILS_CLASS);
        if (moreButton) {
            this.renderButton('e-flat', '', false, moreButton, this.detailsClick);
        }
        const saveButton = quickCellPopup.querySelector('.' + EVENT_CREATE_CLASS);
        if (saveButton) {
            this.renderButton('e-flat e-primary', '', this.parent.activeViewOptions.readonly, saveButton, this.saveClick);
        }
        if (this.morePopup) {
            this.morePopup.hide();
        }
        this.quickPopup.content = quickCellPopup;
        this.quickPopup.relateTo = target;
        this.quickPopup.dataBind();
        this.beforeQuickPopupOpen(target, this.parent.eventBase.getPageCoordinates(args.event));
    }
    isSameEventClick(events) {
        const isSameTarget = this.quickPopup.relateTo === closest(events.element, '.' + APPOINTMENT_CLASS);
        if (isSameTarget && this.quickPopup.element.classList.contains(POPUP_OPEN)) {
            const editIcon = this.quickPopup.element.querySelector('.' + EDIT_CLASS);
            if (editIcon) {
                editIcon.focus();
            }
            if (!this.parent.isAdaptive) {
                const editButton = this.quickPopup.element.querySelector('.' + EDIT_EVENT_CLASS);
                if (editButton) {
                    editButton.focus();
                }
            }
            return true;
        }
        return false;
    }
    isQuickTemplate(type) {
        return this.parent.quickInfoTemplates.templateType === 'Both' || this.parent.quickInfoTemplates.templateType === type;
    }
    eventClick(events) {
        if (this.parent.eventTooltip) {
            this.parent.eventTooltip.close();
        }
        if (!this.parent.showQuickInfo) {
            return;
        }
        if (this.parent.isAdaptive && this.isMultipleEventSelect) {
            this.updateTapHoldEventPopup(closest(events.element, '.' + APPOINTMENT_CLASS));
        }
        else {
            const isSameTarget = this.isSameEventClick(events);
            this.parent.selectedElements = [];
            if (isSameTarget) {
                return;
            }
            else if (this.quickPopup.element) {
                this.destroyPopupButtons('quickPopup');
            }
            const eventData = events.event;
            const quickEventPopup = createElement('div', { className: EVENT_POPUP_CLASS });
            quickEventPopup.appendChild(this.getPopupHeader('Event', eventData));
            quickEventPopup.appendChild(this.getPopupContent('Event', events, eventData));
            quickEventPopup.appendChild(this.getPopupFooter('Event', eventData));
            const readonly = this.parent.activeViewOptions.readonly || eventData[this.parent.eventFields.isReadonly];
            const editAction = !this.parent.eventSettings.allowEditing || readonly;
            const deleteAction = !this.parent.eventSettings.allowDeleting || readonly;
            const editIcon = quickEventPopup.querySelector('.' + EDIT_CLASS);
            const buttonClass = 'e-flat e-round e-small';
            if (editIcon) {
                this.renderButton(buttonClass, ICON + ' ' + EDIT_ICON_CLASS, editAction, editIcon, this.editClick);
            }
            const deleteIcon = quickEventPopup.querySelector('.' + DELETE_CLASS);
            if (deleteIcon) {
                this.renderButton(buttonClass, ICON + ' ' + DELETE_ICON_CLASS, deleteAction, deleteIcon, this.deleteClick);
            }
            const closeIcon = quickEventPopup.querySelector('.' + CLOSE_CLASS);
            if (closeIcon) {
                this.renderButton(buttonClass, ICON + ' ' + CLOSE_ICON_CLASS, false, closeIcon, this.popupClose);
            }
            const editButton = quickEventPopup.querySelector('.' + EDIT_EVENT_CLASS);
            if (editButton) {
                this.renderButton('e-flat e-primary', '', editAction, editButton, this.editClick);
            }
            const deleteButton = quickEventPopup.querySelector('.' + DELETE_EVENT_CLASS);
            if (deleteButton) {
                this.renderButton('e-flat', '', deleteAction, deleteButton, this.deleteClick);
            }
            if (this.morePopup && !closest(events.element, '.' + MORE_EVENT_WRAPPER_CLASS)) {
                this.morePopup.hide();
            }
            this.quickPopup.content = quickEventPopup;
            this.quickPopup.relateTo = this.parent.isAdaptive ? document.body :
                closest(events.element, '.' + APPOINTMENT_CLASS);
            this.quickPopup.dataBind();
            this.beforeQuickPopupOpen(events.element, this.parent.eventBase.getPageCoordinates(events.originalEvent));
        }
    }
    getPopupHeader(headerType, headerData) {
        const headerTemplate = createElement('div', { className: POPUP_HEADER_CLASS });
        if (this.isQuickTemplate(headerType) && this.parent.quickInfoTemplates.header) {
            const headerArgs = extend({}, headerData, { elementType: headerType.toLowerCase() }, true);
            const templateId = this.parent.element.id;
            const headerTemp = [].slice.call(this.parent.getQuickInfoTemplatesHeader()(headerArgs, this.parent, 'header', templateId + '_headerTemplate', false));
            append([].slice.call(headerTemp), headerTemplate);
        }
        else {
            let header;
            let args;
            switch (headerType) {
                case 'Cell':
                    header = `<div class="${POPUP_HEADER_ICON_WRAPPER}"><button class="${CLOSE_CLASS}" title=` +
                        `"${this.l10n.getConstant('close')}"></button></div>`;
                    break;
                case 'Event':
                    args = this.getFormattedString(headerData);
                    header = `<div class="${POPUP_HEADER_ICON_WRAPPER}">` +
                        `<button class="${EDIT_CLASS + ' ' + ICON}" title="${this.l10n.getConstant('edit')}"></button>` +
                        `<button class="${DELETE_CLASS + ' ' + ICON}" title="${this.l10n.getConstant('delete')}"></button>` +
                        `<button class="${CLOSE_CLASS}" title="${this.l10n.getConstant('close')}"></button></div>` +
                        `<div class="${SUBJECT_WRAP}"><div class="${SUBJECT_CLASS} ${TEXT_ELLIPSIS}" ` +
                        `title="${args.eventSubject ? args.eventSubject.replaceAll('"', '\'') : args.eventSubject}"></div></div >`;
                    break;
            }
            const templateWrapper = createElement('div', { innerHTML: header });
            if (headerType === 'Event') {
                const subjectText = templateWrapper.querySelector('.' + SUBJECT_CLASS);
                this.parent.sanitize(args.eventSubject, subjectText);
            }
            append([].slice.call(templateWrapper.childNodes), headerTemplate);
        }
        return headerTemplate;
    }
    getPopupContent(type, args, data) {
        const contentTemplate = createElement('div', { className: POPUP_CONTENT_CLASS });
        if (this.isQuickTemplate(type) && this.parent.quickInfoTemplates.content) {
            const contentArgs = extend({}, data, { elementType: type.toLowerCase() }, true);
            const templateId = this.parent.element.id;
            const contentTemp = [].slice.call(this.parent.getQuickInfoTemplatesContent()(contentArgs, this.parent, 'content', templateId + '_contentTemplate', false));
            append([].slice.call(contentTemp), contentTemplate);
        }
        else {
            let content;
            let cellDetails;
            let argsData;
            const resourceText = this.getResourceText(args, type.toLowerCase());
            switch (type) {
                case 'Cell':
                    cellDetails = this.getFormattedString(data);
                    content = `<table class="${POPUP_TABLE_CLASS}"><tbody><tr><td><form class="${FORM_CLASS}" onsubmit=` +
                        `"return false;"><input class="${SUBJECT_CLASS} ${EVENT_FIELD}" type="text" name=` +
                        `"${this.parent.eventFields.subject}" /></form></td></tr><tr><td><div class="${DATE_TIME_CLASS}">` +
                        `<div class="${DATE_TIME_ICON_CLASS} ${ICON}"></div><div class="${DATE_TIME_DETAILS_CLASS} ` +
                        `${TEXT_ELLIPSIS}">${cellDetails.details}</div></div>` +
                        `${this.parent.activeViewOptions.group.resources.length > 0 ? `<div class="${RESOURCE_CLASS}">` +
                            `<div class="${RESOURCE_ICON_CLASS} ${ICON} "></div><div class="${RESOURCE_DETAILS_CLASS} ` +
                            `${TEXT_ELLIPSIS}"></div></div>` : ''}</td></tr></tbody></table>`;
                    break;
                case 'Event':
                    argsData = this.getFormattedString(data);
                    content = '<div class="' + DATE_TIME_CLASS + '"><div class="' + DATE_TIME_ICON_CLASS + ' ' + ICON +
                        '"></div><div class="' + DATE_TIME_WRAPPER_CLASS + ' ' + TEXT_ELLIPSIS + '"><div class="' +
                        DATE_TIME_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '">' + argsData.details + '</div>';
                    if (data[this.parent.eventFields.recurrenceRule]) {
                        content += '<div class="' + RECURRENCE_SUMMARY_CLASS + ' ' + TEXT_ELLIPSIS + '">' +
                            this.getRecurrenceSummary(data) + '</div>';
                    }
                    content += '</div></div>';
                    if (data[this.parent.eventFields.location]) {
                        content += '<div class="' + LOCATION_CLASS + '"><div class="' + LOCATION_ICON_CLASS + ' ' +
                            ICON + '"></div><div class="' + LOCATION_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '"></div></div>';
                    }
                    if (data[this.parent.eventFields.startTimezone] || data[this.parent.eventFields.endTimezone]) {
                        content += '<div class="' + TIME_ZONE_CLASS + '"><div class="' + TIME_ZONE_ICON_CLASS + ' ' + ICON +
                            '"></div><div class="' + TIME_ZONE_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '">' +
                            this.getTimezone(data) + '</div></div>';
                    }
                    if (data[this.parent.eventFields.description]) {
                        content += '<div class="' + DESCRIPTION_CLASS + '"><div class="' + DESCRIPTION_ICON_CLASS + ' ' + ICON +
                            '"></div><div class="' + DESCRIPTION_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '"></div></div>';
                    }
                    if (this.parent.resourceCollection.length > 0) {
                        content += '<div class="' + RESOURCE_CLASS + '"><div class="' + RESOURCE_ICON_CLASS + ' ' + ICON +
                            '"></div><div class="' + RESOURCE_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS + '"></div></div>';
                    }
                    break;
            }
            const templateWrapper = createElement('div', { innerHTML: content });
            if (data[this.parent.eventFields.location]) {
                const locationDetails = templateWrapper.querySelector('.' + LOCATION_DETAILS_CLASS);
                if (!isNullOrUndefined(locationDetails)) {
                    this.parent.sanitize(data[this.parent.eventFields.location], locationDetails);
                }
            }
            if (data[this.parent.eventFields.description]) {
                const descriptionDetails = templateWrapper.querySelector('.' + DESCRIPTION_DETAILS_CLASS);
                if (!isNullOrUndefined(descriptionDetails)) {
                    this.parent.sanitize(data[this.parent.eventFields.description], descriptionDetails);
                }
            }
            if (resourceText) {
                const resourceDetails = templateWrapper.querySelector('.' + RESOURCE_DETAILS_CLASS);
                if (!isNullOrUndefined(resourceDetails)) {
                    this.parent.sanitize(resourceText, resourceDetails);
                }
            }
            append([].slice.call(templateWrapper.childNodes), contentTemplate);
        }
        return contentTemplate;
    }
    getPopupFooter(footerType, footerData) {
        const footerTemplate = createElement('div', { className: POPUP_FOOTER_CLASS });
        if (this.isQuickTemplate(footerType) && this.parent.quickInfoTemplates.footer) {
            const footerArgs = extend({}, footerData, { elementType: footerType.toLowerCase() }, true);
            const templateId = this.parent.element.id;
            const footerTemp = [].slice.call(this.parent.getQuickInfoTemplatesFooter()(footerArgs, this.parent, 'footer', templateId + '_footerTemplate', false));
            append([].slice.call(footerTemp), footerTemplate);
        }
        else {
            let footer;
            switch (footerType) {
                case 'Cell':
                    footer = `<button class="${QUICK_POPUP_EVENT_DETAILS_CLASS + ' ' + TEXT_ELLIPSIS}" title=` +
                        `"${this.l10n.getConstant('moreDetails')}">${this.l10n.getConstant('moreDetails')}</button>` +
                        `<button class="${EVENT_CREATE_CLASS} ${TEXT_ELLIPSIS}" title="${this.l10n.getConstant('save')}">` +
                        `${this.l10n.getConstant('save')}</button>`;
                    break;
                case 'Event':
                    footer = `${this.parent.isAdaptive ? '' : `<button class="${EDIT_EVENT_CLASS} ` +
                        `${TEXT_ELLIPSIS}" title="${this.l10n.getConstant('edit')}">${this.l10n.getConstant('edit')}</button>` +
                        `<button class="${DELETE_EVENT_CLASS} ${TEXT_ELLIPSIS}" title="${this.l10n.getConstant('delete')}">` +
                        `${this.l10n.getConstant('delete')}</button>`}`;
                    break;
            }
            const templateWrapper = createElement('div', { innerHTML: footer });
            append([].slice.call(templateWrapper.childNodes), footerTemplate);
        }
        return footerTemplate;
    }
    getResourceText(args, type) {
        if (this.parent.resourceCollection.length === 0) {
            return null;
        }
        let resourceValue = '';
        if (this.parent.activeViewOptions.group.resources.length === 0) {
            const resourceCollection = this.parent.resourceBase.resourceCollection.slice(-1)[0];
            const resourceData = resourceCollection.dataSource;
            if (type === 'event') {
                const eventData = args.event;
                for (const data of resourceData) {
                    const resourceId = eventData[resourceCollection.field];
                    if (resourceId instanceof Array) {
                        if (resourceId.indexOf(data[resourceCollection.idField]) > -1) {
                            const id = resourceId[resourceId.indexOf(data[resourceCollection.idField])];
                            const resource = resourceData.filter((e) => e[resourceCollection.idField] === id)[0];
                            resourceValue += (resourceValue === '') ? resource[resourceCollection.textField] :
                                ', ' + resource[resourceCollection.textField];
                        }
                    }
                    else if (data[resourceCollection.idField] === resourceId) {
                        resourceValue = data[resourceCollection.textField].toString();
                    }
                }
            }
            else {
                resourceValue = resourceData[0][resourceCollection.textField].toString();
            }
        }
        else {
            if (type === 'event') {
                const eventData = args.event;
                let resourceData;
                let lastResource;
                for (let i = this.parent.resourceBase.resourceCollection.length - 1; i >= 0; i--) {
                    resourceData = eventData[this.parent.resourceBase.resourceCollection[parseInt(i.toString(), 10)].field];
                    if (!isNullOrUndefined(resourceData)) {
                        lastResource = this.parent.resourceBase.resourceCollection[parseInt(i.toString(), 10)];
                        break;
                    }
                }
                if (!Array.isArray(resourceData)) {
                    resourceData = [resourceData];
                }
                const resNames = [];
                const lastResourceData = lastResource.dataSource;
                resourceData.forEach((value) => {
                    let text;
                    const i = findIndexInData(lastResourceData, lastResource.idField, value);
                    if (i > -1) {
                        text = lastResourceData[parseInt(i.toString(), 10)][lastResource.textField];
                    }
                    if (text) {
                        resNames.push(text);
                    }
                });
                resourceValue = resNames.join(', ');
            }
            else {
                const argsData = args;
                const groupIndex = !isNullOrUndefined(argsData.groupIndex) ? argsData.groupIndex : 0;
                const resourceDetails = this.parent.resourceBase.lastResourceLevel[parseInt(groupIndex.toString(), 10)];
                resourceValue = resourceDetails.resourceData[resourceDetails.resource.textField];
            }
        }
        return resourceValue;
    }
    getFormattedString(eventData) {
        const fields = this.parent.eventFields;
        const eventSubject = (eventData[fields.subject] || this.l10n.getConstant('noTitle'));
        const startDate = eventData[fields.startTime];
        const endDate = eventData[fields.endTime];
        const startDateDetails = this.getDateFormat(startDate, 'long');
        const endDateDetails = (eventData[fields.isAllDay] && endDate.getHours() === 0 && endDate.getMinutes() === 0) ?
            this.getDateFormat(addDays(new Date(endDate.getTime()), -1), 'long') :
            this.getDateFormat(endDate, 'long');
        const startTimeDetail = this.parent.getTimeString(startDate);
        const endTimeDetail = this.parent.getTimeString(endDate);
        let details = '';
        const spanLength = endDate.getDate() !== startDate.getDate() &&
            (endDate.getTime() - startDate.getTime()) / (60 * 60 * 1000) < 24 ? 1 : 0;
        if (eventData[fields.isAllDay]) {
            details = startDateDetails + ' (' + this.l10n.getConstant('allDay') + ')';
            if (((getUniversalTime(endDate) - getUniversalTime(startDate)) / MS_PER_DAY) > 1) {
                details += '&nbsp;-&nbsp;' + endDateDetails + ' (' + this.l10n.getConstant('allDay') + ')';
            }
        }
        else if ((((getUniversalTime(endDate) - getUniversalTime(startDate)) / MS_PER_DAY) >= 1) || spanLength > 0) {
            details = startDateDetails + ' (' + startTimeDetail + ')' + '&nbsp;-&nbsp;' + endDateDetails + ' (' + endTimeDetail + ')';
        }
        else {
            details = startDateDetails + ' (' + (startTimeDetail + '&nbsp;-&nbsp;' + endTimeDetail) + ')';
        }
        return { eventSubject: eventSubject, details: details };
    }
    moreEventClick(data, endDate, groupIndex) {
        this.quickPopupHide(true);
        const moreEventContentEle = this.morePopup.element.querySelector('.' + MORE_EVENT_CONTENT_CLASS);
        if (moreEventContentEle) {
            remove(moreEventContentEle);
        }
        const selectedDate = ((data.date).getTime()).toString();
        const target = closest(data.element, '.' + MORE_INDICATOR_CLASS + ',.' + WORK_CELLS_CLASS);
        const day = this.parent.globalize.formatDate(data.date, { format: 'E', calendar: this.parent.getCalendarMode() });
        this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DAY_CLASS).innerHTML = capitalizeFirstWord(day, 'single');
        const dateElement = this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DATE_CLASS);
        dateElement.innerHTML = this.getDateFormat(data.date, 'd');
        dateElement.setAttribute('data-date', selectedDate);
        dateElement.setAttribute('data-end-date', endDate.getTime().toString());
        let groupOrder;
        if (!isNullOrUndefined(groupIndex)) {
            dateElement.setAttribute('data-group-index', groupIndex);
            groupOrder = this.parent.resourceBase.lastResourceLevel[parseInt(groupIndex, 10)].groupOrder;
        }
        const moreEventElements = this.createMoreEventList(data.event, groupOrder, groupIndex);
        this.morePopup.element.querySelector('.' + MORE_EVENT_POPUP_CLASS).appendChild(moreEventElements);
        removeClass(this.morePopup.element.querySelector('.' + MORE_EVENT_DATE_HEADER_CLASS).childNodes, CURRENTDATE_CLASS);
        if (resetTime(data.date).getTime() === resetTime(this.parent.getCurrentTime()).getTime()) {
            addClass(this.morePopup.element.querySelector('.' + MORE_EVENT_DATE_HEADER_CLASS).childNodes, CURRENTDATE_CLASS);
        }
        if (!this.parent.isAdaptive) {
            if (this.parent.currentView.indexOf('Timeline') !== -1) {
                const gIndex = target.getAttribute('data-group-index');
                const startDate = new Date(parseInt(target.getAttribute('data-start-date'), 10));
                startDate.setHours(startDate.getHours(), startDate.getMinutes(), 0);
                const tdDate = startDate.getTime().toString();
                if (isNullOrUndefined(gIndex)) {
                    this.morePopup.relateTo = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS +
                        ' tbody tr td[data-date="' + tdDate + '"]');
                }
                else {
                    this.morePopup.relateTo = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS +
                        ' tbody tr td[data-group-index="' + gIndex + '"][data-date="' + tdDate + '"]');
                    if (isNullOrUndefined(this.morePopup.relateTo)) {
                        const workCells = [].slice.call(this.parent.element.querySelectorAll('.' + CONTENT_WRAP_CLASS +
                            ' tbody tr td[data-group-index="' + gIndex + '"]'));
                        for (let i = 0; i < workCells.length; i++) {
                            const date = workCells[parseInt(i.toString(), 10)].getAttribute('data-date');
                            if (date < tdDate) {
                                this.morePopup.relateTo = workCells[parseInt(i.toString(), 10)];
                            }
                        }
                    }
                }
            }
            else {
                this.morePopup.relateTo = closest(target, '.' + WORK_CELLS_CLASS);
            }
        }
        this.parent.renderTemplates(() => {
            const eventProp = {
                type: 'EventContainer', cancel: false,
                element: this.morePopup.element, data: data
            };
            this.parent.trigger(popupOpen, eventProp, (popupArgs) => {
                if (!popupArgs.cancel) {
                    this.morePopup.show();
                }
            });
        });
    }
    saveClick(event) {
        this.applyFormValidation();
        this.dialogEvent = event;
        this.isCrudAction = true;
        this.quickPopupHide();
    }
    detailsClick(event) {
        const subjectEle = this.quickPopup.element.querySelector('.' + SUBJECT_CLASS);
        if (subjectEle && subjectEle.value !== '') {
            extend(this.parent.activeCellsData, { subject: subjectEle.value });
        }
        this.dialogEvent = event;
        this.isCrudAction = false;
        this.fieldValidator.destroyToolTip();
        this.quickPopupHide();
        this.parent.eventWindow.openEditor(this.parent.activeCellsData, 'Add');
    }
    editClick(event) {
        this.dialogEvent = event;
        this.quickPopupHide(true);
        const data = this.parent.activeEventData.event;
        this.parent.currentAction = 'EditSeries';
        if (!isNullOrUndefined(data[this.parent.eventFields.recurrenceRule])) {
            this.parent.currentAction = 'EditOccurrence';
            this.openRecurrenceAlert();
        }
        else {
            this.parent.eventWindow.openEditor(data, this.parent.currentAction);
        }
    }
    deleteClick(event) {
        this.dialogEvent = event;
        this.quickPopupHide(true);
        this.parent.currentAction = 'Delete';
        if (this.parent.activeEventData.event[this.parent.eventFields.recurrenceRule]) {
            this.openRecurrenceAlert();
        }
        else {
            this.openDeleteAlert();
        }
    }
    updateMoreEventContent() {
        if (this.morePopup.element.classList.contains('e-popup-close')) {
            return;
        }
        const moreEventContentEle = this.morePopup.element.querySelector('.' + MORE_EVENT_CONTENT_CLASS);
        if (moreEventContentEle) {
            remove(moreEventContentEle);
        }
        const dateElement = this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DATE_CLASS);
        const startDate = new Date(parseInt(dateElement.getAttribute('data-date'), 10));
        const endDate = new Date(parseInt(dateElement.getAttribute('data-end-date'), 10));
        const groupIndex = dateElement.getAttribute('data-group-index');
        let data;
        let groupOrder;
        if (!isNullOrUndefined(groupIndex)) {
            data = this.parent.resourceBase.lastResourceLevel[parseInt(groupIndex, 10)];
            groupOrder = data.groupOrder;
        }
        const events = this.parent.eventBase.filterEvents(startDate, endDate, this.parent.eventsProcessed, data);
        const moreElement = this.createMoreEventList(events, groupOrder, groupIndex);
        this.morePopup.element.querySelector('.' + MORE_EVENT_POPUP_CLASS).appendChild(moreElement);
    }
    closeClick(event) {
        this.dialogEvent = event;
        if (this.parent.currentView === 'Year' && this.parent.activeCellsData && this.parent.activeCellsData.element) {
            this.parent.selectCell(this.parent.activeCellsData.element);
        }
        this.quickPopupHide();
        this.morePopup.hide();
    }
    dialogButtonClick(event) {
        this.dialogEvent = event;
        this.quickDialog.hide();
        const target = event.target;
        const cancelBtn = this.quickDialog.element.querySelector('.' + QUICK_DIALOG_ALERT_CANCEL);
        const eventData = this.parent.activeEventData.event;
        if (target.classList.contains(QUICK_DIALOG_OCCURRENCE_CLASS)) {
            this.parent.currentAction = (this.parent.currentAction === 'Delete') ? 'DeleteOccurrence' : 'EditOccurrence';
            switch (this.parent.currentAction) {
                case 'EditOccurrence':
                    this.parent.eventWindow.openEditor(eventData, this.parent.currentAction);
                    break;
                case 'DeleteOccurrence':
                    this.parent.crudModule.deleteEvent(eventData, this.parent.currentAction);
                    break;
            }
        }
        else if (target.classList.contains(QUICK_DIALOG_FOLLOWING_EVENTS_CLASS)) {
            this.parent.currentAction = (this.parent.currentAction === 'Delete') ? 'DeleteFollowingEvents' : 'EditFollowingEvents';
            switch (this.parent.currentAction) {
                case 'EditFollowingEvents':
                    this.parent.eventWindow.openEditor(eventData, this.parent.currentAction);
                    break;
                case 'DeleteFollowingEvents':
                    this.parent.crudModule.deleteEvent(eventData, this.parent.currentAction);
                    break;
            }
        }
        else if (target.classList.contains(QUICK_DIALOG_SERIES_CLASS)) {
            this.parent.currentAction = (this.parent.currentAction === 'Delete') ? 'DeleteSeries' : 'EditSeries';
            switch (this.parent.currentAction) {
                case 'EditSeries':
                    this.parent.eventWindow.openEditor(this.parent.eventBase.getParentEvent(eventData, true), this.parent.currentAction);
                    break;
                case 'DeleteSeries':
                    this.parent.crudModule.deleteEvent(eventData, this.parent.currentAction);
                    break;
            }
        }
        else if (target.classList.contains(QUICK_DIALOG_DELETE_CLASS)) {
            this.parent.crudModule.deleteEvent(eventData, this.parent.currentAction);
        }
        else if (!cancelBtn.classList.contains(DISABLE_CLASS) && (target.classList.contains(QUICK_DIALOG_ALERT_OK) ||
            (target.classList.contains(QUICK_DIALOG_ALERT_CANCEL) && !cancelBtn.classList.contains(QUICK_DIALOG_CANCEL_CLASS)))) {
            this.parent.uiStateValues.isIgnoreOccurrence = target.classList.contains(QUICK_DIALOG_ALERT_CANCEL);
            this.parent.eventWindow.eventSave(event, this.l10n.getConstant('ok'));
        }
    }
    updateTapHoldEventPopup(target) {
        const selectedElements = this.parent.eventBase.getSelectedEventElements(target);
        this.parent.activeEventData = this.parent.eventBase.getSelectedEvents();
        if (selectedElements.length > 0) {
            const eventObj = this.parent.eventBase.getEventByGuid(selectedElements[0].getAttribute('data-guid'));
            const titleContent = (selectedElements.length === 1) ?
                (eventObj[this.parent.eventFields.subject] || this.l10n.getConstant('noTitle')) :
                '(' + selectedElements.length + ')' + '&nbsp;' + this.l10n.getConstant('selectedItems');
            this.quickPopup.element.querySelector('.' + SUBJECT_CLASS).innerHTML = titleContent;
            if (selectedElements.length > 1) {
                addClass([this.quickPopup.element.querySelector('.' + EDIT_ICON_CLASS)], HIDDEN_CLASS);
            }
            else {
                removeClass([this.quickPopup.element.querySelector('.' + EDIT_ICON_CLASS)], HIDDEN_CLASS);
            }
        }
        else {
            this.parent.selectedElements = [];
            this.quickPopupHide();
        }
    }
    getTimezone(event) {
        let zoneDetails = '';
        zoneDetails += event[this.parent.eventFields.startTimezone] || '';
        zoneDetails += zoneDetails === '' ? '' : ' - ';
        zoneDetails += event[this.parent.eventFields.endTimezone] || '';
        return zoneDetails;
    }
    getRecurrenceSummary(event) {
        const recurrenceEditor = this.parent.eventWindow.getRecurrenceEditorInstance();
        if (recurrenceEditor) {
            const ruleSummary = recurrenceEditor.getRuleSummary(event[this.parent.eventFields.recurrenceRule]);
            return ruleSummary.charAt(0).toUpperCase() + ruleSummary.slice(1);
        }
        return '';
    }
    getDateFormat(date, skeletonString) {
        return capitalizeFirstWord(this.parent.globalize.formatDate(date, { skeleton: skeletonString, calendar: this.parent.getCalendarMode() }), 'single');
    }
    getDataFromTarget(target) {
        if (target.classList.contains(APPOINTMENT_CLASS)) {
            return this.parent.activeEventData.event;
        }
        // Deprecated cells data in quick popups
        const eventObj = {
            startTime: this.parent.activeCellsData.startTime,
            endTime: this.parent.activeCellsData.endTime,
            isAllDay: this.parent.activeCellsData.isAllDay,
            groupIndex: this.parent.activeCellsData.groupIndex
        };
        const cellsData = this.parent.activeCellsData;
        this.parent.eventWindow.convertToEventData(cellsData, eventObj);
        return eventObj;
    }
    beforeQuickDialogClose(e) {
        const args = {
            event: e.event || this.dialogEvent,
            type: (isNullOrUndefined(this.parent.activeEventData.event)) ? 'ValidationAlert' :
                !isNullOrUndefined(this.parent.activeEventData.event[this.parent.eventFields.recurrenceRule])
                    ? 'RecurrenceAlert' : 'DeleteAlert', cancel: false, data: this.parent.activeEventData.event,
            element: this.quickDialog.element
        };
        this.parent.trigger(popupClose, args, (popupCloseArgs) => {
            if (!popupCloseArgs.cancel) {
                this.parent.eventBase.focusElement(true);
            }
        });
    }
    beforeQuickPopupOpen(target, originalEvent) {
        this.parent.renderTemplates(() => {
            const isEventPopup = this.quickPopup.element.querySelector('.' + EVENT_POPUP_CLASS);
            const popupType = this.parent.isAdaptive ? isEventPopup ? 'ViewEventInfo' : 'EditEventInfo' : 'QuickInfo';
            const eventProp = {
                type: popupType, cancel: false, data: extend({}, this.getDataFromTarget(target), null, true),
                target: target, element: this.quickPopup.element
            };
            this.parent.trigger(popupOpen, eventProp, (popupArgs) => {
                if (popupArgs.cancel) {
                    this.quickPopupHide();
                    this.destroyPopupButtons('quickPopup');
                    if (popupArgs.element.classList.contains(POPUP_OPEN)) {
                        this.quickPopupClose();
                    }
                    removeChildren(this.quickPopup.element);
                    this.isMultipleEventSelect = false;
                }
                else {
                    const display = this.quickPopup.element.style.display;
                    this.quickPopup.element.style.display = 'block';
                    if (this.parent.isAdaptive) {
                        this.quickPopup.element.removeAttribute('style');
                        this.quickPopup.element.style.display = 'block';
                        this.quickPopup.element.style.height = formatUnit((popupType === 'EditEventInfo') ? 65 : window.innerHeight);
                    }
                    else {
                        const isVirtualScroll = this.parent.virtualScrollModule && this.parent.virtualScrollModule.isHorizontalScroll
                            && !isNullOrUndefined(closest(target, '.' + CONTENT_TABLE_CLASS));
                        const conTable = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' table');
                        this.quickPopup.offsetX = isVirtualScroll && !this.parent.enableRtl ? (getTranslateX(conTable) + 10) : 10;
                        this.quickPopup.offsetY = this.parent.virtualScrollModule && !this.parent.virtualScrollModule.isHorizontalScroll ?
                            this.quickPopup.offsetY : 0;
                        this.quickPopup.collision = { X: this.parent.enableRtl ? 'flip' : 'none', Y: 'fit' };
                        this.quickPopup.position = { X: this.parent.enableRtl ? 'left' : 'right', Y: this.parent.enableRtl ? 'bottom' : 'top' };
                        this.quickPopup.dataBind();
                        this.quickPopup.refreshPosition(null, true);
                        const collide = isCollide(this.quickPopup.element, this.parent.element);
                        if (collide.indexOf(this.parent.enableRtl ? 'left' : 'right') > -1) {
                            this.quickPopup.offsetX = -target.offsetWidth - 10 - this.quickPopup.element.offsetWidth;
                            if (isVirtualScroll && !this.parent.enableRtl) {
                                this.quickPopup.offsetX = getTranslateX(conTable) + this.quickPopup.offsetX;
                            }
                            this.quickPopup.dataBind();
                            this.quickPopup.refreshPosition(null, true);
                            const leftCollide = isCollide(this.quickPopup.element, this.parent.element);
                            if (leftCollide.indexOf('left') > -1) {
                                this.quickPopup.position = { X: 'center', Y: 'center' };
                                this.quickPopup.collision = { X: 'fit', Y: 'fit' };
                                this.quickPopup.offsetX = -(this.quickPopup.element.offsetWidth / 2);
                                this.quickPopup.dataBind();
                            }
                        }
                        if (this.parent.virtualScrollModule && !this.parent.virtualScrollModule.isHorizontalScroll && (collide.indexOf('top') > -1 || collide.indexOf('bottom') > -1)) {
                            const translateY = getTranslateY(conTable);
                            this.quickPopup.offsetY = translateY;
                            this.quickPopup.dataBind();
                            this.quickPopup.refreshPosition(null, true);
                        }
                        if (this.quickPopup.position.X === 'center' && this.quickPopup.position.Y === 'center' && !isNullOrUndefined(originalEvent) &&
                            originalEvent.clientX && originalEvent.clientY) {
                            const clientX = originalEvent.clientX;
                            const clientY = originalEvent.clientY;
                            const targetRect = target.getBoundingClientRect();
                            const offsetY = originalEvent.offsetY || Math.ceil(clientY - targetRect.y);
                            const previousOffset = this.quickPopup.offsetY;
                            let collision = isCollide(this.quickPopup.element, target);
                            const popupRect = this.quickPopup.element.getBoundingClientRect();
                            const targetEle = document.elementFromPoint(clientX, clientY);
                            if (collision.indexOf('top') > -1 || collision.indexOf('bottom') > -1 || closest(targetEle, '.' + POPUP_WRAPPER_CLASS)) {
                                if (popupRect.top <= clientY &&
                                    clientY <= popupRect.top + popupRect.height) {
                                    this.quickPopup.offsetY = previousOffset - popupRect.height - 10;
                                    this.quickPopup.dataBind();
                                    collision = isCollide(this.quickPopup.element, this.parent.element);
                                    if (collision.indexOf('top') > -1) {
                                        this.quickPopup.offsetY = previousOffset + offsetY + 10;
                                        this.quickPopup.dataBind();
                                    }
                                }
                                else if (isCollide(this.quickPopup.element, this.parent.element).indexOf('bottom') > -1) {
                                    this.quickPopup.offsetY =
                                        previousOffset - offsetY - Math.ceil(popupRect.height) - 10;
                                    this.quickPopup.dataBind();
                                }
                            }
                        }
                    }
                    if (isEventPopup) {
                        this.applyEventColor();
                    }
                    this.quickPopup.element.style.display = display;
                    this.quickPopup.dataBind();
                    this.quickPopup.show();
                }
            });
        });
    }
    applyEventColor() {
        let colorField = '';
        if (this.parent.currentView === 'Agenda' || this.parent.currentView === 'MonthAgenda') {
            colorField = this.parent.enableRtl ? 'border-right-color' : 'border-left-color';
        }
        else {
            colorField = 'background-color';
        }
        let color = this.parent.activeEventData.element.style[colorField];
        if (color === '') {
            return;
        }
        let colorEle = this.quickPopup.element.querySelector('.' + POPUP_HEADER_CLASS);
        const footerEle = this.quickPopup.element.querySelector('.' + POPUP_FOOTER_CLASS);
        if (footerEle && footerEle.offsetParent) {
            colorEle = this.quickPopup.element.querySelector('.' + SUBJECT_CLASS);
            if (colorEle) {
                colorEle.style.borderLeftColor = color;
                color = `rgba(${color.match(/\d+/g).join()},0.3)`;
            }
        }
        if (colorEle) {
            colorEle.style.backgroundColor = color;
        }
    }
    quickPopupOpen() {
        if (this.parent.isAdaptive) {
            this.quickPopup.element.style.top = '0px';
            return;
        }
        if (this.quickPopup.element.querySelector('.' + CELL_POPUP_CLASS)) {
            const subjectElement = this.quickPopup.element.querySelector('.' + SUBJECT_CLASS);
            if (subjectElement) {
                subjectElement.focus();
            }
        }
        else {
            const editElement = this.quickPopup.element.querySelector('.' + EDIT_EVENT_CLASS);
            if (editElement) {
                editElement.focus();
            }
            const editIcon = this.quickPopup.element.querySelector('.' + EDIT_CLASS);
            if (editIcon) {
                editIcon.focus();
            }
        }
    }
    quickPopupClose() {
        this.parent.eventBase.focusElement();
        this.quickPopup.relateTo = '.' + WORK_CELLS_CLASS;
        this.fieldValidator.destroyToolTip();
        if (this.quickPopup.element.querySelectorAll('.e-formvalidator').length) {
            this.fieldValidator.destroy();
        }
        this.destroyPopupButtons('quickPopup');
        removeChildren(this.quickPopup.element);
    }
    morePopupOpen() {
        if (this.parent.isAdaptive) {
            this.morePopup.element.style.top = '0px';
            this.morePopup.element.style.left = '0px';
            this.morePopup.element.style.height = formatUnit(window.innerHeight);
            return;
        }
        this.morePopup.element.querySelector('.' + MORE_EVENT_HEADER_DATE_CLASS).focus();
        this.morePopup.refreshPosition();
    }
    morePopupClose() {
        const moreWrapper = this.parent.element.querySelector('.' + MORE_EVENT_WRAPPER_CLASS);
        if (moreWrapper) {
            remove(moreWrapper);
        }
    }
    popupClose(event) {
        this.dialogEvent = event;
        this.isCrudAction = false;
        this.quickPopupHide(true);
    }
    quickPopupHide(hideAnimation) {
        if (!this.quickPopup.element.classList.contains(POPUP_OPEN)) {
            return;
        }
        const isCellPopup = this.quickPopup.element.querySelector('.' + CELL_POPUP_CLASS);
        let popupData;
        if (isCellPopup) {
            const formvalidator = this.quickPopup.element.querySelector('.e-formvalidator');
            if (this.isCrudAction && formvalidator &&
                !formvalidator.ej2_instances[0].validate()) {
                return;
            }
            const fields = this.parent.eventFields;
            const saveObj = this.parent.eventWindow.getObjectFromFormData(POPUP_WRAPPER_CLASS);
            this.parent.eventWindow.setDefaultValueToObject(saveObj);
            saveObj[fields.id] = this.parent.eventBase.getEventMaxID();
            saveObj[fields.startTime] = this.parent.activeCellsData.startTime;
            saveObj[fields.endTime] = this.parent.activeCellsData.endTime;
            saveObj[fields.isAllDay] = this.parent.activeCellsData.isAllDay;
            if (this.parent.resourceBase) {
                this.parent.resourceBase.setResourceValues(saveObj);
            }
            popupData = saveObj;
        }
        else {
            popupData = this.parent.activeEventData.event;
        }
        const isEventPopup = this.quickPopup.element.querySelector('.' + EVENT_POPUP_CLASS);
        const args = {
            event: this.dialogEvent,
            type: this.parent.isAdaptive ? isEventPopup ? 'ViewEventInfo' : 'EditEventInfo' : 'QuickInfo',
            cancel: false, data: popupData, element: this.quickPopup.element,
            target: (isCellPopup ? this.parent.activeCellsData.element : this.parent.activeEventData.element)
        };
        this.parent.trigger(popupClose, args, (popupCloseArgs) => {
            if (!popupCloseArgs.cancel) {
                if (this.quickPopup.element.classList.contains('e-popup-open')) {
                    if (isCellPopup && this.isCrudAction) {
                        this.parent.currentAction = 'Add';
                        this.parent.crudModule.addEvent(popupCloseArgs.data);
                    }
                    if (hideAnimation) {
                        const animation = this.quickPopup.hideAnimation;
                        this.quickPopup.hideAnimation = null;
                        this.quickPopup.hide();
                        this.quickPopup.hideAnimation = animation;
                    }
                    else {
                        this.quickPopup.hide();
                    }
                    this.isMultipleEventSelect = false;
                    this.isCrudAction = false;
                }
            }
        });
    }
    navigationClick(e) {
        const navigateEle = closest(e.target, '.' + NAVIGATE_CLASS);
        if (!isNullOrUndefined(navigateEle)) {
            const date = this.parent.getDateFromElement(e.currentTarget);
            if (!isNullOrUndefined(date)) {
                this.closeClick(e);
                this.parent.setProperties({ selectedDate: date }, true);
                this.parent.changeView(this.parent.getNavigateView(), e);
            }
        }
    }
    documentClick(e) {
        const target = e.event.target;
        const classNames = '.' + POPUP_WRAPPER_CLASS + ',.' + HEADER_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS +
            ',.' + WORK_CELLS_CLASS + ',.' + APPOINTMENT_CLASS + ',.e-popup';
        const popupWrap = this.parent.element.querySelector('.' + POPUP_WRAPPER_CLASS);
        if ((popupWrap && popupWrap.childElementCount > 0 && !closest(target, classNames)) || !closest(target, classNames)) {
            this.quickPopupHide();
            this.parent.removeNewEventElement();
        }
        const tar = this.parent.element.querySelector('.' + INLINE_SUBJECT_CLASS);
        if (tar && tar !== target && this.parent.allowInline) {
            this.parent.inlineModule.documentClick();
        }
        if (closest(target, '.' + APPOINTMENT_CLASS + ',.' + HEADER_CELLS_CLASS)) {
            this.parent.removeNewEventElement();
        }
        if (!closest(target, '.' + MORE_POPUP_WRAPPER_CLASS) && (target.classList &&
            !target.classList.contains(MORE_INDICATOR_CLASS))
            && (!closest(target, '.' + POPUP_OPEN)) && !closest(target, '.' + WORK_CELLS_CLASS)) {
            this.morePopup.hide();
        }
    }
    onClosePopup(event) {
        if (!isNullOrUndefined(event)) {
            this.dialogEvent = event;
        }
        this.quickPopupHide();
        this.parent.eventBase.focusElement();
    }
    addEventListener() {
        this.parent.on(cellClick, this.cellClick, this);
        this.parent.on(eventClick, this.eventClick, this);
        this.parent.on(documentClick, this.documentClick, this);
        this.parent.on(dataReady, this.updateMoreEventContent, this);
    }
    removeEventListener() {
        this.parent.off(cellClick, this.cellClick);
        this.parent.off(eventClick, this.eventClick);
        this.parent.off(documentClick, this.documentClick);
        this.parent.off(dataReady, this.updateMoreEventContent);
    }
    destroyPopupButtons(popupName) {
        const popup = popupName === 'quickPopup' ? this.quickPopup : this.morePopup;
        const buttonCollections = [].slice.call(popup.element.querySelectorAll('.e-control.e-btn'));
        for (const button of buttonCollections) {
            const instance = button.ej2_instances[0];
            if (instance) {
                instance.destroy();
            }
        }
    }
    refreshQuickDialog() {
        this.destroyQuickDialog();
        this.renderQuickDialog();
    }
    refreshQuickPopup() {
        this.destroyQuickPopup();
        this.renderQuickPopup();
    }
    refreshMorePopup() {
        this.destroyMorePopup();
        this.renderMorePopup();
    }
    destroyQuickDialog() {
        if (this.quickDialog.element) {
            this.quickDialog.destroy();
            remove(this.quickDialog.element);
            this.quickDialog = null;
        }
    }
    destroyQuickPopup() {
        if (this.quickPopup.element) {
            this.destroyPopupButtons('quickPopup');
            this.quickPopup.destroy();
            remove(this.quickPopup.element);
            this.quickPopup = null;
        }
    }
    destroyMorePopup() {
        if (this.morePopup.element) {
            this.destroyPopupButtons('morePopup');
            this.morePopup.destroy();
            remove(this.morePopup.element);
            this.morePopup = null;
        }
    }
    destroy() {
        if (this.quickPopup.element.querySelectorAll('.e-formvalidator').length) {
            this.fieldValidator.destroy();
        }
        this.removeEventListener();
        this.destroyQuickPopup();
        this.destroyMorePopup();
        this.destroyQuickDialog();
        this.dialogEvent = null;
        this.parent = null;
        this.l10n = null;
        this.isCrudAction = null;
        this.fieldValidator = null;
        this.isMultipleEventSelect = null;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Tooltip for Schedule
 */
class EventTooltip {
    constructor(parent) {
        this.parent = parent;
        this.tooltipObj = new Tooltip({
            animation: { close: { effect: 'FadeOut' } },
            content: 'No title',
            position: 'BottomRight',
            offsetY: 10,
            mouseTrail: this.parent.isAdaptive ? false : true,
            showTipPointer: false,
            cssClass: this.parent.cssClass + ' ' + EVENT_TOOLTIP_ROOT_CLASS,
            target: this.getTargets(),
            beforeRender: this.onBeforeRender.bind(this),
            beforeClose: this.onBeforeClose.bind(this),
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer
        });
        this.tooltipObj.appendTo(this.parent.element);
    }
    getTargets() {
        const targets = [];
        if (this.parent.activeViewOptions.group.headerTooltipTemplate) {
            targets.push('.' + RESOURCE_CELLS_CLASS);
        }
        if (this.parent.eventSettings.enableTooltip) {
            targets.push('.' + APPOINTMENT_CLASS);
        }
        return targets.join(',');
    }
    onBeforeRender(args) {
        if (!isNullOrUndefined(args.target.getAttribute('data-tooltip-id'))) {
            return;
        }
        if (args.target.classList.contains(RESOURCE_CELLS_CLASS) && this.parent.activeViewOptions.group.resources.length > 0) {
            let resCollection;
            if (this.parent.activeView.isTimelineView()) {
                const index = parseInt(args.target.getAttribute('data-group-index'), 10);
                resCollection = this.parent.resourceBase.lastResourceLevel[parseInt(index.toString(), 10)];
            }
            else {
                const rowIndex = args.target.parentNode.sectionRowIndex;
                const cellIndex = args.target.cellIndex;
                resCollection =
                    this.parent.activeView.getColumnLevels()[parseInt(rowIndex.toString(), 10)][parseInt(cellIndex.toString(), 10)];
            }
            const data = {
                resource: resCollection.resource,
                resourceData: resCollection.resourceData
            };
            const contentContainer = createElement('div');
            const templateId = this.parent.element.id + '_headerTooltipTemplate';
            const tooltipTemplate = [].slice.call(this.parent.getHeaderTooltipTemplate()(data, this.parent, 'headerTooltipTemplate', templateId, false));
            append(tooltipTemplate, contentContainer);
            this.setContent(contentContainer);
            this.parent.renderTemplates();
            return;
        }
        const record = this.parent.eventBase.getEventByGuid(args.target.getAttribute('data-guid'));
        if (isNullOrUndefined(record)) {
            return;
        }
        if (!isNullOrUndefined(this.parent.eventSettings.tooltipTemplate)) {
            const contentContainer = createElement('div');
            const templateId = this.parent.element.id + '_tooltipTemplate';
            const tooltipTemplate = [].slice.call(this.parent.getEventTooltipTemplate()(record, this.parent, 'tooltipTemplate', templateId, false));
            append(tooltipTemplate, contentContainer);
            this.setContent(contentContainer);
        }
        else {
            const globalize = this.parent.globalize;
            const fields = this.parent.eventFields;
            const eventStart = new Date('' + record[fields.startTime]);
            let eventEnd = new Date('' + record[fields.endTime]);
            eventEnd = (eventEnd.getHours() === 0 && eventEnd.getMinutes() === 0) ? new Date(eventEnd.setMilliseconds(-1000)) : eventEnd;
            const startDate = resetTime(new Date('' + eventStart));
            const endDate = resetTime(new Date('' + eventEnd));
            const tooltipSubject = (record[fields.subject] || this.parent.eventSettings.fields.subject.default
                || this.parent.localeObj.getConstant('addTitle'));
            const tooltipLocation = !isNullOrUndefined(record[fields.location]) ? record[fields.location] : '';
            let startMonthDate = '';
            let startMonthYearDate = '';
            let endMonthYearDate = '';
            startMonthDate = globalize.formatDate(eventStart, {
                type: 'date', skeleton: 'MMMd', calendar: this.parent.getCalendarMode()
            });
            startMonthYearDate = globalize.formatDate(eventStart, {
                type: 'date', skeleton: 'medium', calendar: this.parent.getCalendarMode()
            });
            endMonthYearDate = globalize.formatDate(eventEnd, {
                type: 'date', skeleton: 'medium', calendar: this.parent.getCalendarMode()
            });
            startMonthDate = capitalizeFirstWord(startMonthDate, 'single');
            startMonthYearDate = capitalizeFirstWord(startMonthYearDate, 'single');
            endMonthYearDate = capitalizeFirstWord(endMonthYearDate, 'single');
            const startTime = this.parent.getTimeString(eventStart);
            const endTime = this.parent.getTimeString(eventEnd);
            let tooltipDetails;
            if (startDate.getTime() === endDate.getTime()) {
                tooltipDetails =
                    globalize.formatDate(eventStart, {
                        type: 'date', skeleton: 'long', calendar: this.parent.getCalendarMode()
                    });
                tooltipDetails = capitalizeFirstWord(tooltipDetails, 'single');
            }
            else {
                tooltipDetails = (startDate.getFullYear() === endDate.getFullYear()) ? (startMonthDate + ' - ' + endMonthYearDate) :
                    (startMonthYearDate + ' - ' + endMonthYearDate);
            }
            const tooltipTime = (record[fields.isAllDay]) ? this.parent.localeObj.getConstant('allDay') :
                (startTime + ' - ' + endTime);
            const content = '<div><div class="e-subject">' + tooltipSubject + '</div>' +
                '<div class="e-location">' + tooltipLocation + '</div>' +
                '<div class="e-details">' + tooltipDetails + '</div>' +
                '<div class="e-all-day">' + tooltipTime + '</div></div>';
            this.setContent(content);
        }
        this.parent.renderTemplates();
    }
    onBeforeClose() {
        this.parent.resetTemplates(['tooltipTemplate', 'headerTooltipTemplate']);
    }
    setContent(content) {
        this.tooltipObj.setProperties({ content: content }, true);
    }
    close() {
        this.tooltipObj.close();
    }
    destroy() {
        this.tooltipObj.destroy();
        addClass([this.parent.element], 'e-control');
        this.tooltipObj = null;
        this.parent = null;
    }
}

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const HEADER = 'e-editor';
const INPUTWARAPPER = 'e-input-wrapper';
const INPUTWARAPPERSIDE = 'e-input-wrapper-side';
const REPEATELEMENT = 'e-repeat-element';
const REPEATINTERVAL = 'e-repeat-interval';
const INTERVALCLASS = 'e-interval';
const DAYWRAPPER = 'e-days';
const WEEKWRAPPER = 'e-non-week';
const WEEKPOSITION = 'e-week-position';
const DAYPOSITION = 'e-day-position';
const YEAREXPANDERWRAPPER = 'e-year-expander';
const YEAREXPANDERELEMENT = 'e-year-expander-element';
const MONETHEXPANDERWRAPPER = 'e-month-expander';
const MONETHEXPANDWRAPPER = 'e-month-expand-wrapper';
const MONTHEXPANDERELEMENT = 'e-month-expander-element';
const MONTHEXPANDERCHECKBOXWRAPPER = 'e-month-expander-checkbox-wrapper';
const FORMLEFT = 'e-form-left';
const FORMRIGHT = 'e-form-right';
const MONTHDAYWRAPPER = 'e-month-day';
const MONTHEXPANNDERELEM = 'e-month-expander-wrapper';
const MONTHPOS = 'e-month-pos';
const MONTHWEEK = 'e-month-week';
const ENDON = 'e-end-on';
const MONTHEXPANDERLABEL = 'e-month-expander-label';
const WEEKEXPANDERLABEL = 'e-week-expander-label';
const ENDONLABEL = 'e-end-on-label';
const ENDONLEFT = 'e-end-on-left';
const MONTHDAYELEMENT = 'e-monthday-element';
const ENDONELEMENT = 'e-end-on-element';
const ENDONDATE = 'e-end-on-date';
const UNTILDATE = 'e-until-date';
const ENDONCOUNTWRAPPER = 'e-end-on-count';
const ENDONCOUNT = 'e-recurrence-count';
const HIDEWRAPPER = 'e-hide-recurrence-element';
const RTLCLASS = 'e-rtl';
const PRIMARY = 'e-primary';
const ACTIVE = 'e-active';
const RECURRENCETABLE = 'e-recurrence-table';
const REPEATCONTENT = 'e-repeat-content';
const REPEATCONTENTWRAPPER = 'e-repeat-content-wrapper';
const NONE = 'none';
const DAILY = 'daily';
const WEEKLY = 'weekly';
const MONTHLY = 'monthly';
const YEARLY = 'yearly';
const NEVER = 'never';
const UNTIL$1 = 'until';
const COUNT = 'count';
const TEXTFIELD = 'text';
const VALUEFIELD = 'value';
const LAST = 'last';
const REPEAT = 'repeat';
const REPEATEVERY = 'repeatEvery';
const ON$1 = 'on';
const END = 'end';
const RADIOLABEL = 'onDay';
const RULEUNTIL = 'UNTIL';
const RULEBYDAY = 'BYDAY';
const RULEBYMONTHDAY = 'BYMONTHDAY';
const RULEBYMONTH = 'BYMONTH';
const RULEINTERVAL = 'INTERVAL';
const RULECOUNT = 'COUNT';
const RULESETPOS = 'BYSETPOS';
const RULEFREQ = 'FREQ';
const RULEDAILY = 'DAILY';
const RULEWEEKLY = 'WEEKLY';
const RULEMONTHLY = 'MONTHLY';
const RULEYEARLY = 'YEARLY';
const RULESUNDAY = 'SU';
const RULEMONDAY = 'MO';
const RULETUESDAY = 'TU';
const RULEWEDNESDAY = 'WE';
const RULETHURSDAY = 'TH';
const RULEFRIDAY = 'FR';
const RULESATURDAY = 'SA';
const KEYSUNDAY = 'sun';
const KEYMONDAY = 'mon';
const KEYTUESDAY = 'tue';
const KEYWEDNESDAY = 'wed';
const KEYTHURSDAY = 'thu';
const KEYFRIDAY = 'fri';
const KEYSATURDAY = 'sat';
const EQUAL = '=';
const SEMICOLON = ';';
const COMMA = ',';
const FIRST = 'first';
const SECOND = 'second';
const THIRD = 'third';
const FOURTH = 'fourth';
const contentType = {
    none: '',
    daily: 'days',
    weekly: 'weeks',
    monthly: 'months',
    yearly: 'years'
};
const valueData = {
    'sun': RULESUNDAY,
    'mon': RULEMONDAY,
    'tue': RULETUESDAY,
    'wed': RULEWEDNESDAY,
    'thu': RULETHURSDAY,
    'fri': RULEFRIDAY,
    'sat': RULESATURDAY
};
const neverClassList = [DAYWRAPPER, WEEKWRAPPER, ENDON, INTERVALCLASS, YEAREXPANDERWRAPPER, MONETHEXPANDERWRAPPER];
const weekClassList = [WEEKWRAPPER];
const monthClassList = [DAYWRAPPER, YEAREXPANDERWRAPPER];
const yearClassList = [DAYWRAPPER];
const dailyClassList = [DAYWRAPPER, WEEKWRAPPER, YEAREXPANDERWRAPPER, MONETHEXPANDERWRAPPER];
const noEndClassList = [ENDONDATE, ENDONCOUNTWRAPPER];
const endOnCountClassList = [ENDONDATE];
const endOnDateClassList = [ENDONCOUNTWRAPPER];
/**
 * Represents the RecurrenceEditor component.
 * ```html
 * <div id="recurrence"></div>
 * ```
 * ```typescript
 * <script>
 *   var recObj = new RecurrenceEditor();
 *   recObj.appendTo("#recurrence");
 * </script>
 * ```
 */
let RecurrenceEditor = class RecurrenceEditor extends Component {
    /**
     * Constructor for creating the widget
     *
     * @param {RecurrenceEditorModel} options Accepts the recurrence editor model properties to initiate the rendering
     * @param {string | HTMLElement} element Accepts the DOM element reference
     */
    constructor(options, element) {
        super(options, element);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.defaultLocale = {
            none: 'None',
            daily: 'Daily',
            weekly: 'Weekly',
            monthly: 'Monthly',
            month: 'Month',
            yearly: 'Yearly',
            never: 'Never',
            until: 'Until',
            count: 'Count',
            first: 'First',
            second: 'Second',
            third: 'Third',
            fourth: 'Fourth',
            last: 'Last',
            repeat: 'Repeat',
            repeatEvery: 'Repeat every',
            on: 'Repeat On',
            end: 'End',
            onDay: 'Day',
            days: 'Day(s)',
            weeks: 'Week(s)',
            months: 'Month(s)',
            years: 'Year(s)',
            every: 'every',
            summaryTimes: 'time(s)',
            summaryOn: 'on',
            summaryUntil: 'until',
            summaryRepeat: 'Repeats',
            summaryDay: 'day(s)',
            summaryWeek: 'week(s)',
            summaryMonth: 'month(s)',
            summaryYear: 'year(s)',
            monthWeek: 'Month Week',
            monthPosition: 'Month Position',
            monthExpander: 'Month Expander',
            yearExpander: 'Year Expander',
            repeatInterval: 'Repeat Interval'
        };
        this.renderStatus = false;
        this.dayButtons = [];
        this.monthButtons = [];
    }
    startState(freq, endOn, startDate) {
        this.showFormElement();
        this.updateForm(freq);
        this.freshOnEndForm();
        this.updateEndOnForm(endOn);
        this.selectMonthDay(startDate);
        this.updateUntilDate(startDate);
        this.onMonthDay.setProperties({ checked: true });
    }
    preRender() {
        this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);
        this.calendarUtil = getCalendarUtil(this.calendarMode);
    }
    applyCustomClass(cssClass) {
        if (cssClass) {
            addClass([this.element], cssClass.split(' '));
        }
    }
    initialize() {
        addClass([this.element], 'e-' + this.getModuleName());
        this.renderComponent();
        if (!isNullOrUndefined(this.value) && this.value !== '') {
            this.setRecurrenceRule(this.value);
        }
        else {
            if (!isNullOrUndefined(this.repeatType.value)) {
                this.startState(this.repeatType.value.toString().toUpperCase(), NEVER, this.startDate);
                this.updateForm(this.repeatType.value.toString());
            }
            if (this.selectedType > 0) {
                this.setProperties({ value: this.getRecurrenceRule() }, false);
            }
        }
        this.applyCustomClass(this.cssClass);
    }
    triggerChangeEvent() {
        if (this.renderStatus) {
            const value = this.getRecurrenceRule();
            this.trigger('change', { value: value }, (args) => this.setProperties({ value: args.value }, false));
        }
    }
    resetDayButton() {
        const elements = [].slice.call(this.element.querySelectorAll('.' + DAYWRAPPER + ' button'));
        elements.forEach((element) => removeClass([element], [ACTIVE, PRIMARY]));
    }
    daySelection(dayIndex) {
        this.resetDayButton();
        const days = [0, 1, 2, 3, 4, 5, 6];
        this.rotateArray(days, this.firstDayOfWeek);
        const element = this.element.querySelector('.' + DAYWRAPPER + ' button[data-index="' + days.indexOf(dayIndex) + '"]');
        if (element) {
            addClass([element], [ACTIVE, PRIMARY]);
        }
    }
    rtlClass(status) {
        if (status) {
            addClass([this.element], RTLCLASS);
        }
        else {
            removeClass([this.element], RTLCLASS);
        }
    }
    updateUntilDate(date) {
        const tempDate = new Date(date.getTime());
        tempDate.setDate(tempDate.getDate() + 60);
        this.untilDateObj.setProperties({ value: tempDate });
    }
    selectMonthDay(date) {
        const weekday = [KEYSUNDAY, KEYMONDAY, KEYTUESDAY, KEYWEDNESDAY, KEYTHURSDAY, KEYFRIDAY, KEYSATURDAY];
        this.monthDate.setProperties({ value: this.calendarUtil.getDate(date) });
        this.monthWeekDays.setProperties({ value: valueData[weekday[date.getDay()]] });
        this.monthValue.setProperties({ value: '' + this.calendarUtil.getMonth(date) });
        this.monthWeekPos.setProperties({ value: this.getDayPosition(date) });
        this.daySelection(date.getDay());
    }
    updateForm(state) {
        this.repeatType.setProperties({ value: state });
        const end = this.element.querySelector('.' + ENDON);
        if (state === DAILY) {
            classList(end, [FORMLEFT], [FORMRIGHT]);
        }
        else {
            classList(end, [FORMRIGHT], [FORMLEFT]);
        }
        switch (state) {
            case NONE:
                neverClassList.forEach((className) => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));
                break;
            case WEEKLY:
                weekClassList.forEach((className) => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));
                break;
            case MONTHLY:
                monthClassList.forEach((className) => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));
                break;
            case YEARLY:
                yearClassList.forEach((className) => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));
                break;
            case DAILY:
                dailyClassList.forEach((className) => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));
                break;
        }
    }
    updateEndOnForm(state) {
        this.endType.setProperties({ value: state });
        switch (state) {
            case NEVER:
                noEndClassList.forEach((className) => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));
                break;
            case UNTIL$1:
                endOnDateClassList.forEach((className) => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));
                break;
            case COUNT:
                endOnCountClassList.forEach((className) => addClass([this.element.querySelector('.' + className)], HIDEWRAPPER));
                break;
        }
    }
    freshOnEndForm() {
        noEndClassList.forEach((className) => {
            const element = this.element.querySelector('.' + className);
            if (element) {
                removeClass([element], HIDEWRAPPER);
            }
        });
    }
    showFormElement() {
        neverClassList.forEach((className) => {
            const hideElement = this.element.querySelector('.' + className);
            if (hideElement) {
                removeClass([hideElement], HIDEWRAPPER);
            }
        });
    }
    renderDropdowns() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.repeatType = new DropDownList({
            //set the data to dataSource property
            dataSource: this.getRepeatData(),
            floatLabelType: 'Always',
            enableRtl: this.enableRtl,
            index: this.selectedType,
            fields: {
                text: TEXTFIELD,
                value: VALUEFIELD
            },
            placeholder: this.localeObj.getConstant(REPEAT),
            htmlAttributes: { 'title': this.localeObj.getConstant(REPEAT), role: 'option' },
            change: (args) => {
                self.setProperties({ selectedType: this.frequencies.indexOf(args.value) }, false);
                self.element.querySelector('.' + REPEATCONTENT).innerHTML =
                    self.localeObj.getConstant(contentType[args.value]);
                self.showFormElement();
                self.updateForm(args.value);
                self.resetFormValues();
                self.triggerChangeEvent();
            }
        });
        // set placeholder to DropDownList input element
        this.repeatType.appendTo(this.element.querySelector('.' + REPEATELEMENT));
        this.endType = new DropDownList({
            dataSource: this.getEndData(),
            popupWidth: this.getPopupWidth(),
            enableRtl: this.enableRtl,
            index: 1,
            fields: {
                text: TEXTFIELD,
                value: VALUEFIELD
            },
            htmlAttributes: { role: 'option' },
            change: (args) => {
                self.freshOnEndForm();
                self.updateEndOnForm(args.value);
                self.resetFormValues();
                self.triggerChangeEvent();
            }
        });
        this.endType.appendTo(this.element.querySelector('.' + ENDONELEMENT));
        const renderDropDownList = (dropDownData) => {
            return new DropDownList({
                dataSource: dropDownData,
                popupWidth: this.getPopupWidth(),
                enableRtl: this.enableRtl,
                fields: {
                    text: TEXTFIELD,
                    value: VALUEFIELD
                },
                htmlAttributes: { role: 'option' },
                index: 1,
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                change: (args) => {
                    self.onWeekDay.setProperties({ checked: true });
                    self.resetFormValues();
                    self.triggerChangeEvent();
                }
            });
        };
        this.monthWeekPos = renderDropDownList(this.getMonthPosData());
        this.monthWeekPos.appendTo(this.element.querySelector('.' + MONTHPOS));
        this.monthWeekDays = renderDropDownList(this.getDayData('wide'));
        this.monthWeekDays.appendTo(this.element.querySelector('.' + MONTHWEEK));
        this.monthValue = new DropDownList({
            dataSource: this.getMonthData(),
            fields: {
                text: TEXTFIELD,
                value: VALUEFIELD
            },
            htmlAttributes: { role: 'option' },
            enableRtl: this.enableRtl,
            index: 7,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            change: (args) => {
                self.resetFormValues();
                self.triggerChangeEvent();
            }
        });
        this.monthValue.appendTo(this.element.querySelector('.' + YEAREXPANDERELEMENT));
    }
    setDefaultValue() {
        const formelement = [].slice.call(this.element.querySelectorAll('.e-control .e-numerictextbox'));
        for (const element of formelement) {
            const instance = element.ej2_instances[0];
            if (instance.element.classList.contains(REPEATINTERVAL)) {
                instance.value = 1;
                instance.dataBind();
            }
            else if (instance.element.classList.contains(ENDONCOUNT)) {
                instance.value = 10;
                instance.dataBind();
            }
        }
    }
    resetFormValues() {
        const recurreneElement = [].slice.call(this.element.querySelectorAll('.e-control [type="text"]'));
        for (const element of recurreneElement) {
            let instance;
            if (element.classList.contains('e-datepicker')) {
                instance = element.ej2_instances[0];
                if (instance.value) {
                    // eslint-disable-next-line no-self-assign
                    instance.value = instance.value;
                    instance.dataBind();
                }
                else {
                    this.updateUntilDate(this.startDate);
                }
            }
            else if (element.classList.contains('e-dropdownlist')) {
                instance = element.ej2_instances[0];
                instance.index = instance.index || 0;
                instance.dataBind();
            }
            else if (element.classList.contains('e-numerictextbox')) {
                instance = element.ej2_instances[0];
                let value;
                if (instance.element.classList.contains(REPEATINTERVAL)) {
                    value = 1;
                }
                else if (instance.element.classList.contains(ENDONCOUNT)) {
                    value = 10;
                }
                else {
                    value = this.startDate.getDate();
                }
                instance.value = instance.value || value;
                instance.dataBind();
            }
        }
    }
    getPopupWidth() {
        return Browser.isDevice ? '100%' : 'auto';
    }
    renderDatePickers() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.untilDateObj = new DatePicker({
            firstDayOfWeek: this.firstDayOfWeek,
            enableRtl: this.enableRtl,
            locale: this.locale,
            min: this.minDate,
            max: this.maxDate,
            format: (isNullOrUndefined(this.dateFormat) ? this.getFormat('dateFormats') : this.dateFormat),
            change: (args) => {
                if (args.value) {
                    self.triggerChangeEvent();
                }
            }
        });
        this.untilDateObj.appendTo(this.element.querySelector('.' + UNTILDATE));
    }
    getFormat(formatType) {
        let format;
        if (this.locale === 'en' || this.locale === 'en-US') {
            format = getValue(formatType + '.short', getDefaultDateObject(this.getCalendarMode()));
        }
        else {
            format = getValue('main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.' + formatType + '.short', cldrData);
        }
        return format;
    }
    dayButtonRender() {
        const btns = [].slice.call(this.element.querySelectorAll('.' + DAYWRAPPER + ' button'));
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        for (const btn of btns) {
            const button = new Button({ isToggle: true, enableRtl: this.enableRtl }, btn);
            this.dayButtons.push(button);
            EventHandler.add(btn, 'click', (args) => {
                const btns = [].slice.call(this.element.querySelectorAll('.' + DAYWRAPPER + ' button.' + PRIMARY));
                const element = args.target;
                if (!element.classList.contains(PRIMARY)) {
                    addClass([element], PRIMARY);
                    self.triggerChangeEvent();
                }
                else if (btns.length > 1) {
                    removeClass([element], PRIMARY);
                    self.triggerChangeEvent();
                }
            });
        }
    }
    radioButtonRender() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.onMonthDay = new RadioButton({
            label: this.localeObj.getConstant(RADIOLABEL),
            enableRtl: this.enableRtl,
            name: 'monthType',
            value: 'day',
            change: () => {
                self.resetFormValues();
                self.triggerChangeEvent();
            }
        });
        this.onMonthDay.appendTo(this.element.querySelector('.' + MONTHEXPANDERELEMENT));
        this.monthButtons.push(this.onMonthDay);
        this.onWeekDay = new RadioButton({
            label: this.localeObj.getConstant('monthExpander'),
            cssClass: 'e-month-type',
            name: 'monthType',
            enableRtl: this.enableRtl,
            value: 'daypos',
            change: () => {
                self.resetFormValues();
                self.triggerChangeEvent();
            }
        });
        this.onWeekDay.appendTo(this.element.querySelector('.' + MONTHEXPANNDERELEM));
        this.monthButtons.push(this.onWeekDay);
    }
    numericTextboxRender() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.recurrenceCount = new NumericTextBox({
            value: 10,
            format: '#',
            enableRtl: this.enableRtl,
            min: 1,
            max: 999,
            change: () => {
                self.triggerChangeEvent();
            }
        });
        this.recurrenceCount.appendTo(this.element.querySelector('.' + ENDONCOUNT));
        this.monthDate = new NumericTextBox({
            value: 1,
            format: '#',
            enableRtl: this.enableRtl,
            min: 1,
            max: 31,
            change: () => {
                self.onMonthDay.setProperties({ checked: true });
                self.triggerChangeEvent();
            }
        });
        this.monthDate.appendTo(this.element.querySelector('.' + MONTHDAYWRAPPER));
        this.repeatInterval = new NumericTextBox({
            value: 1,
            format: '#',
            min: 1,
            max: 999,
            enableRtl: this.enableRtl,
            floatLabelType: 'Always',
            placeholder: this.localeObj.getConstant(REPEATEVERY),
            change: () => {
                self.triggerChangeEvent();
            }
        });
        this.repeatInterval.appendTo(this.element.querySelector('.' + REPEATINTERVAL));
    }
    renderComponent() {
        this.setTemplate();
        this.renderDropdowns();
        this.renderDatePickers();
        this.dayButtonRender();
        this.radioButtonRender();
        this.numericTextboxRender();
    }
    rotateArray(data, count) {
        let temp;
        for (let index = 0; index < count; index++) {
            temp = data.shift();
            data.push(temp);
        }
    }
    getEndData() {
        const endData = [NEVER, UNTIL$1, COUNT];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const dataSource = [];
        endData.forEach((data) => {
            dataSource.push({ text: self.localeObj.getConstant(data), value: data });
        });
        return dataSource;
    }
    getDayPosition(date) {
        let temp = new Date(date.getTime());
        let endDate = new Date(date.getTime());
        const day = date.getDay();
        const positionCollection = [];
        temp = this.calendarUtil.getMonthStartDate(temp);
        endDate = this.calendarUtil.getMonthEndDate(endDate);
        while (temp < endDate) {
            if (temp.getDay() === day) {
                positionCollection.push(temp.getTime());
            }
            temp.setDate(temp.getDate() + 1);
        }
        if (positionCollection.indexOf(date.getTime()) === positionCollection.length - 1) {
            return -1;
        }
        return (positionCollection.indexOf(date.getTime()) + 1);
    }
    getRepeatData() {
        const data = [];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.frequencies.forEach((element) => {
            const textValue = (element === NONE) ? NEVER : element;
            data.push({ text: self.localeObj.getConstant(textValue), value: element });
        });
        return data;
    }
    getMonthPosData() {
        const monthpos = [FIRST, SECOND, THIRD, FOURTH, LAST];
        const monthposValue = {
            first: 1,
            second: 2,
            third: 3,
            fourth: 4,
            last: -1
        };
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const dataSource = [];
        monthpos.forEach((data) => {
            dataSource.push({ text: self.localeObj.getConstant(data), value: monthposValue[`${data}`] });
        });
        return dataSource;
    }
    getDayData(format) {
        const weekday = [KEYSUNDAY, KEYMONDAY, KEYTUESDAY, KEYWEDNESDAY, KEYTHURSDAY, KEYFRIDAY, KEYSATURDAY];
        const dayData = [];
        let cldrObj;
        this.rotateArray(weekday, this.firstDayOfWeek);
        if (this.locale === 'en' || this.locale === 'en-US') {
            const nameSpaceString = 'days.stand-alone.';
            cldrObj = (getValue(nameSpaceString + format, getDefaultDateObject(this.getCalendarMode())));
        }
        else {
            const nameSpaceString = 'main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.days.stand-alone.' + format;
            cldrObj = (getValue(nameSpaceString, cldrData));
        }
        for (const obj of weekday) {
            const day = getValue(obj, cldrObj);
            dayData.push({ text: format === 'narrow' ? day : capitalizeFirstWord(day, 'single'), value: valueData[`${obj}`] });
        }
        return dayData;
    }
    getMonthData() {
        const monthData = [];
        let cldrObj;
        if (this.locale === 'en' || this.locale === 'en-US') {
            const nameSpaceString = 'months.stand-alone.wide';
            cldrObj = (getValue(nameSpaceString, getDefaultDateObject(this.getCalendarMode())));
        }
        else {
            const nameSpaceString = 'main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.months.stand-alone.wide';
            cldrObj = (getValue(nameSpaceString, cldrData));
        }
        for (const obj of Object.keys(cldrObj)) {
            monthData.push({
                text: capitalizeFirstWord(getValue(obj, cldrObj), 'single'),
                value: obj
            });
        }
        return monthData;
    }
    setTemplate() {
        const dayData = this.getDayData('narrow');
        const fullDay = this.getDayData('wide');
        this.element.innerHTML = '<div class="' + HEADER + '">' +
            '<div class="' + INPUTWARAPPER + ' ' + FORMLEFT + '">' +
            '<input type="text" tabindex="0" class="' + REPEATELEMENT +
            '"label="' + REPEATELEMENT.substr(2) + '" />' +
            '</div><div class="' + INPUTWARAPPER + ' ' +
            INTERVALCLASS + ' ' + FORMRIGHT + '"><table  class="' + RECURRENCETABLE + ' ' + REPEATCONTENTWRAPPER + '"><tr>' +
            '<td><input type="text" tabindex="0" id="' + this.element.id + '_' + REPEATINTERVAL + '" class="' + REPEATINTERVAL +
            '"title="' + this.localeObj.getConstant('repeatEvery') + '" /></td>' +
            '<td><span class="' + REPEATCONTENT + '"></span></td>' +
            '</tr></table></div><div class="' + INPUTWARAPPERSIDE + ' ' + DAYWRAPPER + ' ' + FORMLEFT + '">' +
            '<div class=' + WEEKEXPANDERLABEL + '>' + this.localeObj.getConstant(ON$1) + '</div>' +
            '<button type="button" class="e-round" data-index="0" title="' + fullDay[0].text + '">' + dayData[0].text + '</button>' +
            '<button type="button" class="e-round" data-index="1" title="' + fullDay[1].text + '">' + dayData[1].text + '</button>' +
            '<button type="button" class="e-round" data-index="2" title="' + fullDay[2].text + '">' + dayData[2].text + '</button>' +
            '<button type="button" class="e-round" data-index="3" title="' + fullDay[3].text + '">' + dayData[3].text + '</button>' +
            '<button type="button" class="e-round" data-index="4" title="' + fullDay[4].text + '">' + dayData[4].text + '</button>' +
            '<button type="button" class="e-round" data-index="5" title="' + fullDay[5].text + '">' + dayData[5].text + '</button>' +
            '<button type="button" class="e-round" data-index="6" title="' + fullDay[6].text + '">' + dayData[6].text + '</button></div>' +
            '<div class="' + INPUTWARAPPERSIDE + ' ' + WEEKWRAPPER + ' ' + FORMLEFT + '">' +
            '<div class=' + MONTHEXPANDERLABEL + '>' + this.localeObj.getConstant(ON$1) + '</div>' +
            '<div class="' + YEAREXPANDERWRAPPER + '">' +
            '<input class="' + YEAREXPANDERELEMENT + '" type="text" tabindex="0" title="' +
            this.localeObj.getConstant('yearExpander') + '"/>' +
            '</div>' +
            '<div class="' + MONETHEXPANDERWRAPPER + '">' +
            '<table class="' + RECURRENCETABLE + ' ' + MONETHEXPANDWRAPPER + '"><tr><td>' +
            '<div class="' + INPUTWARAPPER + ' ' + MONTHEXPANDERCHECKBOXWRAPPER + '">' +
            '<input class="' + MONTHEXPANDERELEMENT + '"title="' + this.localeObj.getConstant('monthExpander') + '" type="radio">' +
            '</div></td>' +
            '<td colspan="2"><div class="' + INPUTWARAPPER + ' ' + MONTHDAYELEMENT + '">' +
            '<input type="text" tabindex="0" id="' + this.element.id + '_' + MONTHDAYWRAPPER + '" class="' + MONTHDAYWRAPPER + '"title="' +
            this.localeObj.getConstant('on') + '" />' +
            '</div></td></tr>' +
            '<tr><td>' +
            '<div class="' + INPUTWARAPPER + ' ' + MONTHEXPANDERCHECKBOXWRAPPER + '" style="min-width: 30px;margin-bottom:18px;">' +
            '<input class="' + MONTHEXPANNDERELEM + '"title="' + this.localeObj.getConstant('monthExpander') + '" type="radio">' +
            '</div></td>' +
            '<td><div class="' + INPUTWARAPPER + ' ' + WEEKPOSITION + '" >' +
            '<input type="text" tabindex="0" class="' + MONTHPOS + '"title="' + this.localeObj.getConstant('monthPosition') + '" />' +
            '</div></td>' +
            '<td><div class="' + INPUTWARAPPER + ' ' + DAYPOSITION + '">' +
            '<input type="text" tabindex="0" class="' + MONTHWEEK + '"title="' + this.localeObj.getConstant('monthWeek') + '" />' +
            '</div></td></tr></table>' +
            '</div></div>' +
            '<div class="' + INPUTWARAPPERSIDE + ' ' + ENDON + ' ' + FORMRIGHT + '">' +
            '<div class=' + ENDONLABEL + '>' + this.localeObj.getConstant(END) + '</div>' +
            '<div class="' + INPUTWARAPPER + ' ' + ENDONLEFT + '">' +
            '<input type="text" tabindex="0" class="' + ENDONELEMENT + '"title="' + this.localeObj.getConstant(END) + '" />' +
            '</div>' +
            '<div class="' + INPUTWARAPPER + ' ' + ENDONDATE + '" >' +
            '<input type="text" tabindex="0" class="' + UNTILDATE + '"title="' + this.localeObj.getConstant(UNTIL$1) + '" />' +
            '</div>' +
            '<div class="' + INPUTWARAPPER + ' ' + ENDONCOUNTWRAPPER + '">' +
            '<input type="text" tabindex="0" id="' + this.element.id + '_' + ENDONCOUNT + '" class="' + ENDONCOUNT + '"title="' + this.localeObj.getConstant(COUNT) + '" />' +
            '</div></div>' +
            '</div></div>';
    }
    getSelectedDaysData() {
        let ruleData = RULEBYDAY + EQUAL;
        const elements = [].slice.call(this.element.querySelectorAll('.' + DAYWRAPPER + ' button.' + PRIMARY));
        const weekday = [RULESUNDAY, RULEMONDAY, RULETUESDAY, RULEWEDNESDAY, RULETHURSDAY, RULEFRIDAY, RULESATURDAY];
        this.rotateArray(weekday, this.firstDayOfWeek);
        for (let index = 0; index < elements.length; index++) {
            ruleData += weekday[parseInt(elements[parseInt(index.toString(), 10)].getAttribute('data-index'), 10)] + (index === (elements.length - 1) ? '' : COMMA);
        }
        return ruleData + SEMICOLON;
    }
    getSelectedMonthData() {
        let ruleData;
        if (this.onWeekDay.checked) {
            ruleData = RULEBYDAY + EQUAL + this.monthWeekDays.value + SEMICOLON
                + RULESETPOS + EQUAL + this.monthWeekPos.value + SEMICOLON;
        }
        else {
            ruleData = RULEBYMONTHDAY + EQUAL + this.monthDate.value + SEMICOLON;
        }
        return ruleData;
    }
    getIntervalData() {
        return RULEINTERVAL + EQUAL + this.repeatInterval.value + SEMICOLON;
    }
    getEndOnCount() {
        return RULECOUNT + EQUAL + this.recurrenceCount.value + SEMICOLON;
    }
    getYearMonthRuleData() {
        return RULEBYMONTH + EQUAL + this.monthValue.value + SEMICOLON;
    }
    updateWeekButton(keys) {
        const weekday = [RULESUNDAY, RULEMONDAY, RULETUESDAY, RULEWEDNESDAY, RULETHURSDAY, RULEFRIDAY, RULESATURDAY];
        this.rotateArray(weekday, this.firstDayOfWeek);
        for (const obj of this.dayButtons) {
            const index = parseInt(obj.element.getAttribute('data-index'), 10);
            if (keys.indexOf(weekday[parseInt(index.toString(), 10)]) !== -1) {
                obj.setProperties({ isPrimary: true });
            }
            else {
                obj.setProperties({ isPrimary: false });
            }
        }
    }
    updateMonthUI() {
        if (this.ruleObject.monthDay.length) {
            this.monthDate.setProperties({ value: this.ruleObject.monthDay[0] });
            this.onMonthDay.setProperties({ checked: true });
        }
        else {
            this.onWeekDay.setProperties({ checked: true });
            this.monthWeekPos.setProperties({ value: this.ruleObject.setPosition });
            for (const key of Object.keys(valueData)) {
                if (valueData[`${key}`] === this.ruleObject.day[0]) {
                    this.monthWeekDays.setProperties({ value: this.ruleObject.day[0] });
                    break;
                }
            }
        }
    }
    updateUI(repeat, state) {
        this.repeatInterval.setProperties({ value: this.ruleObject.interval });
        switch (state) {
            case UNTIL$1:
                this.untilDateObj.setProperties({ value: this.ruleObject.until });
                break;
            case COUNT:
                this.recurrenceCount.setProperties({ value: this.ruleObject.count });
                break;
        }
        switch (repeat) {
            case WEEKLY:
                this.updateWeekButton(this.ruleObject.day);
                break;
            case YEARLY:
                this.monthValue.setProperties({ index: (this.ruleObject.month[0] - 1) });
                this.updateMonthUI();
                break;
            case MONTHLY:
                this.updateMonthUI();
                break;
        }
    }
    getUntilData() {
        if (!this.untilDateObj.value) {
            return '';
        }
        const tempStr = getRecurrenceStringFromDate(this.untilDateObj.value);
        return RULEUNTIL + EQUAL + tempStr + SEMICOLON;
    }
    destroyComponents() {
        if (!this.recurrenceCount.isDestroyed) {
            this.recurrenceCount.destroy();
            this.recurrenceCount = null;
        }
        if (!this.monthDate.isDestroyed) {
            this.monthDate.destroy();
            this.monthDate = null;
        }
        if (!this.repeatInterval.isDestroyed) {
            this.repeatInterval.destroy();
            this.repeatInterval = null;
        }
        if (!this.untilDateObj.isDestroyed) {
            this.untilDateObj.destroy();
            this.untilDateObj = null;
        }
        if (!this.repeatType.isDestroyed) {
            this.repeatType.destroy();
            this.repeatType = null;
        }
        if (!this.endType.isDestroyed) {
            this.endType.destroy();
            this.endType = null;
        }
        if (!this.monthWeekPos.isDestroyed) {
            this.monthWeekPos.destroy();
            this.monthWeekPos = null;
        }
        if (!this.monthWeekDays.isDestroyed) {
            this.monthWeekDays.destroy();
            this.monthWeekDays = null;
        }
        if (!this.monthValue.isDestroyed) {
            this.monthValue.destroy();
            this.monthValue = null;
        }
        if (!this.onMonthDay.isDestroyed) {
            this.onMonthDay.destroy();
            this.onMonthDay = null;
        }
        if (!this.onWeekDay.isDestroyed) {
            this.onWeekDay.destroy();
            this.onWeekDay = null;
        }
        this.dayButtons.forEach((element) => {
            if (!element.isDestroyed) {
                element.destroy();
            }
        });
        this.dayButtons = [];
        this.monthButtons.forEach((element) => {
            if (!element.isDestroyed) {
                element.destroy();
            }
        });
        this.monthButtons = [];
    }
    resetFields() {
        this.startState(NONE, NEVER, this.startDate);
        this.setDefaultValue();
    }
    updateRuleUntilDate(startDate) {
        if (this.untilDateObj.value && startDate) {
            const untilDate = this.untilDateObj.value;
            const newUntilDate = new Date(untilDate.getFullYear(), untilDate.getMonth(), untilDate.getDate(), startDate.getHours(), startDate.getMinutes(), startDate.getMilliseconds());
            this.untilDateObj.setProperties({ value: newUntilDate });
        }
    }
    getCalendarMode() {
        return this.calendarMode.toLowerCase();
    }
    getRuleSummary(rule = this.getRecurrenceRule()) {
        return generateSummary(rule, this.localeObj, this.locale, this.calendarMode);
    }
    getRecurrenceDates(startDate, rule, excludeDate, maximumCount, viewDate) {
        viewDate = isNullOrUndefined(viewDate) ? this.startDate : viewDate;
        return generate(startDate, rule, excludeDate, this.firstDayOfWeek, maximumCount, viewDate, this.calendarMode);
    }
    getRecurrenceRule() {
        let ruleData = RULEFREQ + EQUAL;
        switch (this.repeatType.value) {
            case DAILY:
                ruleData += RULEDAILY + SEMICOLON;
                break;
            case WEEKLY:
                ruleData += RULEWEEKLY + SEMICOLON + this.getSelectedDaysData();
                break;
            case MONTHLY:
                ruleData += RULEMONTHLY + SEMICOLON + this.getSelectedMonthData();
                break;
            case YEARLY:
                ruleData += RULEYEARLY + SEMICOLON + this.getSelectedMonthData() + this.getYearMonthRuleData();
                break;
            case NONE:
                return '';
        }
        ruleData += this.getIntervalData();
        switch (this.endType.value) {
            case UNTIL$1:
                ruleData += this.getUntilData();
                break;
            case COUNT:
                ruleData += this.getEndOnCount();
                break;
        }
        return ruleData;
    }
    setRecurrenceRule(rule, startDate = this.startDate) {
        if (!rule) {
            this.repeatType.setProperties({ value: NONE });
            return;
        }
        this.renderStatus = false;
        this.ruleObject = extractObjectFromRule(rule);
        const endon = this.ruleObject.count ? COUNT : (this.ruleObject.until ? UNTIL$1 : NEVER);
        switch (this.ruleObject.freq) {
            case RULEDAILY:
                this.startState(DAILY, endon, startDate);
                this.updateUI(DAILY, endon);
                break;
            case RULEWEEKLY:
                this.startState(WEEKLY, endon, startDate);
                this.updateUI(WEEKLY, endon);
                break;
            case RULEMONTHLY:
                this.startState(MONTHLY, endon, startDate);
                this.updateUI(MONTHLY, endon);
                break;
            case RULEYEARLY:
                this.startState(YEARLY, endon, startDate);
                this.updateUI(YEARLY, endon);
                break;
        }
        this.renderStatus = true;
        this.triggerChangeEvent();
    }
    detachInputs() {
        const inputElements = [].slice.call(this.element.querySelectorAll('input'));
        for (const element of inputElements) {
            detach(element);
        }
    }
    /**
     * Destroys the widget.
     *
     * @returns {void}
     */
    destroy() {
        if (!this.isDestroyed) {
            this.destroyComponents();
            super.destroy();
            let removeClasses = ['e-' + this.getModuleName()];
            if (this.cssClass) {
                removeClasses = removeClasses.concat(this.cssClass.split(' '));
            }
            removeClass([this.element], removeClasses);
            this.detachInputs();
            while (this.element.firstElementChild) {
                this.element.removeChild(this.element.firstElementChild);
            }
        }
    }
    /**
     * Get component name.
     *
     * @returns {string} Returns the module name
     * @private
     */
    getModuleName() {
        return 'recurrenceeditor';
    }
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @returns {string} Returns the persisted state
     */
    getPersistData() {
        return this.addOnPersist([]);
    }
    /**
     * Initialize the control rendering
     *
     * @returns {void}
     * @private
     */
    render() {
        this.initialize();
        this.rtlClass(this.enableRtl);
        this.renderStatus = true;
        this.renderComplete();
    }
    /**
     * Called internally, if any of the property value changed.
     *
     * @param {RecurrenceEditorModel} newProp Accepts the changed properties new values
     * @param {RecurrenceEditorModel} oldProp Accepts the changed properties old values
     * @returns {void}
     * @private
     */
    onPropertyChanged(newProp, oldProp) {
        for (const prop of Object.keys(newProp)) {
            switch (prop) {
                case 'startDate':
                    this.selectMonthDay(newProp.startDate);
                    this.updateUntilDate(newProp.startDate);
                    this.endType.setProperties({ index: 0 });
                    break;
                case 'enableRtl':
                    this.rtlClass(newProp.enableRtl);
                    break;
                case 'cssClass':
                    if (oldProp.cssClass) {
                        removeClass([this.element], oldProp.cssClass.split(' '));
                    }
                    if (newProp.cssClass) {
                        addClass([this.element], newProp.cssClass.split(' '));
                    }
                    break;
                case 'selectedType':
                    this.repeatType.setProperties({ index: this.selectedType });
                    break;
                case 'minDate':
                    this.untilDateObj.setProperties({ minDate: this.minDate });
                    break;
                case 'maxDate':
                    this.untilDateObj.setProperties({ maxDate: this.maxDate });
                    break;
                case 'value':
                    if (this.getRecurrenceRule() !== this.value) {
                        this.setRecurrenceRule(this.value);
                    }
                    break;
                case 'calendarMode':
                    this.calendarMode = newProp.calendarMode;
                    this.calendarUtil = getCalendarUtil(newProp.calendarMode);
                    break;
                case 'locale':
                case 'frequencies':
                case 'firstDayOfWeek':
                    this.refresh();
                    break;
                case 'dateFormat':
                    this.untilDateObj.setProperties({ format: newProp.dateFormat });
                    break;
            }
        }
    }
};
__decorate$1([
    Property(['none', 'daily', 'weekly', 'monthly', 'yearly'])
], RecurrenceEditor.prototype, "frequencies", void 0);
__decorate$1([
    Property(0)
], RecurrenceEditor.prototype, "firstDayOfWeek", void 0);
__decorate$1([
    Property(new Date())
], RecurrenceEditor.prototype, "startDate", void 0);
__decorate$1([
    Property()
], RecurrenceEditor.prototype, "dateFormat", void 0);
__decorate$1([
    Property('Gregorian')
], RecurrenceEditor.prototype, "calendarMode", void 0);
__decorate$1([
    Property()
], RecurrenceEditor.prototype, "cssClass", void 0);
__decorate$1([
    Property()
], RecurrenceEditor.prototype, "value", void 0);
__decorate$1([
    Property(new Date(1900, 0, 1))
], RecurrenceEditor.prototype, "minDate", void 0);
__decorate$1([
    Property(new Date(2099, 11, 31))
], RecurrenceEditor.prototype, "maxDate", void 0);
__decorate$1([
    Property(0)
], RecurrenceEditor.prototype, "selectedType", void 0);
__decorate$1([
    Event()
], RecurrenceEditor.prototype, "change", void 0);
RecurrenceEditor = __decorate$1([
    NotifyPropertyChanges
], RecurrenceEditor);

/* eslint-disable @typescript-eslint/no-explicit-any */
const EVENT_FIELD$1 = 'e-field';
const REPEAT_CONTAINER_CLASS = 'e-recurrence-container';
const REPEAT_BUTTON_ICON_CLASS = 'e-recurrence-edit';
const REPEAT_BUTTON_CLASS = 'e-recurrence-edit-button';
const REPEAT_DIALOG_CLASS = 'e-recurrence-dialog';
const HIDE_STYLE_CLASS = 'e-hide';
/**
 * Event editor window
 */
class EventWindow {
    constructor(parent) {
        this.parent = parent;
        this.l10n = this.parent.localeObj;
        this.fields = this.parent.eventFields;
        this.eventWindowTime = { startTime: new Date(), endTime: new Date() };
        this.renderEventWindow();
    }
    renderEventWindow() {
        this.element = createElement('div', { id: this.parent.element.id + '_dialog_wrapper' });
        this.parent.element.appendChild(this.element);
        const dialogModel = {
            animationSettings: { effect: 'Zoom' },
            content: this.getEventWindowContent(),
            cssClass: EVENT_WINDOW_DIALOG_CLASS,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            height: this.parent.isAdaptive ? '100%' : 'auto',
            minHeight: '300px',
            isModal: true,
            showCloseIcon: this.parent.isAdaptive ? false : true,
            target: document.body,
            visible: false,
            width: '500px',
            beforeOpen: this.onBeforeOpen.bind(this),
            beforeClose: this.onBeforeClose.bind(this)
        };
        if (this.parent.isAdaptive) {
            dialogModel.cssClass = EVENT_WINDOW_DIALOG_CLASS + ' ' + DEVICE_CLASS;
            dialogModel.header = '<div class="e-title-header"><div class="e-back-icon e-icons"></div><div class="e-title-text">' +
                this.l10n.getConstant('newEvent') + '</div><div class="e-save-icon e-icons"></div></div>';
        }
        else {
            dialogModel.buttons = [{
                    buttonModel: {
                        content: this.l10n.getConstant('deleteButton'), cssClass: DELETE_EVENT_CLASS,
                        disabled: !this.parent.eventSettings.allowDeleting || this.parent.readonly
                    },
                    click: this.eventDelete.bind(this)
                }, {
                    buttonModel: {
                        content: this.l10n.getConstant('saveButton'), cssClass: 'e-primary ' + EVENT_WINDOW_SAVE_BUTTON_CLASS,
                        isPrimary: true, disabled: !this.parent.eventSettings.allowAdding || this.parent.readonly
                    },
                    click: this.eventSave.bind(this)
                }, {
                    buttonModel: { cssClass: EVENT_WINDOW_CANCEL_BUTTON_CLASS, content: this.l10n.getConstant('cancelButton') },
                    click: this.dialogClose.bind(this)
                }];
            dialogModel.header = '<div class="e-title-text">' + this.l10n.getConstant('newEvent') + '</div>';
        }
        this.dialogObject = new Dialog(dialogModel, this.element);
        if (this.dialogObject.element.querySelector('.e-dlg-closeicon-btn')) {
            this.dialogObject.element.querySelector('.e-dlg-closeicon-btn').setAttribute('title', this.l10n.getConstant('close'));
        }
        addClass([this.element.parentElement], EVENT_WINDOW_DIALOG_CLASS + '-container');
        if (this.parent.isAdaptive) {
            EventHandler.add(this.element.querySelector('.' + EVENT_WINDOW_BACK_ICON_CLASS), 'click', this.dialogClose, this);
            EventHandler.add(this.element.querySelector('.' + EVENT_WINDOW_SAVE_ICON_CLASS), 'click', this.eventSave, this);
        }
        EventHandler.add(this.dialogObject.element, 'keydown', this.preventEventSave, this);
        this.applyFormValidation();
    }
    refresh() {
        this.destroy(true);
        this.renderEventWindow();
    }
    refreshRecurrenceEditor() {
        if (this.recurrenceEditor) {
            const recurrenceEditor = this.recurrenceEditor.element;
            this.recurrenceEditor.destroy();
            this.createRecurrenceEditor(recurrenceEditor);
        }
    }
    setRecurrenceEditor(recurrenceEditor) {
        if (this.parent.editorTemplate) {
            this.recurrenceEditor = recurrenceEditor;
        }
    }
    openEditor(data, type, isEventData, repeatType) {
        this.parent.currentAction = type;
        this.parent.removeNewEventElement();
        if (this.parent.quickPopup) {
            this.parent.quickPopup.quickPopupHide(true);
        }
        this.parent.inlineModule.removeInlineAppointmentElement();
        if (type === 'Add') {
            let eventObj = {};
            this.cellClickAction = !isEventData;
            this.parent.activeCellsData = data;
            const event = data;
            if (this.cellClickAction) {
                this.convertToEventData(event, eventObj);
            }
            else {
                this.parent.activeCellsData = {
                    startTime: (event.startTime || event[this.fields.startTime]),
                    endTime: (event.endTime || event[this.fields.endTime]),
                    isAllDay: (event.isAllDay || event[this.fields.isAllDay]),
                    element: event.element,
                    groupIndex: event.groupIndex
                };
                eventObj = event;
            }
            data = eventObj;
        }
        if (!isNullOrUndefined(this.parent.editorTemplate)) {
            this.renderFormElements(this.element.querySelector('.e-schedule-form'), data);
        }
        if (!this.parent.isAdaptive && isNullOrUndefined(this.parent.editorTemplate)) {
            removeClass([this.dialogObject.element.querySelector('.e-recurrenceeditor')], DISABLE_CLASS);
        }
        if (this.recurrenceEditor) {
            this.recurrenceEditor.firstDayOfWeek = this.parent.activeViewOptions.firstDayOfWeek;
        }
        switch (type) {
            case 'Add':
                this.onCellDetailsUpdate(data, repeatType);
                break;
            case 'Save':
            case 'EditOccurrence':
            case 'EditSeries':
            case 'EditFollowingEvents':
                if (type === 'EditOccurrence' && !this.parent.isAdaptive && isNullOrUndefined(this.parent.editorTemplate)) {
                    addClass([this.dialogObject.element.querySelector('.e-recurrenceeditor')], DISABLE_CLASS);
                }
                this.cellClickAction = false;
                this.onEventDetailsUpdate(data);
                break;
        }
    }
    setDialogContent() {
        this.dialogObject.content = this.getEventWindowContent();
        this.dialogObject.dataBind();
        this.applyFormValidation();
    }
    preventEventSave(e) {
        if (this.parent && !this.parent.allowKeyboardInteraction && e.code === 'Enter') {
            this.isEnterKey = true;
        }
    }
    onBeforeOpen(args) {
        const eventProp = {
            type: 'Editor',
            data: this.eventData,
            cancel: false,
            element: this.element,
            target: (this.cellClickAction ? this.parent.activeCellsData.element : this.parent.activeEventData.element)
        };
        if (this.cellClickAction) {
            eventProp.duration = this.getSlotDuration();
        }
        const saveObj = this.getInstance(EVENT_WINDOW_SAVE_BUTTON_CLASS);
        if (saveObj) {
            saveObj.disabled = !(this.cellClickAction ? this.parent.eventSettings.allowAdding : this.parent.eventSettings.allowEditing);
            saveObj.dataBind();
        }
        const deleteObj = this.getInstance(DELETE_EVENT_CLASS);
        if (deleteObj) {
            deleteObj.disabled = !this.parent.eventSettings.allowDeleting;
            deleteObj.dataBind();
        }
        const callBackPromise = new Deferred();
        this.parent.trigger(popupOpen, eventProp, (popupArgs) => {
            args.cancel = popupArgs.cancel;
            this.duration = this.cellClickAction ? popupArgs.duration : null;
            this.refreshDateTimePicker(this.duration);
            if (this.cellClickAction && popupArgs.duration !== this.getSlotDuration() && isNullOrUndefined(this.parent.editorTemplate)) {
                const startObj = this.getInstance(EVENT_WINDOW_START_CLASS);
                const endObj = this.getInstance(EVENT_WINDOW_END_CLASS);
                endObj.value = new Date(startObj.value.getTime() + (MS_PER_MINUTE * popupArgs.duration));
                endObj.dataBind();
            }
            if (this.parent.editorTemplate && this.element.querySelector('.e-recurrenceeditor') && !this.recurrenceEditor) {
                this.recurrenceEditor = this.getInstance('e-recurrenceeditor');
            }
            callBackPromise.resolve(args);
        });
        return callBackPromise;
    }
    onBeforeClose(args) {
        if (args.isInteracted) {
            this.isCrudAction = false;
        }
        const eventProp = {
            type: 'Editor',
            event: args.event || this.dialogEvent,
            data: this.eventCrudData,
            cancel: false,
            element: this.element,
            target: (this.cellClickAction ? this.parent.activeCellsData.element : this.parent.activeEventData.element)
        };
        const callBackPromise = new Deferred();
        this.parent.trigger(popupClose, eventProp, (popupArgs) => {
            args.cancel = popupArgs.cancel;
            if (!popupArgs.cancel) {
                if (this.isCrudAction) {
                    args.cancel = this.processCrudActions(popupArgs.data);
                    this.isCrudAction = args.cancel;
                }
                if (!this.isCrudAction) {
                    this.resetForm();
                    this.parent.eventBase.focusElement(true);
                    this.eventCrudData = null;
                }
            }
            callBackPromise.resolve(args);
        });
        return callBackPromise;
    }
    getEventWindowContent() {
        const container = createElement('div', { className: FORM_CONTAINER_CLASS });
        const form = createElement('form', {
            id: this.parent.element.id + 'EditForm',
            className: FORM_CLASS,
            attrs: { onsubmit: 'return false;' }
        });
        this.renderFormElements(form);
        container.appendChild(form);
        return container;
    }
    renderFormElements(form, args) {
        if (!isNullOrUndefined(this.parent.editorTemplate)) {
            if (args) {
                if (this.fieldValidator) {
                    this.fieldValidator.destroy();
                    this.fieldValidator = null;
                }
                if (this.recurrenceEditor) {
                    this.recurrenceEditor.destroy();
                    this.recurrenceEditor = null;
                }
                this.destroyComponents();
                const formElements = [].slice.call(form.children);
                for (const element of formElements) {
                    remove(element);
                }
                this.parent.resetTemplates(['editorTemplate']);
            }
            const templateId = this.parent.element.id + '_editorTemplate';
            const tempEle = [].slice.call(this.parent.getEditorTemplate()(args || {}, this.parent, 'editorTemplate', templateId, false));
            append(tempEle, form);
            this.parent.renderTemplates(() => {
                if (this.element) {
                    this.applyFormValidation();
                }
            });
        }
        else {
            form.appendChild(this.getDefaultEventWindowContent());
        }
    }
    getDefaultEventWindowContent() {
        const parentDiv = this.createDivElement(EVENT_WINDOW_DIALOG_PARENT_CLASS);
        const titleLocationDiv = this.createDivElement(EVENT_WINDOW_TITLE_LOCATION_DIV_CLASS);
        parentDiv.appendChild(titleLocationDiv);
        titleLocationDiv.appendChild(this.renderTextBox(SUBJECT_CLASS));
        titleLocationDiv.querySelector('.' + SUBJECT_CLASS).setAttribute('title', this.parent.editorTitles.subject);
        titleLocationDiv.appendChild(this.renderTextBox(LOCATION_CLASS));
        titleLocationDiv.querySelector('.' + LOCATION_CLASS).setAttribute('title', this.parent.editorTitles.location);
        const startEndDateTimeDiv = this.createDivElement(EVENT_WINDOW_START_END_DIV_CLASS);
        parentDiv.appendChild(startEndDateTimeDiv);
        startEndDateTimeDiv.appendChild(this.renderDateTimePicker(EVENT_WINDOW_START_CLASS, this.onTimeChange.bind(this)));
        startEndDateTimeDiv.querySelector('.' + EVENT_WINDOW_START_CLASS).setAttribute('title', this.parent.editorTitles.startTime);
        startEndDateTimeDiv.appendChild(this.renderDateTimePicker(EVENT_WINDOW_END_CLASS));
        startEndDateTimeDiv.querySelector('.' + EVENT_WINDOW_END_CLASS).setAttribute('title', this.parent.editorTitles.endTime);
        const allDayTimezoneDiv = this.createDivElement(EVENT_WINDOW_ALLDAY_TZ_DIV_CLASS);
        parentDiv.appendChild(allDayTimezoneDiv);
        allDayTimezoneDiv.appendChild(this.renderCheckBox(EVENT_WINDOW_ALL_DAY_CLASS));
        allDayTimezoneDiv.appendChild(this.renderCheckBox(TIME_ZONE_CLASS));
        const timezoneParentDiv = this.createDivElement(EVENT_WINDOW_TIME_ZONE_DIV_CLASS);
        parentDiv.appendChild(timezoneParentDiv);
        timezoneParentDiv.appendChild(this.renderDropDown(EVENT_WINDOW_START_TZ_CLASS));
        timezoneParentDiv.appendChild(this.renderDropDown(EVENT_WINDOW_END_TZ_CLASS));
        const repeatParentDiv = this.createDivElement(EVENT_WINDOW_REPEAT_DIV_CLASS);
        parentDiv.appendChild(repeatParentDiv);
        const repeatDiv = this.renderCheckBox(EVENT_WINDOW_REPEAT_CLASS);
        const repeatEditContainer = createElement('span', { className: REPEAT_CONTAINER_CLASS });
        const button = createElement('button', {
            className: REPEAT_BUTTON_CLASS,
            attrs: { type: 'button', 'title': this.l10n.getConstant('editRecurrence') }
        });
        this.buttonObj = new Button({ iconCss: REPEAT_BUTTON_ICON_CLASS + ' e-icons', cssClass: 'e-medium ' + this.parent.cssClass });
        repeatEditContainer.appendChild(button);
        this.buttonObj.appendTo(button);
        repeatDiv.appendChild(repeatEditContainer);
        repeatParentDiv.appendChild(repeatDiv);
        if (this.parent.isAdaptive) {
            EventHandler.add(button, 'click', this.loadRecurrenceEditor, this);
        }
        else {
            this.createRecurrenceEditor(parentDiv);
        }
        if (this.parent.resourceCollection.length > 0) {
            const resourceParentDiv = this.createDivElement(EVENT_WINDOW_RESOURCES_DIV_CLASS);
            for (const resource of this.parent.resourceBase.resourceCollection) {
                resourceParentDiv.appendChild(this.renderResourceDetails(resource));
            }
            parentDiv.appendChild(resourceParentDiv);
        }
        const description = this.createDivElement(DESCRIPTION_CLASS + '-row');
        description.appendChild(this.renderTextBox(DESCRIPTION_CLASS));
        description.querySelector('.' + DESCRIPTION_CLASS).setAttribute('title', this.parent.editorTitles.description);
        parentDiv.appendChild(description);
        const submit = createElement('button', { attrs: { type: 'hidden', title: 'submit', style: 'display:none' } });
        parentDiv.appendChild(submit);
        return parentDiv;
    }
    createRecurrenceEditor(parentDiv) {
        const recurrenceEditor = createElement('div', { id: this.parent.element.id + '_recurrence_editor' });
        parentDiv.appendChild(recurrenceEditor);
        this.recurrenceEditor = this.renderRecurrenceEditor();
        this.recurrenceEditor.appendTo(recurrenceEditor);
        this.updateMinMaxDateToEditor();
    }
    createDivElement(className) {
        return createElement('div', { className: className });
    }
    createInputElement(className, fieldName, type) {
        return createElement(type || 'input', {
            className: className, attrs: {
                type: 'text', name: fieldName, value: '', id: fieldName,
                title: ((this.l10n.getConstant(fieldName.charAt(0).toLowerCase() + fieldName.slice(1))) === '') ?
                    fieldName : this.l10n.getConstant(fieldName.charAt(0).toLowerCase() + fieldName.slice(1))
            }
        });
    }
    getSlotDuration() {
        return this.parent.activeViewOptions.timeScale.interval / this.parent.activeViewOptions.timeScale.slotCount;
    }
    renderDateTimePicker(value, changeEvent) {
        const dateTimeDiv = this.createDivElement(value + '-container');
        const fieldName = this.getFieldName(value);
        const dateTimeInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName);
        dateTimeDiv.appendChild(dateTimeInput);
        const dateTimePicker = new DateTimePicker({
            change: changeEvent,
            firstDayOfWeek: this.parent.activeViewOptions.firstDayOfWeek,
            calendarMode: this.parent.calendarMode,
            min: this.parent.minDate,
            max: new Date(new Date(+this.parent.maxDate).setHours(23, 59, 59)),
            cssClass: this.parent.cssClass,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            floatLabelType: 'Always',
            timeFormat: this.parent.activeViewOptions.timeFormat,
            format: (isNullOrUndefined(this.parent.dateFormat) ?
                this.getFormat('dateFormats') : this.parent.dateFormat) + ' ' + this.parent.activeViewOptions.timeFormat,
            placeholder: this.getFieldLabel(value),
            step: this.getSlotDuration(),
            width: '100%'
        });
        dateTimePicker.appendTo(dateTimeInput);
        return dateTimeDiv;
    }
    refreshDateTimePicker(duration) {
        const elementSelector = '.' + EVENT_WINDOW_START_CLASS + ',.' + EVENT_WINDOW_END_CLASS;
        const startEndElement = [].slice.call(this.element.querySelectorAll(elementSelector));
        for (const element of startEndElement) {
            const instance = element.ej2_instances[0];
            instance.firstDayOfWeek = this.parent.activeViewOptions.firstDayOfWeek;
            instance.timeFormat = this.parent.activeViewOptions.timeFormat;
            instance.step = duration || this.getSlotDuration();
            instance.dataBind();
        }
    }
    onTimeChange() {
        const startObj = this.getInstance(EVENT_WINDOW_START_CLASS);
        if (startObj.element.parentElement.classList.contains('e-input-focus')) {
            const endObj = this.getInstance(EVENT_WINDOW_END_CLASS);
            let duration = 0;
            if (this.cellClickAction) {
                duration = MS_PER_MINUTE * this.duration;
                this.eventWindowTime.startTime = startObj.value;
            }
            else {
                duration = this.eventData[this.fields.endTime].getTime() - this.eventData[this.fields.startTime].getTime();
            }
            const endDate = (isNullOrUndefined(startObj.value)) ? null : new Date(startObj.value.getTime() + duration);
            if (this.cellClickAction) {
                this.eventWindowTime.endTime = endDate;
            }
            endObj.value = endDate;
            endObj.dataBind();
        }
        if (this.recurrenceEditor) {
            this.recurrenceEditor.updateRuleUntilDate(this.eventWindowTime.startTime);
        }
    }
    renderResourceDetails(resourceData) {
        const fieldName = resourceData.field;
        const value = 'e-' + fieldName;
        const labelValue = resourceData.title;
        const resourceDiv = this.createDivElement(value + '-container' + ' ' + 'e-resources');
        const resourceInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName);
        resourceDiv.appendChild(resourceInput);
        const resourceTemplate = '<div class="e-resource-template"><div class="e-resource-color" style="background-color:${' +
            resourceData.colorField + '}"></div><div class="e-resource-text">${' + resourceData.textField + '}</div></div>';
        if (resourceData.allowMultiple) {
            const listObj = new MultiSelect({
                enableRtl: this.parent.enableRtl,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                cssClass: this.parent.cssClass || '',
                dataSource: resourceData.dataSource,
                change: this.onMultiselectResourceChange.bind(this),
                itemTemplate: resourceTemplate,
                fields: {
                    text: resourceData.textField,
                    value: resourceData.idField
                },
                htmlAttributes: { 'title': labelValue, 'name': fieldName },
                floatLabelType: 'Always',
                placeholder: labelValue,
                popupHeight: '230px',
                popupWidth: '447px',
                mode: 'Box'
            });
            listObj.appendTo(resourceInput);
        }
        else {
            const dropDownList = new DropDownList({
                cssClass: this.parent.cssClass || '',
                change: this.onDropdownResourceChange.bind(this),
                dataSource: resourceData.dataSource,
                enableRtl: this.parent.enableRtl,
                fields: {
                    text: resourceData.textField,
                    value: resourceData.idField
                },
                htmlAttributes: { 'title': labelValue, 'name': fieldName },
                floatLabelType: 'Always',
                placeholder: labelValue,
                popupHeight: '230px',
                popupWidth: '447px',
                itemTemplate: resourceTemplate
            });
            dropDownList.appendTo(resourceInput);
        }
        return resourceDiv;
    }
    renderDropDown(value) {
        const fieldName = this.getFieldName(value);
        const timezoneDiv = this.createDivElement(value + '-container');
        const timezoneInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName);
        timezoneDiv.appendChild(timezoneInput);
        const dropDownList = new DropDownList({
            allowFiltering: true,
            change: this.onTimezoneChange.bind(this),
            cssClass: this.parent.cssClass || '',
            dataSource: this.parent.timezoneDataSource,
            enableRtl: this.parent.enableRtl,
            fields: { text: 'Text', value: 'Value' },
            filterBarPlaceholder: this.parent.localeObj.getConstant('searchTimezone'),
            noRecordsTemplate: this.parent.localeObj.getConstant('noRecords'),
            filtering: (e) => {
                let query = new Query();
                query = (e.text !== '') ? query.where('Text', 'contains', e.text, true) : query;
                e.updateData(this.parent.timezoneDataSource, query);
            },
            htmlAttributes: { 'title': this.getFieldLabel(value), 'name': fieldName, role: 'option' },
            floatLabelType: 'Always',
            placeholder: this.getFieldLabel(value),
            popupHeight: '230px'
        });
        dropDownList.appendTo(timezoneInput);
        return timezoneDiv;
    }
    onMultiselectResourceChange(args) {
        if (!args.value || !this.parent.activeViewOptions.group.byGroupID || this.parent.resourceCollection.length <= 1) {
            return;
        }
        const resourceCollection = this.parent.resourceBase.resourceCollection;
        const fieldName = args.element.getAttribute('name') || this.getColumnName(args.element);
        for (let i = 0; i < resourceCollection.length; i++) {
            if (resourceCollection[parseInt(i.toString(), 10)].field === fieldName && i < resourceCollection.length - 1) {
                const resObject = this.createInstance(i);
                let datasource = [];
                for (let j = 0; j < args.value.length; j++) {
                    const resourceModel = resourceCollection[i + 1];
                    // eslint-disable-next-line max-len
                    const filter = resourceModel.dataSource.filter((data) => data[resourceModel.groupIDField] === args.value[parseInt(j.toString(), 10)])[0];
                    const groupId = (!isNullOrUndefined(filter)) ?
                        filter[resourceCollection[i + 1].groupIDField] : null;
                    const filterRes = this.filterDatasource(i, groupId);
                    datasource = datasource.concat(filterRes);
                }
                resObject.dataSource = datasource;
                resObject.dataBind();
            }
        }
    }
    createInstance(index) {
        const resourceData = this.parent.resourceBase.resourceCollection[index + 1];
        const resObject = this.element.querySelector('.e-' + resourceData.field).
            ej2_instances[0];
        resObject.clear();
        return resObject;
    }
    onDropdownResourceChange(args) {
        if (!args.value || this.parent.resourceCollection.length <= 1 || !this.parent.activeViewOptions.group.byGroupID) {
            return;
        }
        const fieldName = args.element.getAttribute('name') || this.getColumnName(args.element);
        const resourceCollection = this.parent.resourceBase.resourceCollection;
        for (let i = 0; i < resourceCollection.length; i++) {
            if ((i < resourceCollection.length - 1) && resourceCollection[parseInt(i.toString(), 10)].field === fieldName) {
                const resObj = this.createInstance(i);
                const groupId = args.itemData[resourceCollection[parseInt(i.toString(), 10)].idField];
                resObj.dataSource = this.filterDatasource(i, groupId);
                resObj.dataBind();
                const resValue = (resObj.dataSource.length > 0) ?
                    resObj.dataSource[0][resourceCollection[i + 1].idField] : null;
                resObj.value = (resourceCollection[i + 1].allowMultiple) ? [resValue] : resValue;
                resObj.dataBind();
            }
        }
    }
    filterDatasource(index, groupId) {
        const resourceData = this.parent.resourceBase.resourceCollection[index + 1];
        return resourceData.dataSource.filter((data) => data[resourceData.groupIDField] === groupId);
    }
    onTimezoneChange(args) {
        const fieldName = args.element.getAttribute('name') || this.getColumnName(args.element);
        if (fieldName === this.parent.eventFields.startTimezone) {
            const startTimezoneObj = this.getInstance(EVENT_WINDOW_START_TZ_CLASS);
            const endTimezoneObj = this.getInstance(EVENT_WINDOW_END_TZ_CLASS);
            endTimezoneObj.value = startTimezoneObj.value;
            endTimezoneObj.dataBind();
        }
    }
    renderCheckBox(value) {
        const checkBoxDiv = this.createDivElement(value + '-container');
        const fieldName = this.getFieldName(value);
        const checkBoxInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName);
        checkBoxDiv.appendChild(checkBoxInput);
        const checkBox = new CheckBox({
            change: this.onChange.bind(this),
            cssClass: value + ' ' + this.parent.cssClass,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            label: this.getFieldLabel(value)
        });
        checkBox.appendTo(checkBoxInput);
        checkBoxInput.setAttribute('name', fieldName);
        if (fieldName === 'Repeat') {
            this.repeatStatus = checkBox;
        }
        return checkBoxDiv;
    }
    renderTextBox(value) {
        const textBoxDiv = this.createDivElement(value + '-container');
        const fieldName = this.getFieldName(value);
        const elementType = (value === DESCRIPTION_CLASS) ? 'textarea' : 'input';
        const textBoxInput = this.createInputElement(value + ' ' + EVENT_FIELD$1, fieldName, elementType);
        textBoxDiv.appendChild(textBoxInput);
        Input.createInput({
            element: textBoxInput,
            floatLabelType: 'Always',
            properties: {
                enableRtl: this.parent.enableRtl,
                placeholder: this.getFieldLabel(value)
            }
        });
        return textBoxDiv;
    }
    getFieldName(name) {
        let fieldName = '';
        switch (name) {
            case SUBJECT_CLASS:
                fieldName = this.fields.subject;
                break;
            case LOCATION_CLASS:
                fieldName = this.fields.location;
                break;
            case EVENT_WINDOW_START_CLASS:
                fieldName = this.fields.startTime;
                break;
            case EVENT_WINDOW_END_CLASS:
                fieldName = this.fields.endTime;
                break;
            case DESCRIPTION_CLASS:
                fieldName = this.fields.description;
                break;
            case EVENT_WINDOW_ALL_DAY_CLASS:
                fieldName = this.fields.isAllDay;
                break;
            case EVENT_WINDOW_START_TZ_CLASS:
                fieldName = this.fields.startTimezone;
                break;
            case EVENT_WINDOW_END_TZ_CLASS:
                fieldName = this.fields.endTimezone;
                break;
            case TIME_ZONE_CLASS:
                fieldName = 'Timezone';
                break;
            case EVENT_WINDOW_REPEAT_CLASS:
                fieldName = 'Repeat';
                break;
        }
        return fieldName;
    }
    getFieldLabel(fieldName) {
        let labelText = '';
        switch (fieldName) {
            case SUBJECT_CLASS:
                labelText = this.parent.editorTitles.subject;
                break;
            case LOCATION_CLASS:
                labelText = this.parent.editorTitles.location;
                break;
            case DESCRIPTION_CLASS:
                labelText = this.parent.editorTitles.description;
                break;
            case EVENT_WINDOW_START_CLASS:
                labelText = this.parent.editorTitles.startTime;
                break;
            case EVENT_WINDOW_END_CLASS:
                labelText = this.parent.editorTitles.endTime;
                break;
            case EVENT_WINDOW_START_TZ_CLASS:
                labelText = this.parent.editorTitles.startTimezone;
                break;
            case EVENT_WINDOW_END_TZ_CLASS:
                labelText = this.parent.editorTitles.endTimezone;
                break;
            case EVENT_WINDOW_REPEAT_CLASS:
                labelText = this.parent.editorTitles.recurrenceRule;
                break;
            case EVENT_WINDOW_ALL_DAY_CLASS:
                labelText = this.parent.editorTitles.isAllDay;
                break;
            case TIME_ZONE_CLASS:
                labelText = this.l10n.getConstant('timezone');
                break;
        }
        return labelText;
    }
    onChange(args) {
        const targetSelector = `.${EVENT_WINDOW_ALL_DAY_CLASS},.${TIME_ZONE_CLASS},.${EVENT_WINDOW_REPEAT_CLASS}`;
        const target = closest(args.event.target, targetSelector);
        if (target.classList.contains(EVENT_WINDOW_ALL_DAY_CLASS)) {
            this.onAllDayChange(args.checked);
        }
        else if (target.classList.contains(TIME_ZONE_CLASS)) {
            this.timezoneChangeStyle(args.checked);
        }
        else if (target.classList.contains(EVENT_WINDOW_REPEAT_CLASS)) {
            this.onRepeatChange(args.checked);
        }
    }
    renderRepeatDialog() {
        const element = createElement('div');
        this.repeatDialogObject = new Dialog({
            header: this.l10n.getConstant('recurrence'),
            visible: false,
            content: '<div class="e-rec-editor"></div>',
            closeOnEscape: true,
            width: '90%',
            buttons: [{
                    click: this.repeatSaveDialog.bind(this),
                    buttonModel: { content: this.l10n.getConstant('save'), cssClass: 'e-save', isPrimary: true }
                },
                { click: this.repeatCancelDialog.bind(this), buttonModel: { cssClass: 'e-cancel', content: this.l10n.getConstant('cancel') } }],
            target: this.element,
            animationSettings: { effect: 'Zoom' },
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            isModal: true,
            cssClass: REPEAT_DIALOG_CLASS,
            open: this.repeatOpenDialog.bind(this)
        });
        this.element.appendChild(element);
        this.repeatDialogObject.appendTo(element);
        this.createRecurrenceEditor(this.repeatDialogObject.element.querySelector('.e-rec-editor'));
    }
    loadRecurrenceEditor() {
        this.repeatDialogObject.show();
        if (this.recurrenceEditor && this.repeatRule) {
            this.recurrenceEditor.setRecurrenceRule(this.repeatRule);
        }
    }
    onRepeatChange(state) {
        if (state) {
            if (!this.repeatDialogObject) {
                this.renderRepeatDialog();
            }
            this.recurrenceEditor.setProperties({ startDate: this.repeatStartDate, selectedType: 0 });
            this.loadRecurrenceEditor();
        }
        else {
            if (this.repeatDialogObject) {
                this.repeatDialogObject.hide();
            }
            this.repeatRule = '';
            if (this.recurrenceEditor) {
                this.recurrenceEditor.setRecurrenceRule(this.repeatRule);
                this.updateRepeatLabel(this.repeatRule);
            }
            const element = this.element.querySelector('.' + REPEAT_CONTAINER_CLASS);
            addClass([element], HIDE_STYLE_CLASS);
        }
    }
    repeatSaveDialog() {
        this.repeatRule = this.recurrenceEditor.getRecurrenceRule();
        const element = this.element.querySelector('.' + REPEAT_CONTAINER_CLASS);
        if (this.recurrenceEditor.getRecurrenceRule()) {
            removeClass([element], HIDE_STYLE_CLASS);
        }
        else {
            addClass([element], HIDE_STYLE_CLASS);
            this.repeatStatus.setProperties({ checked: false });
        }
        this.updateRepeatLabel(this.repeatRule);
        this.closeRepeatDialog();
    }
    closeRepeatDialog() {
        this.repeatDialogObject.hide();
    }
    repeatCancelDialog() {
        this.closeRepeatDialog();
        if (this.recurrenceEditor) {
            this.recurrenceEditor.setRecurrenceRule(this.repeatTempRule);
        }
        if (!this.repeatTempRule) {
            this.repeatStatus.setProperties({ checked: false });
        }
    }
    repeatOpenDialog() {
        this.repeatTempRule = this.recurrenceEditor.getRecurrenceRule();
    }
    onCellDetailsUpdate(eventObj, repeatType) {
        if (!this.parent.eventSettings.allowAdding) {
            return;
        }
        if (this.parent.isAdaptive && repeatType && !this.repeatDialogObject) {
            this.renderRepeatDialog();
        }
        this.element.querySelector('.' + FORM_CLASS).removeAttribute('data-id');
        this.element.querySelector('.' + EVENT_WINDOW_TITLE_TEXT_CLASS).innerHTML = this.l10n.getConstant('newEvent');
        eventObj.Timezone = false;
        this.repeatStartDate = eventObj[this.fields.startTime];
        this.repeatRule = '';
        if (!isNullOrUndefined(this.parent.eventSettings.fields.subject.default)) {
            eventObj[this.fields.subject] = this.parent.eventSettings.fields.subject.default;
        }
        if (!isNullOrUndefined(this.parent.eventSettings.fields.location.default)) {
            eventObj[this.fields.location] = this.parent.eventSettings.fields.location.default;
        }
        if (!isNullOrUndefined(this.parent.eventSettings.fields.description.default)) {
            eventObj[this.fields.description] = this.parent.eventSettings.fields.description.default;
        }
        this.showDetails(eventObj);
        if (eventObj[this.fields.recurrenceRule] && this.recurrenceEditor) {
            this.recurrenceEditor.setRecurrenceRule(eventObj[this.fields.recurrenceRule], eventObj[this.fields.startTime]);
            this.repeatRule = eventObj[this.fields.recurrenceRule];
        }
        const deleteButton = this.element.querySelector('.' + DELETE_EVENT_CLASS);
        if (deleteButton) {
            addClass([deleteButton], DISABLE_CLASS);
        }
        if (this.recurrenceEditor) {
            this.recurrenceEditor.setProperties({
                startDate: eventObj[this.fields.startTime],
                selectedType: !isNullOrUndefined(repeatType) ? repeatType : !isNullOrUndefined(eventObj[this.fields.recurrenceRule]) ?
                    this.recurrenceEditor.selectedType : 0
            });
            this.repeatRule = this.recurrenceEditor.value;
        }
        if (this.parent.isAdaptive && isNullOrUndefined(this.parent.editorTemplate)) {
            const element = this.element.querySelector('.' + REPEAT_CONTAINER_CLASS);
            if (eventObj[this.fields.recurrenceRule] || repeatType) {
                removeClass([element], HIDE_STYLE_CLASS);
                this.repeatStatus.setProperties({ checked: true });
            }
            else {
                addClass([element], HIDE_STYLE_CLASS);
                this.repeatStatus.setProperties({ checked: false });
            }
            this.updateRepeatLabel(this.repeatRule);
        }
        else {
            const saveButton = this.element.querySelector('.' + EVENT_WINDOW_SAVE_BUTTON_CLASS);
            this.disableButton(saveButton, false);
        }
        this.dialogObject.show();
    }
    convertToEventData(cellsData, eventObj) {
        if (cellsData.subject) {
            eventObj[this.fields.subject] = cellsData.subject;
        }
        eventObj[this.fields.startTime] = cellsData.startTime;
        eventObj[this.fields.endTime] = cellsData.endTime;
        eventObj[this.fields.isAllDay] = cellsData.isAllDay;
        if (cellsData.RecurrenceRule) {
            eventObj[this.fields.recurrenceRule] = cellsData.RecurrenceRule;
        }
        if (this.parent.resourceCollection.length > 0 || this.parent.activeViewOptions.group.resources.length > 0) {
            this.parent.resourceBase.setResourceValues(eventObj);
        }
    }
    applyFormValidation() {
        const form = this.element.querySelector('.' + FORM_CLASS);
        if (!form) {
            return;
        }
        const getValidationRule = (rules) => (rules && Object.keys(rules).length > 0) ? rules : undefined;
        const rules = {};
        const subjectRule = getValidationRule(this.parent.eventSettings.fields.subject.validation);
        if (!isNullOrUndefined(subjectRule)) {
            rules[this.parent.eventSettings.fields.subject.name] = subjectRule;
        }
        const locationRule = getValidationRule(this.parent.eventSettings.fields.location.validation);
        if (!isNullOrUndefined(locationRule)) {
            rules[this.parent.eventSettings.fields.location.name] = locationRule;
        }
        const startTimeRule = getValidationRule(this.parent.eventSettings.fields.startTime.validation);
        if (!isNullOrUndefined(startTimeRule)) {
            rules[this.parent.eventSettings.fields.startTime.name] = startTimeRule;
        }
        const endTimeRule = getValidationRule(this.parent.eventSettings.fields.endTime.validation);
        if (!isNullOrUndefined(endTimeRule)) {
            rules[this.parent.eventSettings.fields.endTime.name] = endTimeRule;
        }
        const descriptionRule = getValidationRule(this.parent.eventSettings.fields.description.validation);
        if (!isNullOrUndefined(descriptionRule)) {
            rules[this.parent.eventSettings.fields.description.name] = descriptionRule;
        }
        this.fieldValidator = new FieldValidator();
        this.fieldValidator.renderFormValidator(form, rules, this.element, this.parent.locale);
    }
    showDetails(eventData) {
        const eventObj = extend({}, eventData, null, true);
        if ((!this.cellClickAction || this.cellClickAction && !isNullOrUndefined(this.parent.editorTemplate)) &&
            eventObj[this.fields.endTime].getHours() === 0 && eventObj[this.fields.endTime].getMinutes() === 0) {
            this.trimAllDay(eventObj);
        }
        this.eventData = eventObj;
        const formElements = this.getFormElements(EVENT_WINDOW_DIALOG_CLASS);
        const keyNames = Object.keys(eventObj);
        for (const curElement of formElements) {
            const columnName = curElement.name || this.getColumnName(curElement);
            if (!isNullOrUndefined(columnName) && columnName !== '') {
                if (keyNames.indexOf(columnName) !== -1) {
                    this.setValueToElement(curElement, eventObj[`${columnName}`]);
                }
                else {
                    this.setDefaultValueToElement(curElement);
                }
            }
        }
        if (isNullOrUndefined(this.parent.editorTemplate)) {
            this.onAllDayChange(eventObj[this.fields.isAllDay]);
            const timezoneObj = this.getInstance(TIME_ZONE_CLASS + '.' + EVENT_FIELD$1);
            if (!(isNullOrUndefined(eventObj[this.fields.startTimezone]) && isNullOrUndefined(eventObj[this.fields.endTimezone]))) {
                timezoneObj.checked = true;
                timezoneObj.dataBind();
            }
            this.timezoneChangeStyle(timezoneObj.checked);
            delete eventObj.Timezone;
        }
    }
    getColumnName(element) {
        let attrName = element.getAttribute('data-name') || '';
        if (attrName === '') {
            let isDropDowns = false;
            let fieldSelector = '';
            if (element.classList.contains('e-dropdownlist')) {
                fieldSelector = 'e-ddl';
                isDropDowns = true;
            }
            else if (element.classList.contains('e-multiselect')) {
                fieldSelector = 'e-multiselect';
                isDropDowns = true;
            }
            else if (element.classList.contains('e-datetimepicker')) {
                fieldSelector = 'e-datetimepicker';
            }
            else if (element.classList.contains('e-datepicker')) {
                fieldSelector = 'e-datepicker';
            }
            else if (element.classList.contains('e-checkbox')) {
                fieldSelector = 'e-checkbox';
            }
            const classSelector = isDropDowns ? `.${fieldSelector}:not(.e-control)` : `.${fieldSelector}`;
            const control = closest(element, classSelector) || element.querySelector(`.${fieldSelector}`);
            if (control) {
                const attrEle = control.querySelector('[name]');
                if (attrEle) {
                    attrName = attrEle.name;
                }
            }
        }
        return attrName;
    }
    onAllDayChange(allDayStatus) {
        const startObj = this.getInstance(EVENT_WINDOW_START_CLASS);
        const endObj = this.getInstance(EVENT_WINDOW_END_CLASS);
        const timezoneDiv = this.element.querySelector('.e-time-zone-container');
        let format;
        if (allDayStatus) {
            format = (isNullOrUndefined(this.parent.dateFormat)) ? this.getFormat('dateFormats') : this.parent.dateFormat;
            addClass(this.element.querySelectorAll('.e-time-icon'), EVENT_WINDOW_ICON_DISABLE_CLASS);
            addClass([timezoneDiv], DISABLE_CLASS);
            if (this.element.querySelector('.' + EVENT_WINDOW_TIME_ZONE_DIV_CLASS)) {
                removeClass([this.element.querySelector('.' + EVENT_WINDOW_TIME_ZONE_DIV_CLASS)], ENABLE_CLASS);
            }
            startObj.format = endObj.format = format;
        }
        else {
            format = (isNullOrUndefined(this.parent.dateFormat)) ? this.getFormat('dateFormats') + ' ' +
                this.parent.activeViewOptions.timeFormat : this.parent.dateFormat + ' ' + this.parent.activeViewOptions.timeFormat;
            removeClass(this.element.querySelectorAll('.e-time-icon'), EVENT_WINDOW_ICON_DISABLE_CLASS);
            removeClass([timezoneDiv], DISABLE_CLASS);
            if (this.element.querySelector('.e-checkbox-wrapper .e-time-zone').checked) {
                addClass([this.element.querySelector('.' + EVENT_WINDOW_TIME_ZONE_DIV_CLASS)], ENABLE_CLASS);
            }
            startObj.format = endObj.format = format;
        }
        if (this.cellClickAction) {
            this.updateDateTime(allDayStatus, startObj, endObj);
        }
        startObj.dataBind();
        endObj.dataBind();
        if (!isNullOrUndefined(this.recurrenceEditor)) {
            this.recurrenceEditor.updateRuleUntilDate(startObj.value);
        }
    }
    updateDateTime(allDayStatus, startObj, endObj) {
        let startDate;
        let endDate;
        if (allDayStatus) {
            startDate = resetTime(new Date(this.eventWindowTime.startTime.getTime()));
            if (this.parent.activeCellsData.isAllDay) {
                const temp = addDays(new Date(this.eventWindowTime.endTime.getTime()), -1).getTime();
                endDate = (+this.eventWindowTime.startTime > temp) ? this.eventWindowTime.endTime : new Date(temp);
            }
            else {
                endDate = resetTime(new Date(this.eventWindowTime.endTime.getTime()));
            }
        }
        else {
            const start = this.parent.activeCellsData.startTime;
            startDate = new Date(this.eventWindowTime.startTime.getTime());
            startDate.setHours(start.getHours(), start.getMinutes(), start.getSeconds());
            if (this.parent.activeCellsData.isAllDay) {
                const startHour = this.parent.getStartEndTime(this.parent.workHours.start);
                startDate.setHours(startHour.getHours(), startHour.getMinutes(), startHour.getSeconds());
                endDate = new Date(startDate.getTime());
                endDate.setMilliseconds(MS_PER_MINUTE * this.getSlotDuration());
            }
            else {
                endDate = new Date(startDate.getTime());
                endDate.setMilliseconds(this.parent.activeCellsData.endTime.getTime() - this.parent.activeCellsData.startTime.getTime());
            }
        }
        this.eventWindowTime = { startTime: new Date(startDate.getTime()), endTime: new Date(endDate.getTime()) };
        startObj.value = startDate;
        endObj.value = endDate;
        startObj.dataBind();
        endObj.dataBind();
    }
    getFormat(formatType) {
        let format;
        if (this.parent.locale === 'en' || this.parent.locale === 'en-US') {
            format = getValue(formatType + '.short', getDefaultDateObject(this.parent.getCalendarMode()));
        }
        else {
            format = getValue(`main.${this.parent.locale}.dates.calendars.${this.parent.getCalendarMode()}.${formatType}.short`, cldrData);
        }
        return format;
    }
    onEventDetailsUpdate(eventObj) {
        if (!this.parent.eventSettings.allowEditing) {
            return;
        }
        if (!this.parent.isAdaptive) {
            removeClass([this.element.querySelector('.' + DELETE_EVENT_CLASS)], DISABLE_CLASS);
        }
        this.element.querySelector('.' + EVENT_WINDOW_TITLE_TEXT_CLASS).innerHTML = this.l10n.getConstant('editEvent');
        this.element.querySelector('.' + FORM_CLASS).setAttribute('data-id', eventObj[this.fields.id].toString());
        if (isNullOrUndefined(this.parent.editorTemplate)) {
            eventObj = extend({}, eventObj, null, true);
            const timezoneObj = this.getInstance(TIME_ZONE_CLASS + '.' + EVENT_FIELD$1);
            let timezoneValue;
            if (eventObj[this.fields.startTimezone] || eventObj[this.fields.endTimezone]) {
                timezoneValue = true;
                this.parent.eventBase.timezoneConvert(eventObj);
            }
            else {
                timezoneValue = false;
            }
            eventObj.Timezone = timezoneValue;
            timezoneObj.checked = timezoneValue;
            timezoneObj.dataBind();
        }
        this.showDetails(eventObj);
        if (eventObj[this.fields.recurrenceRule] && this.recurrenceEditor) {
            this.recurrenceEditor.setRecurrenceRule(eventObj[this.fields.recurrenceRule], eventObj[this.fields.startTime]);
        }
        else if (!this.parent.isAdaptive && this.recurrenceEditor) {
            this.recurrenceEditor.setProperties({ startDate: eventObj[this.fields.startTime] });
            this.recurrenceEditor.setRecurrenceRule('');
        }
        this.repeatStartDate = eventObj[this.fields.startTime];
        this.repeatRule = '';
        if (eventObj[this.fields.recurrenceRule]) {
            if (this.recurrenceEditor) {
                this.recurrenceEditor.setRecurrenceRule(eventObj[this.fields.recurrenceRule], eventObj[this.fields.startTime]);
            }
            this.repeatRule = eventObj[this.fields.recurrenceRule];
        }
        if (this.parent.isAdaptive && isNullOrUndefined(this.parent.editorTemplate)) {
            const element = this.element.querySelector('.' + REPEAT_CONTAINER_CLASS);
            if (eventObj[this.fields.recurrenceRule]) {
                removeClass([element], HIDE_STYLE_CLASS);
                this.repeatStatus.setProperties({ checked: true });
            }
            else {
                addClass([element], HIDE_STYLE_CLASS);
                this.repeatStatus.setProperties({ checked: false });
            }
            this.updateRepeatLabel(this.repeatRule);
        }
        const isDisable = (this.parent.readonly || eventObj[this.fields.isReadonly]);
        if (!this.parent.isAdaptive) {
            const saveButton = this.element.querySelector('.' + EVENT_WINDOW_SAVE_BUTTON_CLASS);
            const deleteButton = this.element.querySelector('.' + DELETE_EVENT_CLASS);
            this.disableButton(saveButton, isDisable);
            this.disableButton(deleteButton, isDisable);
        }
        else {
            const saveIcon = this.element.querySelector('.' + EVENT_WINDOW_SAVE_ICON_CLASS);
            if (saveIcon) {
                if (isDisable) {
                    addClass([saveIcon], ICON_DISABLE_CLASS);
                }
                else {
                    removeClass([saveIcon], ICON_DISABLE_CLASS);
                }
            }
        }
        this.dialogObject.show();
    }
    disableButton(element, value) {
        if (element) {
            element.ej2_instances[0].disabled = value;
        }
    }
    renderRecurrenceEditor() {
        return new RecurrenceEditor({
            calendarMode: this.parent.calendarMode,
            cssClass: this.parent.cssClass,
            dateFormat: this.parent.dateFormat,
            enableRtl: this.parent.enableRtl,
            firstDayOfWeek: this.parent.activeViewOptions.firstDayOfWeek,
            locale: this.parent.locale
        });
    }
    updateMinMaxDateToEditor() {
        const startDate = this.element.querySelector('.e-start');
        const endDate = this.element.querySelector('.e-end');
        if (startDate && endDate) {
            const startObj = startDate.ej2_instances[0];
            const endObj = endDate.ej2_instances[0];
            startObj.min = this.parent.minDate;
            startObj.max = this.parent.maxDate;
            endObj.min = this.parent.minDate;
            endObj.max = this.parent.maxDate;
            startObj.dataBind();
            endObj.dataBind();
        }
        if (this.recurrenceEditor) {
            const untilDate = this.recurrenceEditor.element.querySelector('.e-until-date');
            if (untilDate) {
                const untilObj = untilDate.ej2_instances[0];
                untilObj.min = this.parent.minDate;
                untilObj.max = this.parent.maxDate;
                untilObj.dataBind();
            }
        }
    }
    updateRepeatLabel(repeatRule) {
        if (this.parent.isAdaptive && !this.repeatDialogObject) {
            this.renderRepeatDialog();
        }
        const data = repeatRule ?
            (this.l10n.getConstant('repeats') + ' ' + this.recurrenceEditor.getRuleSummary(repeatRule)) : this.l10n.getConstant('repeat');
        this.repeatStatus.setProperties({ label: data });
    }
    dialogClose(event) {
        if (this.isEnterKey) {
            this.isEnterKey = false;
            return;
        }
        this.dialogEvent = event;
        this.isCrudAction = false;
        this.parent.activeEventData = { event: undefined, element: undefined };
        this.parent.currentAction = null;
        this.dialogObject.hide();
    }
    resetForm() {
        this.fieldValidator.destroyToolTip();
        this.resetFormFields();
        if (!this.parent.isAdaptive && this.recurrenceEditor && !this.recurrenceEditor.isDestroyed) {
            this.recurrenceEditor.resetFields();
        }
    }
    timezoneChangeStyle(value) {
        const timezoneDiv = this.element.querySelector('.' + EVENT_WINDOW_TIME_ZONE_DIV_CLASS);
        const localTimezoneName = this.parent.tzModule.getLocalTimezoneName();
        if (value) {
            addClass([timezoneDiv], ENABLE_CLASS);
            const startTimezoneObj = this.getInstance(EVENT_WINDOW_START_TZ_CLASS);
            const endTimezoneObj = this.getInstance(EVENT_WINDOW_END_TZ_CLASS);
            const timezone = startTimezoneObj.dataSource;
            if (!startTimezoneObj.value || !this.parent.timezone) {
                const found = timezone.some((tz) => { return tz.Value === localTimezoneName; });
                if (!found) {
                    timezone.push({ Value: localTimezoneName, Text: localTimezoneName });
                    startTimezoneObj.dataSource = timezone;
                    endTimezoneObj.dataSource = timezone;
                    startTimezoneObj.dataBind();
                    endTimezoneObj.dataBind();
                }
            }
            startTimezoneObj.value = startTimezoneObj.value || this.parent.timezone || localTimezoneName;
            endTimezoneObj.value = endTimezoneObj.value || this.parent.timezone || localTimezoneName;
            startTimezoneObj.dataBind();
            endTimezoneObj.dataBind();
        }
        else {
            removeClass([timezoneDiv], ENABLE_CLASS);
        }
    }
    resetFormFields() {
        const formElement = this.getFormElements(EVENT_WINDOW_DIALOG_CLASS);
        for (const currentElement of formElement) {
            const columnName = currentElement.name || this.getColumnName(currentElement);
            if (!isNullOrUndefined(columnName) && columnName !== '') {
                this.setDefaultValueToElement(currentElement);
            }
        }
    }
    eventSave(event, alert) {
        if (this.isEnterKey) {
            this.isEnterKey = false;
            return;
        }
        const formElement = this.element.querySelector('.' + FORM_CLASS);
        if (formElement && formElement.classList.contains('e-formvalidator') &&
            !formElement.ej2_instances[0].validate()) {
            return;
        }
        const dataCollection = this.getEventDataFromEditor();
        if (this.processEventValidation(dataCollection.tempData, alert)) {
            return;
        }
        this.eventCrudData = dataCollection.eventData;
        this.dialogEvent = event;
        this.isCrudAction = true;
        this.dialogObject.hide();
    }
    getEventDataFromEditor() {
        const eventObj = extend({}, this.getObjectFromFormData(EVENT_WINDOW_DIALOG_CLASS));
        if (!eventObj.Timezone) {
            eventObj[this.fields.startTimezone] = null;
            eventObj[this.fields.endTimezone] = null;
        }
        delete eventObj.Timezone;
        delete eventObj.Repeat;
        this.setDefaultValueToObject(eventObj);
        eventObj[this.fields.recurrenceRule] = this.recurrenceEditor ? this.recurrenceEditor.getRecurrenceRule() || null : undefined;
        const tempObj = extend({}, eventObj, null, true);
        if (eventObj[this.fields.isAllDay]) {
            eventObj[this.fields.startTime] = (isNullOrUndefined(eventObj[this.fields.startTime])) ? null
                : resetTime(new Date(eventObj[this.fields.startTime].getTime()));
            eventObj[this.fields.endTime] = (isNullOrUndefined(eventObj[this.fields.endTime])) ? null
                : addDays(resetTime(new Date(eventObj[this.fields.endTime].getTime())), 1);
        }
        return { eventData: eventObj, tempData: tempObj };
    }
    processEventValidation(eventObj, alert) {
        let alertType;
        if (isNullOrUndefined(this.parent.editorTemplate)) {
            if (!eventObj[this.fields.startTime] || !eventObj[this.fields.endTime]) {
                this.parent.quickPopup.openValidationError('invalidDateError');
                return true;
            }
            if (eventObj[this.fields.startTime] > eventObj[this.fields.endTime]) {
                this.parent.quickPopup.openValidationError('startEndError');
                return true;
            }
        }
        if (this.recurrenceEditor && this.recurrenceEditor.value && this.recurrenceEditor.value !== '') {
            if (this.parent.currentAction !== 'EditOccurrence') {
                alertType = this.recurrenceValidation(eventObj[this.fields.startTime], eventObj[this.fields.endTime], alert);
            }
            let isShowAlert = true;
            if (alertType === 'seriesChangeAlert' && this.parent.uiStateValues.isIgnoreOccurrence) {
                isShowAlert = false;
            }
            if (!isNullOrUndefined(alertType) && isShowAlert
                && ((!this.parent.enableRecurrenceValidation && alertType === 'wrongPattern') || this.parent.enableRecurrenceValidation)) {
                this.parent.quickPopup.openRecurrenceValidationAlert(alertType);
                return true;
            }
        }
        return false;
    }
    processCrudActions(eventObj) {
        this.parent.uiStateValues.isBlock = false;
        const resourceData = this.getResourceData(eventObj);
        const isResourceEventExpand = (this.parent.activeViewOptions.group.resources.length > 0 ||
            this.parent.resourceCollection.length > 0) && !this.parent.activeViewOptions.group.allowGroupEdit
            && !isNullOrUndefined(resourceData);
        const eventId = this.getEventIdFromForm();
        if (!isNullOrUndefined(eventId)) {
            let eveId = this.parent.eventBase.getEventIDType() === 'string' ? eventId : parseInt(eventId, 10);
            let editedData = this.parent.eventsData.filter((data) => data[this.fields.id] === eveId)[0];
            if (isNullOrUndefined(editedData)) {
                editedData = this.parent.blockData.filter((data) => data[this.fields.id] === eveId)[0];
            }
            eventObj = extend({}, editedData, eventObj);
            if (eventObj[this.fields.isReadonly]) {
                return false;
            }
            let currentAction;
            if (!isNullOrUndefined(editedData[this.fields.recurrenceRule])) {
                currentAction = this.parent.currentAction;
                eventObj.Guid = this.parent.activeEventData.event.Guid;
                if (this.parent.currentAction === 'EditOccurrence') {
                    if (!eventObj[this.fields.recurrenceID]) {
                        eventObj[this.fields.id] = this.parent.eventBase.getEventMaxID();
                        eventObj.Guid = this.parent.activeEventData.event.Guid;
                    }
                    else {
                        eveId = eventObj[this.fields.recurrenceID];
                        currentAction = null;
                    }
                    if (this.parent.enableRecurrenceValidation && this.editOccurrenceValidation(eveId, eventObj)) {
                        return true;
                    }
                }
                if (this.parent.currentAction === 'EditSeries' || eventObj[this.fields.id] !== editedData[this.fields.id]) {
                    eventObj[this.fields.recurrenceID] = editedData[this.fields.id];
                }
                else if (this.parent.currentAction === 'EditFollowingEvents') {
                    eventObj[this.fields.id] = this.parent.eventBase.getEventMaxID();
                    eventObj[this.fields.followingID] = editedData[this.fields.id];
                }
            }
            if (isResourceEventExpand) {
                this.resourceSaveEvent(eventObj, 'Save', currentAction);
            }
            else {
                this.parent.saveEvent(eventObj, currentAction);
            }
        }
        else {
            this.parent.currentAction = 'Add';
            if (isResourceEventExpand) {
                this.resourceSaveEvent(eventObj, this.parent.currentAction);
            }
            else {
                eventObj[this.fields.id] = this.parent.eventBase.getEventMaxID();
                this.parent.addEvent(eventObj);
            }
        }
        return this.parent.uiStateValues.isBlock;
    }
    getResourceData(eventObj) {
        let resourceData = null;
        if (!isNullOrUndefined(this.parent.resourceBase) && !isNullOrUndefined(this.parent.resourceBase.resourceCollection)
            && this.parent.resourceBase.resourceCollection.length > 0) {
            const lastResourceData = this.parent.resourceBase.resourceCollection.slice(-1)[0];
            resourceData = eventObj[lastResourceData.field];
        }
        return resourceData;
    }
    getObjectFromFormData(className) {
        const formElement = this.getFormElements(className);
        const eventObj = {};
        for (const currentElement of formElement) {
            const columnName = currentElement.name || this.getColumnName(currentElement);
            if (!isNullOrUndefined(columnName) && columnName !== '') {
                eventObj[`${columnName}`] = this.getValueFromElement(currentElement);
            }
        }
        return eventObj;
    }
    setDefaultValueToObject(eventObj) {
        if (!isNullOrUndefined(eventObj[this.fields.subject])) {
            eventObj[this.fields.subject] = eventObj[this.fields.subject] || this.parent.eventSettings.fields.subject.default
                || this.l10n.getConstant('addTitle');
        }
        if (!isNullOrUndefined(eventObj[this.fields.location])) {
            eventObj[this.fields.location] = eventObj[this.fields.location] || this.parent.eventSettings.fields.location.default;
        }
        if (!isNullOrUndefined(eventObj[this.fields.description])) {
            eventObj[this.fields.description] = eventObj[this.fields.description] || this.parent.eventSettings.fields.description.default;
        }
    }
    recurrenceValidation(startDate, endDate, alert) {
        let alertMessage;
        const recEditor = this.recurrenceEditor;
        const interval = this.getInstance('e-repeat-interval.e-numerictextbox').value;
        if (alert !== this.l10n.getConstant('ok')) {
            const activeEvent = this.parent.activeEventData.event;
            let excludedEvents = [];
            if ((this.parent.currentAction === 'EditSeries' || this.parent.currentAction === 'EditFollowingEvents')
                && !isNullOrUndefined(activeEvent)) {
                const eventStartTime = activeEvent[this.parent.eventFields.startTime];
                const seriesEvents = this.parent.eventBase.getSeriesEvents(this.eventData, eventStartTime);
                if (seriesEvents.length > 0) {
                    excludedEvents = this.parent.eventBase.getEditedOccurrences(seriesEvents, eventStartTime);
                }
                else {
                    const event = this.parent.eventBase.getEventById(activeEvent[this.parent.eventFields.id]);
                    excludedEvents = this.parent.eventBase.getEditedOccurrences([event], eventStartTime);
                }
                if (this.parent.currentAction === 'EditSeries'
                    && !isNullOrUndefined(this.eventData[this.parent.eventFields.recurrenceException])) {
                    excludedEvents.push(this.eventData);
                }
            }
            if (excludedEvents.length > 0) {
                alertMessage = 'seriesChangeAlert';
            }
            if (this.getInstance('e-end-on-left .e-ddl .e-dropdownlist').value === 'until' &&
                this.getInstance('e-end-on-date .e-datepicker').value < startDate) {
                alertMessage = 'wrongPattern';
            }
            if (isNullOrUndefined(alertMessage)) {
                let types = recEditor.value.split(';')[1].split('=')[1].split(',');
                const obj = { 'SU': 0, 'MO': 1, 'TU': 2, 'WE': 3, 'TH': 4, 'FR': 5, 'SA': 6 };
                const temp = [];
                const tempDiff = [];
                let tempValue;
                switch (recEditor.value.split(';')[0].split('=')[1]) {
                    case 'DAILY':
                        if ((((endDate.getTime() - startDate.getTime()) / (1000 * 3600)) > (interval * 24))) {
                            alertMessage = 'createError';
                        }
                        break;
                    case 'WEEKLY':
                        types = recEditor.value.split(';')[1].split('=')[1].split(',');
                        for (let index = 0; index < types.length * (interval + 1); index++) {
                            temp[parseInt(index.toString(), 10)] =
                                (types.length > index) ? obj[types[parseInt(index.toString(), 10)]] :
                                    temp[index - types.length] + (7 * interval);
                        }
                        tempValue = temp.sort((a, b) => a - b);
                        for (let index = 1; index < tempValue.length; index++) {
                            tempDiff.push(tempValue[parseInt(index.toString(), 10)] - tempValue[index - 1]);
                        }
                        if ((((endDate.getTime() - startDate.getTime()) / (1000 * 3600)) >= Math.min(...tempDiff) * 24)
                            || isNullOrUndefined(interval)) {
                            alertMessage = 'createError';
                        }
                        break;
                    case 'MONTHLY':
                        if (endDate.getTime() >= new Date(+startDate).setMonth(startDate.getMonth() + interval)) {
                            alertMessage = 'createError';
                        }
                        break;
                    case 'YEARLY':
                        if (endDate.getTime() >= new Date(+startDate).setFullYear(startDate.getFullYear() + interval)) {
                            alertMessage = 'createError';
                        }
                        break;
                }
            }
        }
        else {
            if (endDate.getTime() >= new Date(+startDate).setMonth(startDate.getMonth() + interval)) {
                alertMessage = 'createError';
            }
            if (isNullOrUndefined(alertMessage)) {
                this.parent.quickPopup.quickDialog.hide();
            }
        }
        if (isNullOrUndefined(interval)) {
            alertMessage = 'createError';
        }
        return alertMessage;
    }
    getRecurrenceIndex(recColl, event) {
        let recIndex;
        for (let index = 0; index < recColl.length; index++) {
            if (event[this.fields.startTime].valueOf() === recColl[parseInt(index.toString(), 10)][this.fields.startTime].valueOf()) {
                recIndex = index;
                break;
            }
        }
        return recIndex;
    }
    trimAllDay(data) {
        if (data[this.fields.isAllDay]) {
            const temp = addDays(new Date(+data[this.fields.endTime]), -1).getTime();
            data[this.fields.endTime] = (+data[this.fields.startTime] > temp) ? data[this.fields.endTime] : new Date(temp);
        }
    }
    editOccurrenceValidation(eventId, currentData, editData) {
        if (editData === void 0) {
            editData = this.eventData;
        }
        const recurColl = this.parent.getOccurrencesByID(eventId);
        const excludedDatas = this.parent.eventsData.filter((data) => data[this.fields.recurrenceID] === eventId);
        excludedDatas.map((data) => recurColl.push(extend({}, data)));
        currentData = extend({}, currentData);
        this.trimAllDay(currentData);
        for (const data of recurColl) {
            this.trimAllDay(data);
        }
        this.parent.eventBase.sortByTime(recurColl);
        const index = this.getRecurrenceIndex(recurColl, editData);
        if (isNullOrUndefined(index)) {
            return false;
        }
        const currentStartTime = new Date(+currentData[this.fields.startTime]);
        const currentEndTime = new Date(+currentData[this.fields.endTime]);
        let nextStartTime;
        let nextEndTime;
        if (index !== recurColl.length - 1) {
            nextStartTime = new Date(+recurColl[index + 1][this.fields.startTime]);
            nextEndTime = new Date(+recurColl[index + 1][this.fields.endTime]);
        }
        const lastEndTime = new Date(+recurColl[recurColl.length - 1][this.fields.endTime]);
        if (index === 0) {
            if (!isNullOrUndefined(recurColl[index + 1])) {
                if (!(nextStartTime.getTime() >= currentEndTime.getTime()) &&
                    (resetTime(lastEndTime).getTime() >=
                        resetTime(currentStartTime).getTime()) ||
                    resetTime(lastEndTime).getTime() < resetTime(currentStartTime).getTime()) {
                    this.parent.quickPopup.openRecurrenceValidationAlert('occurrenceAlert');
                    return true;
                }
                else if (!(resetTime(currentStartTime).getTime() <
                    resetTime(nextStartTime).getTime())) {
                    this.parent.quickPopup.openRecurrenceValidationAlert('sameDayAlert');
                    return true;
                }
            }
            return false;
        }
        else {
            const previousStartTime = new Date(+recurColl[index - 1][this.fields.startTime]);
            const previousEndTime = new Date(+recurColl[index - 1][this.fields.endTime]);
            if (index === recurColl.length - 1) {
                if (resetTime(new Date(+recurColl[(recurColl.length - 1) - index][this.fields.startTime])).getTime() >
                    resetTime(currentStartTime).getTime()) {
                    this.parent.quickPopup.openRecurrenceValidationAlert('occurrenceAlert');
                    return true;
                }
                else if (!((previousEndTime.getTime() <= currentStartTime.getTime()) &&
                    (resetTime(currentStartTime).getTime() > resetTime(previousStartTime).getTime()))) {
                    this.parent.quickPopup.openRecurrenceValidationAlert('sameDayAlert');
                    return true;
                }
            }
            else if (!(((resetTime(previousStartTime).getTime() < resetTime(currentStartTime).getTime()) ||
                resetTime(new Date(+recurColl[0][this.fields.startTime])).getTime() >
                    resetTime(currentStartTime).getTime()) &&
                ((resetTime(nextStartTime).getTime() > resetTime(currentStartTime).getTime()) ||
                    (lastEndTime.getTime() < currentStartTime.getTime())))) {
                this.parent.quickPopup.openRecurrenceValidationAlert('sameDayAlert');
                return true;
            }
            else if (!(previousEndTime.getTime() <= currentStartTime.getTime() && nextStartTime.getTime() >
                currentEndTime.getTime()) || (resetTime(nextEndTime).getTime() <
                resetTime(currentStartTime).getTime()) ||
                (resetTime(previousStartTime).getTime() > resetTime(currentEndTime).getTime()) ||
                !(resetTime(currentStartTime).getTime() < resetTime(nextStartTime).getTime())) {
                this.parent.quickPopup.openRecurrenceValidationAlert('occurrenceAlert');
                return true;
            }
        }
        return false;
    }
    resourceSaveEvent(eventObj, action, currentAction) {
        const lastResourceData = this.parent.resourceBase.resourceCollection.slice(-1)[0];
        let resourceData = eventObj[lastResourceData.field];
        resourceData = (resourceData instanceof Array) ? resourceData.reverse() : [resourceData].reverse();
        const lastLevel = this.parent.resourceBase.lastResourceLevel;
        const eventList = [];
        for (let i = 0; i < resourceData.length; i++) {
            const events = extend({}, eventObj, null, true);
            events[this.fields.id] = this.parent.eventBase.getEventMaxID();
            const temp = [];
            const addValues = () => {
                if (action === 'Save' && i === resourceData.length - 1) {
                    if (temp.length > 0) {
                        temp[0][this.fields.id] = eventObj[this.fields.id];
                        for (let k = 1; k < temp.length; k++) {
                            temp[parseInt(k.toString(), 10)][this.fields.id] = this.parent.eventBase.getEventMaxID(i);
                            eventList.push(temp[parseInt(k.toString(), 10)]);
                            this.parent.saveEvent(temp[0], currentAction);
                        }
                    }
                    else {
                        events[this.fields.id] = eventObj[this.fields.id];
                        this.parent.saveEvent(events, currentAction);
                    }
                }
                else {
                    if (temp.length > 0) {
                        for (let j = 0; j < temp.length; j++) {
                            temp[parseInt(j.toString(), 10)][this.fields.id] = this.parent.eventBase.getEventMaxID(j);
                            eventList.push(temp[parseInt(j.toString(), 10)]);
                        }
                    }
                    else {
                        events[this.fields.id] = this.parent.eventBase.getEventMaxID(i);
                        eventList.push(events);
                    }
                }
            };
            if (this.parent.activeViewOptions.group.byGroupID && (!isNullOrUndefined(lastLevel))) {
                const lastResource = lastResourceData.dataSource;
                const resCol = this.parent.resourceCollection;
                let index;
                if (resCol.length > 1) {
                    index =
                        findIndexInData(lastResource, lastResourceData.idField, resourceData[parseInt(i.toString(), 10)], events, resCol);
                }
                else {
                    index =
                        findIndexInData(lastResource, lastResourceData.idField, resourceData[parseInt(i.toString(), 10)]);
                }
                if (index < 0) {
                    return;
                }
                const groupId = lastResource[parseInt(index.toString(), 10)][lastResourceData.groupIDField];
                const filter = lastLevel.filter((obj) => obj.resourceData[lastResourceData.idField] ===
                    resourceData[parseInt(i.toString(), 10)]).
                    filter((obj) => obj.resourceData[lastResourceData.groupIDField] === groupId)[0];
                const groupOrder = filter.groupOrder;
                for (let index = 0; index < this.parent.resourceBase.resourceCollection.length; index++) {
                    const field = this.parent.resourceBase.resourceCollection[parseInt(index.toString(), 10)].field;
                    events[`${field}`] = (groupOrder[parseInt(index.toString(), 10)] instanceof Array) ? groupOrder[parseInt(index.toString(), 10)][0] :
                        groupOrder[parseInt(index.toString(), 10)];
                }
                addValues();
            }
            else {
                for (let index = 0; index < this.parent.resourceBase.resourceCollection.length - 1; index++) {
                    const field = this.parent.resourceBase.resourceCollection[parseInt(index.toString(), 10)].field;
                    if (events[`${field}`] instanceof Array && events[`${field}`].length > 1) {
                        for (let k = 0; k < events[`${field}`].length; k++) {
                            const event = extend({}, events, null, true);
                            event[`${field}`] = eventObj[`${field}`][parseInt(k.toString(), 10)];
                            event[lastResourceData.field] = resourceData[parseInt(i.toString(), 10)];
                            temp.push(event);
                        }
                    }
                    else {
                        if (temp.length === 0) {
                            events[`${field}`] = (eventObj[`${field}`] instanceof Array) ?
                                eventObj[`${field}`][0] : eventObj[`${field}`];
                            events[lastResourceData.field] = resourceData[parseInt(i.toString(), 10)];
                        }
                        else {
                            for (let l = 0; l < temp.length; l++) {
                                temp[parseInt(l.toString(), 10)][`${field}`] = (eventObj[`${field}`] instanceof Array) ?
                                    eventObj[`${field}`][0] : eventObj[`${field}`];
                            }
                        }
                    }
                }
                events[lastResourceData.field] = resourceData[parseInt(i.toString(), 10)];
                addValues();
            }
        }
        if (eventList.length > 0) {
            for (const event of eventList) {
                event[this.fields.recurrenceException] = null;
                event[this.fields.recurrenceID] = null;
            }
            this.parent.addEvent(eventList);
        }
    }
    getEventIdFromForm() {
        return this.element.querySelector('.' + FORM_CLASS).getAttribute('data-id');
    }
    getFormElements(className) {
        let elements = [];
        if (className === EVENT_WINDOW_DIALOG_CLASS) {
            elements = [].slice.call(this.element.querySelectorAll('.' + EVENT_FIELD$1));
        }
        else {
            elements = [].slice.call(this.parent.element.querySelectorAll('.' + className + ' .' + EVENT_FIELD$1));
        }
        return elements;
    }
    getValueFromElement(element) {
        let value;
        if (element.classList.contains('e-datepicker')) {
            value = element.ej2_instances[0].value;
        }
        else if (element.classList.contains('e-datetimepicker')) {
            value = element.ej2_instances[0].value;
        }
        else if (element.classList.contains('e-dropdownlist')) {
            value = element.ej2_instances[0].value;
        }
        else if (element.classList.contains('e-multiselect')) {
            value = element.ej2_instances[0].value;
        }
        else if (element.classList.contains('e-checkbox')) {
            value = element.ej2_instances[0].checked;
        }
        else {
            if (element.type === 'checkbox') {
                value = element.checked;
            }
            else {
                value = this.parent.enableHtmlSanitizer ?
                    SanitizeHtmlHelper.sanitize(element.value) : element.value;
            }
        }
        return value;
    }
    setValueToElement(element, value) {
        if (element.classList.contains('e-datepicker')) {
            const instance = element.ej2_instances[0];
            instance.value = value;
            instance.dataBind();
        }
        else if (element.classList.contains('e-datetimepicker')) {
            const instance = element.ej2_instances[0];
            if (instance.element.classList.contains(EVENT_WINDOW_START_CLASS)) {
                this.eventWindowTime.startTime = new Date('' + value);
            }
            else {
                this.eventWindowTime.endTime = new Date('' + value);
            }
            instance.value = value;
            instance.dataBind();
        }
        else if (element.classList.contains('e-dropdownlist')) {
            const instance = element.ej2_instances[0];
            instance.value = value;
            instance.dataBind();
        }
        else if (element.classList.contains('e-multiselect')) {
            const instance = element.ej2_instances[0];
            instance.value = [];
            instance.value = ((value instanceof Array) ? value : [value]);
            instance.dataBind();
        }
        else if (element.classList.contains('e-checkbox')) {
            const instance = element.ej2_instances[0];
            instance.checked = value;
            instance.dataBind();
        }
        else {
            if (element.type !== 'checkbox') {
                element.value = value || '';
            }
            else {
                element.checked = value;
            }
        }
    }
    setDefaultValueToElement(element) {
        if (element.classList.contains('e-datepicker')) {
            const instance = element.ej2_instances[0];
            instance.value = this.parent.getCurrentTime();
            instance.dataBind();
        }
        else if (element.classList.contains('e-datetimepicker')) {
            const instance = element.ej2_instances[0];
            const dateValue = this.parent.getCurrentTime();
            this.eventWindowTime = { startTime: dateValue, endTime: dateValue };
            instance.value = dateValue;
            instance.dataBind();
        }
        else if (element.classList.contains('e-dropdownlist')) {
            const instance = element.ej2_instances[0];
            instance.value = null;
            instance.dataBind();
        }
        else if (element.classList.contains('e-multiselect')) {
            const instance = element.ej2_instances[0];
            instance.value = [];
            instance.dataBind();
        }
        else if (element.classList.contains('e-checkbox')) {
            const instance = element.ej2_instances[0];
            instance.checked = false;
            instance.dataBind();
        }
        else {
            if (element.type === 'checkbox') {
                element.checked = false;
            }
            else {
                element.value = '';
            }
        }
    }
    getInstance(className) {
        const element = this.element.querySelector('.' + className);
        return element ? element.ej2_instances[0] : null;
    }
    eventDelete(event) {
        if (this.isEnterKey) {
            this.isEnterKey = false;
            return;
        }
        switch (this.parent.currentAction) {
            case 'EditOccurrence':
                if (!isNullOrUndefined(this.parent.activeEventData.event[this.parent.eventFields.recurrenceRule])) {
                    this.parent.currentAction = 'DeleteOccurrence';
                }
                else {
                    this.parent.currentAction = 'Delete';
                }
                break;
            case 'EditSeries':
                this.parent.currentAction = 'DeleteSeries';
                break;
            case 'Save':
                this.parent.currentAction = 'Delete';
                break;
            case 'EditFollowingEvents':
                if (!isNullOrUndefined(this.parent.activeEventData.event[this.parent.eventFields.recurrenceRule])) {
                    this.parent.currentAction = 'DeleteFollowingEvents';
                }
                break;
        }
        this.dialogEvent = event;
        this.isCrudAction = false;
        this.dialogObject.hide();
        this.parent.quickPopup.openDeleteAlert();
    }
    getRecurrenceEditorInstance() {
        if (this.parent.isAdaptive && !this.repeatDialogObject) {
            this.renderRepeatDialog();
        }
        return this.recurrenceEditor;
    }
    destroyComponents() {
        const formElements = this.getFormElements(EVENT_WINDOW_DIALOG_CLASS);
        for (const element of formElements) {
            let instance;
            if (element.classList.contains('e-datetimepicker')) {
                instance = element.ej2_instances;
            }
            else if (element.classList.contains('e-datepicker')) {
                instance = element.ej2_instances;
            }
            else if (element.classList.contains('e-checkbox')) {
                instance = element.ej2_instances;
            }
            else if (element.classList.contains('e-dropdownlist')) {
                instance = element.ej2_instances;
            }
            else if (element.classList.contains('e-multiselect')) {
                instance = element.ej2_instances;
            }
            else if (element.classList.contains('e-numerictextbox')) {
                instance = element.ej2_instances;
            }
            if (instance && instance[0]) {
                instance[0].destroy();
            }
        }
        if (this.buttonObj) {
            this.buttonObj.destroy();
        }
    }
    detachComponents() {
        const formElements = this.getFormElements(EVENT_WINDOW_DIALOG_CLASS);
        for (const element of formElements) {
            detach(element);
        }
    }
    destroy(isIgnore) {
        if (this.parent && !this.parent.isDestroyed) {
            this.parent.resetTemplates(['editorTemplate']);
        }
        this.destroyComponents();
        if (this.recurrenceEditor) {
            this.recurrenceEditor.destroy();
            detach(this.recurrenceEditor.element);
            this.recurrenceEditor = null;
        }
        if (this.fieldValidator) {
            this.fieldValidator.destroy();
            this.fieldValidator = null;
        }
        if (this.repeatDialogObject) {
            this.repeatDialogObject.destroy();
            this.repeatDialogObject = null;
        }
        this.detachComponents();
        if (this.dialogObject) {
            if (this.dialogObject.element) {
                const form = this.dialogObject.element.querySelector('form');
                removeChildren(form);
                detach(form);
                EventHandler.remove(this.dialogObject.element, 'keydown', this.preventEventSave);
            }
            this.dialogObject.destroy();
            this.dialogObject = null;
        }
        if (this.element) {
            remove(this.element);
            this.element = null;
        }
        if (!isIgnore) {
            this.l10n = null;
            this.parent = null;
            this.fields = null;
            this.buttonObj = null;
            this.repeatStatus = null;
            this.eventWindowTime = null;
            this.dialogEvent = null;
        }
    }
}

/**
 * Virtual Scroll
 */
class VirtualScroll {
    constructor(parent) {
        this.translateY = 0;
        this.itemSize = 60;
        this.bufferCount = 3;
        this.renderedLength = 0;
        this.averageRowHeight = 0;
        this.startIndex = 0;
        this.parent = parent;
        this.addEventListener();
    }
    addEventListener() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.parent.on(virtualScroll, this.virtualScrolling, this);
    }
    removeEventListener() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.parent.off(virtualScroll, this.virtualScrolling);
    }
    getRenderedCount() {
        this.setItemSize();
        const containerSize = this.isHorizontalScroll ? this.parent.element.clientWidth : this.parent.element.clientHeight;
        this.renderedLength = Math.ceil(containerSize / this.itemSize) + this.bufferCount;
        return this.renderedLength;
    }
    renderVirtualTrack(contentWrap) {
        const wrap = createElement('div', { className: VIRTUAL_TRACK_CLASS });
        if (this.isHorizontalScroll) {
            const colCount = this.parent.activeView.colLevels[this.parent.activeView.colLevels.length - 1].length;
            wrap.style.width = (colCount * this.itemSize) + 'px';
        }
        else {
            wrap.style.height = (this.parent.resourceBase.expandedResources.length * this.itemSize) + 'px';
        }
        contentWrap.appendChild(wrap);
    }
    updateVirtualScrollHeight() {
        const virtual = this.parent.element.querySelector('.' + VIRTUAL_TRACK_CLASS);
        const lastResourceIndex = this.parent.resourceBase.expandedResources[this.parent.resourceBase.expandedResources.length - 1].groupIndex;
        const lastRenderIndex = this.parent.resourceBase.renderedResources[this.parent.resourceBase.renderedResources.length - 1].groupIndex;
        if (lastRenderIndex !== lastResourceIndex) {
            const conTable = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS);
            this.renderedLength = conTable.querySelector('tbody').children.length;
            virtual.style.height = (conTable.offsetHeight + (this.parent.resourceBase.expandedResources.length - (this.renderedLength)) *
                conTable.offsetHeight / this.renderedLength) + 'px';
        }
        else {
            virtual.style.height = '';
        }
        this.averageRowHeight = virtual.offsetHeight / this.parent.resourceBase.expandedResources.length;
    }
    updateVirtualTrackHeight(wrap) {
        const resourceCount = this.parent.resourceBase.renderedResources.length;
        if (resourceCount !== this.getRenderedCount()) {
            wrap.style.height = this.parent.element.querySelector('.e-content-wrap').clientHeight + 'px';
            const resWrap = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);
            const conWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
            const eventWrap = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);
            this.translateY = 0;
            this.setTranslate(resWrap, conWrap, eventWrap);
        }
        else {
            const lastRenderIndex = this.parent.resourceBase.renderedResources[resourceCount - 1].groupIndex;
            const lastCollIndex = this.parent.resourceBase.expandedResources[this.parent.resourceBase.expandedResources.length - 1].groupIndex;
            let renderedResCount = resourceCount + (lastCollIndex - lastRenderIndex);
            renderedResCount = (renderedResCount > this.parent.resourceBase.expandedResources.length) ?
                this.parent.resourceBase.expandedResources.length : renderedResCount;
            wrap.style.height = (renderedResCount * this.itemSize) + 'px';
        }
    }
    setItemSize() {
        if (this.isHorizontalScroll) {
            this.itemSize = getElementWidthFromClass(this.parent.activeView.element, WORK_CELLS_CLASS) || this.itemSize;
        }
        else {
            this.itemSize = getElementHeightFromClass(this.parent.activeView.element, WORK_CELLS_CLASS) || this.itemSize;
        }
    }
    renderEvents() {
        this.setTabIndex();
        if (this.parent.crudModule) {
            this.parent.crudModule.refreshProcessedData(true);
        }
        if (this.parent.currentView !== 'Month') {
            this.parent.notify(contentReady, {});
        }
        this.parent.hideSpinner();
    }
    virtualScrolling() {
        if (this.parent.quickPopup) {
            this.parent.quickPopup.quickPopupHide();
            this.parent.quickPopup.morePopup.hide();
        }
        const conWrap = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        if (this.isHorizontalScroll) {
            this.horizontalScrolling(conWrap);
        }
        else {
            const resWrap = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);
            const eventWrap = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);
            const timeIndicator = this.parent.element.querySelector('.' + CURRENT_TIMELINE_CLASS);
            const conTable = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS);
            addClass([conWrap], 'e-transition');
            this.renderedLength = resWrap.querySelector('tbody').children.length;
            const firstTDIndex = parseInt(resWrap.querySelector('tbody td').getAttribute('data-group-index'), 10);
            const scrollHeight = this.parent.rowAutoHeight ?
                (conTable.offsetHeight - conWrap.offsetHeight) : this.bufferCount * this.itemSize;
            let resCollection = [];
            if ((conWrap.scrollTop) - this.translateY < 0) {
                resCollection = this.upScroll(conWrap, firstTDIndex);
            }
            else if (conWrap.scrollTop - this.translateY > scrollHeight) {
                resCollection = this.downScroll(conWrap, firstTDIndex);
            }
            if (!isNullOrUndefined(resCollection) && resCollection.length > 0) {
                this.parent.showSpinner();
                const selectedEle = this.parent.getSelectedCells();
                this.focusedEle = selectedEle[selectedEle.length - 1] || this.focusedEle;
                this.updateContent(resWrap, conWrap, eventWrap, resCollection);
                this.setTranslate(resWrap, conWrap, eventWrap, timeIndicator);
                if (this.parent.dragAndDropModule && this.parent.dragAndDropModule.actionObj.action === 'drag') {
                    this.parent.dragAndDropModule.navigationWrapper();
                }
                window.clearTimeout(this.timeValue);
                this.timeValue = window.setTimeout(() => { this.renderEvents(); }, 250);
            }
        }
    }
    horizontalScrolling(conWrap) {
        let resCollection = [];
        const scrollWidth = this.bufferCount * this.itemSize;
        if (Math.abs(conWrap.scrollLeft) - Math.abs(this.translateY) < 0) {
            resCollection = this.leftScroll(conWrap);
        }
        else if (Math.abs(conWrap.scrollLeft) - Math.abs(this.translateY) > scrollWidth) {
            resCollection = this.rightScroll(conWrap);
        }
        if (!isNullOrUndefined(resCollection) && resCollection.length > 0) {
            if (this.parent.resourceBase.expandedResources.length !== resCollection.length ||
                this.parent.resourceBase.expandedResources[0] !== resCollection[0] ||
                this.parent.resourceBase.expandedResources[this.parent.resourceBase.expandedResources.length - 1] !==
                    resCollection[resCollection.length - 1]) {
                this.parent.showSpinner();
                const colLevels = this.parent.activeView.colLevels.slice(0);
                this.updateHorizontalContent(conWrap, resCollection);
                setStyleAttribute(conWrap.querySelector('table'), { transform: `translateX(${this.translateY}px)` });
                this.parent.activeView.colLevels = colLevels;
                if (this.parent.dragAndDropModule && this.parent.dragAndDropModule.actionObj.action === 'drag') {
                    this.parent.dragAndDropModule.navigationWrapper();
                }
            }
            window.clearTimeout(this.timeValue);
            this.timeValue = window.setTimeout(() => { this.renderEvents(); }, 250);
        }
    }
    upScroll(conWrap, firstTDIndex) {
        let index = 0;
        index = (~~(conWrap.scrollTop / this.itemSize) + Math.ceil(conWrap.clientHeight / this.itemSize)) - this.renderedLength;
        if (this.parent.rowAutoHeight) {
            index = (index > firstTDIndex) ? firstTDIndex - this.bufferCount : index;
        }
        index = (index > 0) ? index : 0;
        const prevSetCollection = this.getBufferCollection(index, index + this.renderedLength);
        this.parent.resourceBase.renderedResources = prevSetCollection;
        if (firstTDIndex === 0) {
            this.translateY = conWrap.scrollTop;
        }
        else {
            let height = (this.parent.rowAutoHeight) ? this.averageRowHeight : this.itemSize;
            height = (height > 0) ? height : this.itemSize;
            this.translateY = (conWrap.scrollTop - (this.bufferCount * height) > 0) ?
                conWrap.scrollTop - (this.bufferCount * height) : 0;
        }
        return prevSetCollection;
    }
    downScroll(conWrap, firstTDIndex) {
        const lastResource = this.parent.resourceBase.
            renderedResources[this.parent.resourceBase.renderedResources.length - 1].groupIndex;
        const lastResourceIndex = this.parent.resourceBase.expandedResources[this.parent.resourceBase.expandedResources.length - 1].groupIndex;
        if (lastResource === lastResourceIndex) {
            return null;
        }
        let nextSetResIndex = 0;
        nextSetResIndex = ~~(conWrap.scrollTop / this.itemSize);
        if (this.parent.rowAutoHeight) {
            nextSetResIndex = ~~((conWrap.scrollTop - this.translateY) / this.averageRowHeight) + firstTDIndex;
            nextSetResIndex = (nextSetResIndex > firstTDIndex + this.bufferCount) ? nextSetResIndex : firstTDIndex + this.bufferCount;
        }
        let lastIndex = nextSetResIndex + this.renderedLength;
        lastIndex = (lastIndex > this.parent.resourceBase.expandedResources.length) ?
            nextSetResIndex + (this.parent.resourceBase.expandedResources.length - nextSetResIndex) : lastIndex;
        const nextSetCollection = this.getBufferCollection(lastIndex - this.renderedLength, lastIndex);
        this.translateY = conWrap.scrollTop;
        return nextSetCollection;
    }
    leftScroll(conWrap) {
        let index = 0;
        index = (~~(Math.abs(conWrap.scrollLeft) / this.itemSize) + Math.ceil(conWrap.clientWidth / this.itemSize)) - this.renderedLength;
        index = (index > 0) ? index : 0;
        return this.getCollection(index, index + this.renderedLength);
    }
    rightScroll(conWrap) {
        const lastLevel = this.parent.activeView.colLevels[this.parent.activeView.colLevels.length - 1];
        let nextSetIndex = 0;
        nextSetIndex = ~~(Math.abs(conWrap.scrollLeft) / this.itemSize);
        let lastIndex = nextSetIndex + this.renderedLength;
        lastIndex = (lastIndex > lastLevel.length - 1) ? lastLevel.length - 1 : lastIndex;
        return this.getCollection(lastIndex - this.renderedLength, lastIndex);
    }
    getCollection(startIndex, endIndex) {
        this.translateY = startIndex * this.itemSize;
        const lastLevel = this.getResCollection(startIndex, endIndex);
        if (this.parent.enableRtl) {
            this.translateY = -this.translateY;
        }
        return lastLevel;
    }
    getResCollection(startIndex, endIndex) {
        const lastLevel = this.parent.activeView.colLevels[this.parent.activeView.colLevels.length - 1];
        let resCollection = [];
        const index = { startIndex: 0, endIndex: 0 };
        if (this.parent.activeViewOptions.group.byDate) {
            if (lastLevel[parseInt(startIndex.toString(), 10)].date.getTime() ===
                this.parent.resourceBase.expandedResources[0].date.getTime() &&
                lastLevel[parseInt(endIndex.toString(), 10)].date.getTime() ===
                    this.parent.resourceBase.expandedResources[this.parent.resourceBase.expandedResources.length - 1].date.getTime()) {
                return this.parent.resourceBase.expandedResources;
            }
            resCollection =
                this.getByDateCollection(lastLevel[parseInt(startIndex.toString(), 10)], lastLevel[parseInt(endIndex.toString(), 10)], index);
            this.setRenderedDates(resCollection);
        }
        else {
            if (lastLevel[parseInt(startIndex.toString(), 10)].groupIndex === this.parent.resourceBase.expandedResources[0].groupIndex &&
                lastLevel[parseInt(endIndex.toString(), 10)].groupIndex ===
                    this.parent.resourceBase.expandedResources[this.parent.resourceBase.expandedResources.length - 1].groupIndex) {
                return this.parent.resourceBase.expandedResources;
            }
            resCollection =
                this.getByIdCollection(lastLevel[parseInt(startIndex.toString(), 10)], lastLevel[parseInt(endIndex.toString(), 10)], index);
        }
        if (this.parent.currentView !== 'Month') {
            this.startIndex = index.startIndex;
            resCollection = lastLevel.slice(index.startIndex, index.endIndex);
        }
        this.translateY = index.startIndex * this.itemSize;
        return resCollection;
    }
    getByDateCollection(firstItem, lastItem, index) {
        const resCollection = this.parent.activeView.colLevels[0].filter((data) => firstItem.date.getTime() <= data.date.getTime() &&
            data.date.getTime() <= lastItem.date.getTime());
        this.setStartEndIndex(this.parent.activeView.colLevels[0], resCollection[0], resCollection[resCollection.length - 1], index);
        return resCollection;
    }
    getByIdCollection(firstItem, lastItem, index) {
        const resCollection = this.parent.resourceBase.lastResourceLevel.filter((data) => firstItem.groupIndex <= data.groupIndex && data.groupIndex <= lastItem.groupIndex);
        this.parent.resourceBase.renderedResources = resCollection;
        this.setStartEndIndex(this.parent.resourceBase.lastResourceLevel, resCollection[0], resCollection[resCollection.length - 1], index);
        return resCollection;
    }
    setStartEndIndex(data, firstItem, lastItem, colIndex) {
        let index = 0;
        data.filter((data) => {
            if (firstItem === data) {
                colIndex.startIndex = index;
            }
            else if (lastItem === data) {
                colIndex.endIndex = index + data.colSpan;
            }
            index += data.colSpan;
        });
        if (firstItem === lastItem) {
            colIndex.endIndex = colIndex.startIndex + lastItem.colSpan;
        }
    }
    updateContent(resWrap, conWrap, eventWrap, resCollection) {
        const renderedLength = resWrap.querySelector('tbody').children.length;
        if (document.activeElement && document.activeElement.classList.contains(RESOURCE_CELLS_CLASS)) {
            this.isResourceCell = true;
            this.parent.element.focus();
        }
        for (let i = 0; i < renderedLength; i++) {
            remove(resWrap.querySelector('tbody tr'));
            remove(conWrap.querySelector('tbody tr'));
            remove(eventWrap.querySelector('div'));
        }
        this.parent.resourceBase.renderedResources = resCollection;
        const resourceRows = this.parent.resourceBase.getContentRows(resCollection, true);
        const contentRows = this.parent.activeView.getContentRows();
        const eventRows = this.parent.activeView.getEventRows(resCollection.length);
        append(resourceRows, resWrap.querySelector('tbody'));
        append(contentRows, conWrap.querySelector('tbody'));
        append(eventRows, eventWrap);
    }
    updateHorizontalContent(conWrap, resCollection) {
        this.parent.resourceBase.expandedResources = resCollection;
        const selectedEle = this.parent.getSelectedCells();
        this.focusedEle = selectedEle[selectedEle.length - 1] || this.focusedEle;
        const renderedLength = conWrap.querySelectorAll('tbody tr').length;
        for (let i = 0; i < renderedLength; i++) {
            remove(conWrap.querySelector('tbody tr'));
        }
        if (this.parent.currentView === 'Month') {
            if (this.parent.activeViewOptions.group.byDate) {
                this.parent.activeView.colLevels[0] = resCollection;
            }
            else {
                this.parent.activeView.colLevels[this.parent.activeView.colLevels.length - 2] = resCollection;
            }
            const contentRows = this.parent.activeView.getContentRows();
            append(contentRows, conWrap.querySelector('tbody'));
        }
        else {
            const col = [].slice.call(conWrap.querySelector('colgroup').children);
            for (let i = 0; i < col.length; i++) {
                remove(col[parseInt(i.toString(), 10)]);
            }
            this.parent.activeView.colLevels[this.parent.activeView.colLevels.length - 1] = resCollection;
            const contentRows = this.parent.activeView.getContentRows();
            const table = conWrap.querySelector('table');
            const thead = conWrap.querySelector('thead');
            const colGroupEle = conWrap.querySelector('colgroup');
            resCollection.forEach(() => {
                colGroupEle.appendChild(createElement('col'));
            });
            thead.appendChild(this.parent.eventBase.createEventWrapper('', this.startIndex > 0 ? this.startIndex : 0));
            if (this.parent.activeViewOptions.timeScale.enable) {
                thead.appendChild(this.parent.eventBase.createEventWrapper('timeIndicator'));
            }
            prepend([thead], table);
            append(contentRows, conWrap.querySelector('tbody'));
        }
    }
    getBufferCollection(startIndex, endIndex) {
        return this.parent.resourceBase.expandedResources.slice(startIndex, endIndex);
    }
    setTranslate(resWrap, conWrap, eventWrap, timeIndicator) {
        setStyleAttribute(resWrap.querySelector('table'), { transform: `translateY(${this.translateY}px)` });
        setStyleAttribute(conWrap.querySelector('table'), { transform: `translateY(${this.translateY}px)` });
        setStyleAttribute(eventWrap, { transform: `translateY(${this.translateY}px)` });
        if (!isNullOrUndefined(timeIndicator)) {
            setStyleAttribute(timeIndicator, { transform: `translateY(${this.translateY}px)` });
        }
    }
    updateFocusedWorkCell() {
        if (this.focusedEle) {
            const date = parseInt(this.focusedEle.getAttribute('data-date'), 10);
            const groupIndex = parseInt(this.focusedEle.getAttribute('data-group-index'), 10);
            const ele = this.parent.element.querySelector(`.${WORK_CELLS_CLASS}[data-date="${date}"][data-group-index="${groupIndex}"]`);
            if (ele) {
                this.parent.addSelectedClass([ele], ele, true);
            }
            this.focusedEle = null;
        }
    }
    setRenderedDates(resCollection) {
        if (this.parent.currentView !== 'Month') {
            const dateCol = resCollection.map((x) => x.date);
            this.parent.resourceBase.renderedResources.forEach((x) => x.renderDates = dateCol);
        }
        else {
            const dateCol = resCollection.map((x) => x.date.getDay());
            const renderDates = this.parent.activeView.renderDates.filter((x) => dateCol.indexOf(x.getDay()) >= 0);
            this.parent.resourceBase.renderedResources.forEach((x) => x.renderDates = renderDates);
        }
    }
    setTabIndex() {
        const resColWrap = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);
        const resCells = [].slice.call(this.parent.element.querySelectorAll('.' + RESOURCE_CELLS_CLASS));
        if (resCells && resColWrap) {
            resCells.forEach((element) => {
                if (element.getBoundingClientRect().top >= resColWrap.getBoundingClientRect().top) {
                    element.setAttribute('tabindex', '0');
                }
            });
        }
        const focusResCell = this.parent.element.querySelector(`.${RESOURCE_CELLS_CLASS}[tabindex="${0}"]`);
        if (this.isResourceCell && focusResCell) {
            focusResCell.focus();
            this.isResourceCell = false;
        }
    }
    destroy() {
        this.removeEventListener();
        this.focusedEle = null;
    }
}

/**
 * Schedule DOM rendering
 */
class Render {
    constructor(parent) {
        this.parent = parent;
    }
    render(viewName, isDataRefresh = true) {
        this.initializeLayout(viewName);
        if (this.parent.activeView && isDataRefresh) {
            this.parent.crudModule.refreshDataManager();
        }
    }
    initializeLayout(viewName) {
        if (this.parent.activeView) {
            const templates = [
                'cellTemplate', 'eventTemplate', 'tooltipTemplate', 'majorSlotTemplate', 'minorSlotTemplate',
                'headerTooltipTemplate', 'dateHeaderTemplate', 'dayHeaderTemplate', 'monthHeaderTemplate',
                'headerIndentTemplate', 'resourceHeaderTemplate', 'cellHeaderTemplate', 'dateRangeTemplate'
            ];
            this.parent.resetTemplates(templates);
            this.parent.activeView.removeEventListener();
            this.parent.activeView.destroy();
        }
        switch (viewName) {
            case 'Day':
                this.parent.activeView = this.parent.dayModule;
                break;
            case 'Week':
                this.parent.activeView = this.parent.weekModule;
                break;
            case 'WorkWeek':
                this.parent.activeView = this.parent.workWeekModule;
                break;
            case 'Month':
                this.parent.activeView = this.parent.monthModule;
                break;
            case 'Year':
                this.parent.activeView = this.parent.yearModule;
                break;
            case 'Agenda':
                this.parent.activeView = this.parent.agendaModule;
                break;
            case 'MonthAgenda':
                this.parent.activeView = this.parent.monthAgendaModule;
                break;
            case 'TimelineDay':
                this.parent.activeView = this.parent.timelineViewsModule;
                this.parent.activeView.viewClass = 'e-timeline-day-view';
                break;
            case 'TimelineWorkWeek':
                this.parent.activeView = this.parent.timelineViewsModule;
                this.parent.activeView.viewClass = 'e-timeline-work-week-view';
                break;
            case 'TimelineWeek':
                this.parent.activeView = this.parent.timelineViewsModule;
                this.parent.activeView.viewClass = 'e-timeline-week-view';
                break;
            case 'TimelineMonth':
                this.parent.activeView = this.parent.timelineMonthModule;
                break;
            case 'TimelineYear':
                this.parent.activeView = this.parent.timelineYearModule;
                break;
        }
        if (isNullOrUndefined(this.parent.activeView)) {
            const firstView = this.parent.viewCollections[0].option;
            if (firstView) {
                this.parent.setProperties({ currentView: firstView }, true);
                if (this.parent.headerModule) {
                    this.parent.headerModule.updateActiveView();
                    this.parent.headerModule.setCalendarView();
                }
                return this.initializeLayout(firstView);
            }
            throw Error('Inject required modules');
        }
        this.parent.activeView.viewIndex = this.parent.viewIndex;
        this.updateLabelText(viewName);
        this.parent.activeView.addEventListener();
        this.parent.activeView.getRenderDates();
        this.parent.uiStateValues.isGroupAdaptive = this.parent.activeViewOptions.group.resources.length > 0 &&
            (this.parent.enableAdaptiveUI && !this.parent.isAdaptive ||
                this.parent.isAdaptive && this.parent.activeViewOptions.group.enableCompactView);
        if (this.parent.virtualScrollModule) {
            this.parent.virtualScrollModule.destroy();
            this.parent.virtualScrollModule = null;
        }
        if ((['Agenda', 'Year'].indexOf(this.parent.currentView) === -1 ||
            (this.parent.currentView === 'TimelineYear' && this.parent.activeViewOptions.orientation === 'Vertical'))
            && this.parent.activeViewOptions.allowVirtualScrolling
            && this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            this.parent.virtualScrollModule = new VirtualScroll(this.parent);
            if (this.parent.activeView.isTimelineView()) {
                this.parent.uiStateValues.top = 0;
            }
            else {
                this.parent.virtualScrollModule.isHorizontalScroll = true;
                this.parent.uiStateValues.left = 0;
            }
        }
        this.updateHeader();
        this.parent.currentTimezoneDate = this.parent.getCurrentTime();
        this.parent.activeView.renderLayout(CURRENT_PANEL_CLASS);
        this.parent.renderTemplates();
        if (this.parent.eventTooltip) {
            this.parent.eventTooltip.destroy();
            this.parent.eventTooltip = null;
        }
        if (this.parent.eventSettings.enableTooltip || (this.parent.activeViewOptions.group.resources.length > 0
            && this.parent.activeViewOptions.group.headerTooltipTemplate)) {
            this.parent.eventTooltip = new EventTooltip(this.parent);
        }
    }
    updateHeader() {
        if (this.parent.headerModule) {
            this.parent.headerModule.setDayOfWeek(this.parent.activeViewOptions.firstDayOfWeek);
            if (this.parent.activeViewOptions.readonly) {
                addClass([this.parent.element], READ_ONLY);
            }
            else if (this.parent.element.classList.contains(READ_ONLY)) {
                removeClass([this.parent.element], READ_ONLY);
            }
            this.parent.headerModule.updateDateRange();
            this.parent.headerModule.updateHeaderItems('remove');
        }
    }
    updateLabelText(view) {
        const content = this.parent.activeView.getLabelText(view);
        this.parent.element.setAttribute('role', 'main');
        this.parent.element.setAttribute('aria-label', content);
    }
}

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A class that represents the configuration of working hours related options of scheduler.
 */
class WorkHours extends ChildProperty {
}
__decorate$2([
    Property(true)
], WorkHours.prototype, "highlight", void 0);
__decorate$2([
    Property('09:00')
], WorkHours.prototype, "start", void 0);
__decorate$2([
    Property('18:00')
], WorkHours.prototype, "end", void 0);

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A class that represents the configuration of options related to timescale on scheduler.
 */
class TimeScale extends ChildProperty {
}
__decorate$3([
    Property(true)
], TimeScale.prototype, "enable", void 0);
__decorate$3([
    Property(60)
], TimeScale.prototype, "interval", void 0);
__decorate$3([
    Property(2)
], TimeScale.prototype, "slotCount", void 0);
__decorate$3([
    Property()
], TimeScale.prototype, "minorSlotTemplate", void 0);
__decorate$3([
    Property()
], TimeScale.prototype, "majorSlotTemplate", void 0);

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A class that defines the template options available to customize the quick popup of scheduler.
 */
class QuickInfoTemplates extends ChildProperty {
}
__decorate$4([
    Property('Both')
], QuickInfoTemplates.prototype, "templateType", void 0);
__decorate$4([
    Property()
], QuickInfoTemplates.prototype, "header", void 0);
__decorate$4([
    Property()
], QuickInfoTemplates.prototype, "content", void 0);
__decorate$4([
    Property()
], QuickInfoTemplates.prototype, "footer", void 0);

var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A class that represents the header rows related configurations on timeline views.
 */
class HeaderRows extends ChildProperty {
}
__decorate$5([
    Property()
], HeaderRows.prototype, "option", void 0);
__decorate$5([
    Property()
], HeaderRows.prototype, "template", void 0);

/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable max-len */
/**
 * Schedule CRUD operations
 */
class Crud {
    constructor(parent) {
        this.parent = parent;
        this.crudObj = { sourceEvent: null, targetEvent: null, isCrudAction: false };
    }
    getQuery() {
        const start = this.parent.activeView.startDate();
        const end = this.parent.activeView.endDate();
        return this.parent.dataModule.generateQuery(start, end);
    }
    getTable() {
        if (this.parent.eventSettings.query) {
            const query = this.parent.eventSettings.query.clone();
            return query.fromTable;
        }
        return null;
    }
    refreshDataManager() {
        if (!this.parent.activeView) {
            return;
        }
        const start = this.parent.activeView.startDate();
        const end = this.parent.activeView.endDate();
        const dataManager = this.parent.dataModule.getData(this.parent.dataModule.generateQuery(start, end));
        dataManager.then((e) => this.dataManagerSuccess(e)).catch((e) => this.dataManagerFailure(e));
    }
    dataManagerSuccess(e) {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.parent.trigger(dataBinding, e, (args) => {
            const resultData = extend([], args.result, null, true);
            this.parent.eventsData = resultData.filter((data) => !data[this.parent.eventFields.isBlock]);
            this.parent.blockData = resultData.filter((data) => data[this.parent.eventFields.isBlock]);
            this.refreshProcessedData();
            if (this.parent.dragAndDropModule && this.parent.dragAndDropModule.actionObj.action === 'drag') {
                this.parent.dragAndDropModule.navigationWrapper();
            }
            this.parent.trigger(dataBound, null, () => {
                this.parent.hideSpinner();
                if (this.parent.isPrinting) {
                    this.parent.notify(print$1, {});
                }
            });
        });
    }
    dataManagerFailure(e) {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.parent.trigger(actionFailure, { error: e }, () => this.parent.hideSpinner());
    }
    refreshProcessedData(isVirtualScrollAction = false) {
        if (this.parent.dragAndDropModule) {
            this.parent.dragAndDropModule.actionObj.action = '';
            removeClass([this.parent.element], 'e-event-action');
        }
        if (this.parent.activeViewOptions && this.parent.activeViewOptions.eventTemplate) {
            let templateNames = ['eventTemplate'];
            if (this.crudObj.isCrudAction &&
                ['Agenda', 'MonthAgenda', 'Year', 'TimelineYear'].indexOf(this.parent.currentView) === -1) {
                templateNames = [];
                for (let i = 0, len = this.crudObj.sourceEvent.length; i < len; i++) {
                    templateNames.push('eventTemplate_' + this.crudObj.sourceEvent[parseInt(i.toString(), 10)].groupIndex);
                    if (this.crudObj.targetEvent[parseInt(i.toString(), 10)] && this.crudObj.sourceEvent[parseInt(i.toString(), 10)].groupIndex !==
                        this.crudObj.targetEvent[parseInt(i.toString(), 10)].groupIndex) {
                        templateNames.push('eventTemplate_' + this.crudObj.targetEvent[parseInt(i.toString(), 10)].groupIndex);
                    }
                }
            }
            if (templateNames.length > 0) {
                this.parent.resetTemplates(templateNames);
            }
        }
        if (isVirtualScrollAction) {
            this.parent.notify(dataReady, { processedData: this.parent.eventsProcessed });
            return;
        }
        const eventsData = this.parent.eventsData || [];
        const blockData = this.parent.blockData || [];
        const data = eventsData.concat(blockData);
        this.parent.notify(dataReady, { processedData: this.parent.eventBase ? this.parent.eventBase.processData(data) : [] });
    }
    refreshData(args) {
        const actionArgs = {
            requestType: args.requestType, cancel: false, data: args.data,
            addedRecords: args.editParams.addedRecords, changedRecords: args.editParams.changedRecords,
            deletedRecords: args.editParams.deletedRecords
        };
        if (this.parent.dragAndDropModule && this.parent.dragAndDropModule.actionObj && this.parent.dragAndDropModule.actionObj.element) {
            this.parent.dragAndDropModule.actionObj.element.style.display = 'none';
        }
        if (this.parent.resizeModule && this.parent.resizeModule.actionObj && this.parent.resizeModule.actionObj.element) {
            this.parent.resizeModule.actionObj.element.style.display = 'none';
        }
        if (this.parent.isSpecificResourceEvents()) {
            if (args.requestType === 'eventCreated' || args.requestType === 'eventRemoved') {
                this.crudObj.isCrudAction = true;
                this.crudObj.sourceEvent = [];
                const crudData = args.data instanceof Array ? (args.data.length === 0 &&
                    args.requestType === 'eventRemoved' ? args.editParams.deletedRecords : args.data) :
                    ((typeof args.data === 'string' || typeof args.data === 'number') && args.requestType === 'eventRemoved') ?
                        args.editParams.deletedRecords : [args.data];
                for (const data of crudData) {
                    this.crudObj.isCrudAction = !(args.requestType === 'eventRemoved' && !isNullOrUndefined(data.parent));
                    const groupIndex = this.parent.eventBase.getGroupIndexFromEvent(data);
                    if (groupIndex > -1 && this.parent.crudModule.crudObj.sourceEvent.filter((tdData) => tdData.groupIndex === groupIndex).length === 0
                        && this.crudObj.isCrudAction) {
                        this.crudObj.sourceEvent.push(this.parent.resourceBase.lastResourceLevel[parseInt(groupIndex.toString(), 10)]);
                    }
                }
                this.crudObj.targetEvent = this.crudObj.sourceEvent;
            }
        }
        if (this.parent.dataModule.dataManager.dataSource.offline) {
            this.parent.trigger(actionComplete, actionArgs, (offlineArgs) => {
                if (!offlineArgs.cancel) {
                    this.refreshDataManager();
                }
            });
        }
        else {
            args.promise.then(() => {
                if (!this.parent || this.parent && this.parent.isDestroyed) {
                    return;
                }
                this.parent.trigger(actionComplete, actionArgs, (onlineArgs) => {
                    if (!onlineArgs.cancel) {
                        this.refreshDataManager();
                    }
                });
            }).catch((e) => {
                if (!this.parent || this.parent && this.parent.isDestroyed) {
                    return;
                }
                this.parent.trigger(actionFailure, { error: e });
            });
        }
    }
    addEvent(eventData) {
        if (this.parent.eventSettings.allowAdding && !this.parent.activeViewOptions.readonly) {
            if (!this.isBlockEvent(eventData) && this.parent.eventBase.isBlockRange(eventData)) {
                this.parent.quickPopup.openValidationError('blockAlert', eventData);
                return;
            }
            const addEvents = (eventData instanceof Array) ? eventData : [eventData];
            if (addEvents.length === 0) {
                return;
            }
            const args = {
                requestType: 'eventCreate', cancel: false, data: addEvents,
                addedRecords: addEvents, changedRecords: [], deletedRecords: []
            };
            this.parent.trigger(actionBegin, args, (addArgs) => {
                if (!addArgs.cancel) {
                    const fields = this.parent.eventFields;
                    const editParams = { addedRecords: [], changedRecords: [], deletedRecords: [] };
                    let promise;
                    if (addArgs.addedRecords instanceof Array) {
                        for (let event of addArgs.addedRecords) {
                            event = this.parent.eventBase.updateEventDateTime(event);
                            const eventData = extend({}, this.parent.eventBase.processTimezone(event, true), null, true);
                            editParams.addedRecords.push(eventData);
                        }
                        promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());
                    }
                    else {
                        const event = this.parent.eventBase.processTimezone(addArgs.addedRecords, true);
                        editParams.addedRecords.push(event);
                        promise = this.parent.dataModule.dataManager.insert(event, this.getTable(), this.getQuery());
                    }
                    const crudArgs = {
                        requestType: 'eventCreated', cancel: false, data: addArgs.addedRecords, promise: promise, editParams: editParams
                    };
                    this.refreshData(crudArgs);
                }
            });
        }
    }
    saveEvent(eventData, action) {
        if (this.parent.eventSettings.allowEditing && !this.parent.activeViewOptions.readonly) {
            if (this.parent.currentAction !== 'EditFollowingEvents' && !this.isBlockEvent(eventData)
                && this.parent.eventBase.isBlockRange(eventData)) {
                this.parent.quickPopup.openValidationError('blockAlert', eventData);
                this.parent.crudModule.crudObj.isCrudAction = false;
                return;
            }
            const updateEvents = (eventData instanceof Array) ? eventData : [eventData];
            if (updateEvents.length === 0) {
                return;
            }
            this.parent.currentAction = action;
            if (action) {
                switch (action) {
                    case 'Save':
                        this.processSave(eventData);
                        break;
                    case 'EditOccurrence':
                        this.processOccurrences(eventData, action);
                        break;
                    case 'EditFollowingEvents':
                        this.processFollowSeries(eventData, action);
                        break;
                    case 'EditSeries':
                        this.processEntireSeries(eventData, action);
                        break;
                }
            }
            else {
                const args = {
                    requestType: 'eventChange', cancel: false, data: eventData,
                    addedRecords: [], changedRecords: updateEvents, deletedRecords: []
                };
                this.parent.trigger(actionBegin, args, (saveArgs) => {
                    if (!saveArgs.cancel) {
                        let promise;
                        const fields = this.parent.eventFields;
                        const editParams = { addedRecords: [], changedRecords: [], deletedRecords: [] };
                        if (saveArgs.changedRecords instanceof Array) {
                            for (let event of saveArgs.changedRecords) {
                                event = this.parent.eventBase.updateEventDateTime(event);
                                const eventData = extend({}, this.parent.eventBase.processTimezone(event, true), null, true);
                                editParams.changedRecords.push(eventData);
                            }
                            promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());
                        }
                        else {
                            const event = this.parent.eventBase.processTimezone(saveArgs.changedRecords, true);
                            editParams.changedRecords.push(event);
                            promise = this.parent.dataModule.dataManager.update(fields.id, event, this.getTable(), this.getQuery());
                        }
                        const crudArgs = {
                            requestType: 'eventChanged', cancel: false,
                            data: saveArgs.changedRecords, promise: promise, editParams: editParams
                        };
                        this.refreshData(crudArgs);
                    }
                });
            }
        }
    }
    deleteEvent(eventData, action) {
        if (this.parent.eventSettings.allowDeleting && !this.parent.activeViewOptions.readonly) {
            this.parent.currentAction = action;
            let deleteEvents = [];
            if (typeof eventData === 'string' || typeof eventData === 'number') {
                deleteEvents = this.parent.eventsData.filter((eventObj) => eventObj[this.parent.eventFields.id] === eventData);
            }
            else {
                deleteEvents = (eventData instanceof Array ? eventData : [eventData]);
            }
            if (deleteEvents.length === 0) {
                return;
            }
            if (action) {
                switch (action) {
                    case 'Delete':
                        this.processDelete(deleteEvents);
                        break;
                    case 'DeleteOccurrence':
                        this.processOccurrences(deleteEvents, action);
                        break;
                    case 'DeleteFollowingEvents':
                        this.processFollowSeries(deleteEvents, action);
                        break;
                    case 'DeleteSeries':
                        this.processEntireSeries(deleteEvents, action);
                        break;
                }
            }
            else {
                const args = {
                    requestType: 'eventRemove', cancel: false, data: eventData,
                    addedRecords: [], changedRecords: [], deletedRecords: deleteEvents
                };
                this.parent.trigger(actionBegin, args, (deleteArgs) => {
                    if (!deleteArgs.cancel) {
                        let promise;
                        const fields = this.parent.eventFields;
                        const editParams = { addedRecords: [], changedRecords: [], deletedRecords: [] };
                        if (deleteArgs.deletedRecords.length > 1) {
                            editParams.deletedRecords = editParams.deletedRecords.concat(deleteArgs.deletedRecords);
                            promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());
                        }
                        else {
                            editParams.deletedRecords.push(deleteArgs.deletedRecords[0]);
                            promise = this.parent.dataModule.dataManager.remove(fields.id, deleteArgs.deletedRecords[0], this.getTable(), this.getQuery());
                        }
                        this.parent.eventBase.selectWorkCellByTime(deleteArgs.deletedRecords);
                        const crudArgs = {
                            requestType: 'eventRemoved', cancel: false,
                            data: deleteArgs.deletedRecords, promise: promise, editParams: editParams
                        };
                        this.refreshData(crudArgs);
                    }
                });
            }
        }
    }
    processOccurrences(eventData, action) {
        let occurrenceData = [];
        let isDeletedRecords = false;
        if (eventData instanceof Array) {
            for (const event of eventData) {
                occurrenceData.push({ occurrence: event, parent: this.getParentEvent(event) });
            }
        }
        else {
            occurrenceData = { occurrence: eventData, parent: this.getParentEvent(eventData) };
        }
        const updateEvents = (eventData instanceof Array) ? eventData : [eventData];
        const args = {
            requestType: action === 'EditOccurrence' ? 'eventChange' : 'eventRemove', cancel: false,
            addedRecords: [], changedRecords: updateEvents, deletedRecords: []
        };
        args.data = occurrenceData;
        this.parent.trigger(actionBegin, args, (occurrenceArgs) => {
            if (!occurrenceArgs.cancel) {
                const fields = this.parent.eventFields;
                const editParams = { addedRecords: [], changedRecords: [], deletedRecords: [] };
                const occurrenceEvents = (occurrenceData instanceof Array ? occurrenceData : [occurrenceData]);
                for (let a = 0, count = occurrenceArgs.changedRecords.length; a < count; a++) {
                    const childEvent = occurrenceArgs.changedRecords[parseInt(a.toString(), 10)];
                    const parentEvent = occurrenceEvents[parseInt(a.toString(), 10)].parent;
                    const parentException = parentEvent[fields.recurrenceException];
                    let editedData;
                    let exceptionDate;
                    switch (action) {
                        case 'EditOccurrence':
                            editedData = this.parent.eventsProcessed.filter((event) => event.Guid === childEvent.Guid)[0];
                            exceptionDate = this.excludeDateCheck(editedData[fields.startTime], parentException);
                            if (exceptionDate !== parentEvent[fields.recurrenceException]) {
                                parentEvent[fields.recurrenceException] = exceptionDate;
                                childEvent[fields.recurrenceException] = getRecurrenceStringFromDate(editedData[fields.startTime]);
                                childEvent[fields.recurrenceID] = parentEvent[fields.id];
                                childEvent[fields.followingID] = null;
                                editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));
                                editParams.addedRecords.push(this.parent.eventBase.processTimezone(childEvent, true));
                            }
                            else {
                                editParams.changedRecords.push(this.parent.eventBase.processTimezone(childEvent, true));
                            }
                            break;
                        case 'DeleteOccurrence':
                            if (!childEvent[fields.recurrenceException]) {
                                parentEvent[fields.recurrenceException] =
                                    this.excludeDateCheck(childEvent[fields.startTime], parentException);
                                editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));
                            }
                            if (childEvent[fields.id] !== parentEvent[fields.id]) {
                                editParams.deletedRecords.push(childEvent);
                                isDeletedRecords = true;
                            }
                            break;
                    }
                }
                const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());
                this.parent.eventBase.selectWorkCellByTime(occurrenceArgs.changedRecords);
                const crudArgs = {
                    requestType: action === 'EditOccurrence' ? 'eventChanged' : 'eventRemoved',
                    cancel: false, data: isDeletedRecords ? occurrenceArgs.deletedRecords : occurrenceArgs.changedRecords,
                    promise: promise, editParams: editParams
                };
                this.refreshData(crudArgs);
            }
        });
    }
    processFollowSeries(eventData, action) {
        let followData = [];
        if (eventData instanceof Array) {
            for (const event of eventData) {
                followData.push({ occurrence: event, parent: this.getParentEvent(event) });
            }
        }
        else {
            followData = { occurrence: eventData, parent: this.getParentEvent(eventData) };
        }
        const updateFollowEvents = (eventData instanceof Array) ? eventData : [eventData];
        const args = {
            requestType: action === 'EditFollowingEvents' ? 'eventChange' : 'eventRemove', cancel: false,
            addedRecords: [], changedRecords: updateFollowEvents, deletedRecords: []
        };
        args.data = followData;
        this.parent.trigger(actionBegin, args, (followArgs) => {
            if (!followArgs.cancel) {
                const fields = this.parent.eventFields;
                const editParams = { addedRecords: [], changedRecords: [], deletedRecords: [] };
                const followEvents = followData instanceof Array ? followData : [followData];
                for (let a = 0, count = followArgs.changedRecords.length; a < count; a++) {
                    const childEvent = followArgs.changedRecords[parseInt(a.toString(), 10)];
                    const parentEvent = followEvents[parseInt(a.toString(), 10)].parent;
                    const followData = this.parent.eventBase.getEventCollections(parentEvent, childEvent);
                    let isSpanned;
                    switch (action) {
                        case 'EditFollowingEvents':
                            this.processRecurrenceRule(parentEvent, childEvent);
                            isSpanned = !this.parent.eventBase.isFollowingEvent(parentEvent, childEvent);
                            childEvent[fields.followingID] = isSpanned ? null : parentEvent[fields.id];
                            childEvent[fields.recurrenceID] = null;
                            editParams.addedRecords.push(this.parent.eventBase.processTimezone(childEvent, true));
                            editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));
                            if (!this.parent.uiStateValues.isIgnoreOccurrence) {
                                childEvent[fields.recurrenceException] = null;
                                if (followData.occurrence.length > 0) {
                                    const rule = followData.occurrence.slice(-1)[0][fields.recurrenceRule];
                                    if (rule.indexOf('COUNT') === -1) {
                                        childEvent[fields.recurrenceRule] = rule;
                                    }
                                }
                                if (followData.follow.length > 0) {
                                    childEvent[fields.recurrenceRule] = followData.follow.slice(-1)[0][fields.recurrenceRule];
                                    editParams.deletedRecords = editParams.deletedRecords.concat(followData.follow);
                                }
                                if (isSpanned) {
                                    followData.occurrence = followData.occurrence.filter((eventObj) => eventObj[fields.recurrenceID] === childEvent[fields.id]);
                                }
                                editParams.deletedRecords = editParams.deletedRecords.concat(followData.occurrence);
                            }
                            break;
                        case 'DeleteFollowingEvents':
                            this.processRecurrenceRule(parentEvent, childEvent[fields.startTime]);
                            editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));
                            editParams.deletedRecords = editParams.deletedRecords.concat(followData.occurrence).concat(followData.follow);
                            break;
                    }
                }
                const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());
                this.parent.eventBase.selectWorkCellByTime(followArgs.changedRecords);
                const crudArgs = {
                    requestType: action === 'EditFollowingEvents' ? 'eventChanged' : 'eventRemoved',
                    cancel: false, data: followArgs.changedRecords, promise: promise, editParams: editParams
                };
                this.refreshData(crudArgs);
            }
        });
    }
    processEntireSeries(eventData, action) {
        let seriesData = [];
        let isDeletedRecords = false;
        if (eventData instanceof Array) {
            for (const event of eventData) {
                seriesData.push(this.getParentEvent(event, true));
            }
        }
        else {
            seriesData = this.getParentEvent(eventData, true);
        }
        const updateSeriesEvents = (eventData instanceof Array) ? eventData : [eventData];
        const args = {
            requestType: action === 'EditSeries' ? 'eventChange' : 'eventRemove', cancel: false,
            addedRecords: [], changedRecords: updateSeriesEvents, deletedRecords: []
        };
        args.data = seriesData;
        this.parent.trigger(actionBegin, args, (seriesArgs) => {
            if (!seriesArgs.cancel) {
                const fields = this.parent.eventFields;
                const editParams = { addedRecords: [], changedRecords: [], deletedRecords: [] };
                const seriesEvents = seriesData instanceof Array ? seriesData : [seriesData];
                for (let a = 0, count = seriesArgs.changedRecords.length; a < count; a++) {
                    const childEvent = seriesArgs.changedRecords[parseInt(a.toString(), 10)];
                    const parentEvent = seriesEvents[parseInt(a.toString(), 10)];
                    const eventCollections = this.parent.eventBase.getEventCollections(parentEvent);
                    const deletedEvents = eventCollections.follow.concat(eventCollections.occurrence);
                    switch (action) {
                        case 'EditSeries':
                            childEvent[fields.id] = parentEvent[fields.id];
                            childEvent[fields.recurrenceID] = null;
                            childEvent[fields.followingID] = null;
                            if (this.parent.uiStateValues.isIgnoreOccurrence && childEvent[fields.recurrenceException]) {
                                const originalParent = this.parent.eventsData.filter((eventObj) => eventObj[fields.id] === childEvent[fields.id]);
                                if (originalParent.length > 0) {
                                    childEvent[fields.recurrenceRule] = originalParent[0][fields.recurrenceRule];
                                }
                            }
                            else {
                                childEvent[fields.recurrenceException] = null;
                                editParams.deletedRecords = editParams.deletedRecords.concat(deletedEvents);
                            }
                            editParams.changedRecords.push(this.parent.eventBase.processTimezone(childEvent, true));
                            this.parent.uiStateValues.isIgnoreOccurrence = false;
                            break;
                        case 'DeleteSeries':
                            editParams.deletedRecords = editParams.deletedRecords.concat(deletedEvents.concat(parentEvent));
                            isDeletedRecords = true;
                            break;
                    }
                }
                const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());
                this.parent.eventBase.selectWorkCellByTime(seriesArgs.changedRecords);
                const crudArgs = {
                    requestType: action === 'EditSeries' ? 'eventChanged' : 'eventRemoved',
                    cancel: false, data: isDeletedRecords ? seriesArgs.deletedRecords : seriesArgs.changedRecords,
                    promise: promise, editParams: editParams
                };
                this.refreshData(crudArgs);
            }
        });
    }
    processDelete(eventData) {
        const deleteData = [];
        for (const eventObj of eventData) {
            if (eventObj[this.parent.eventFields.recurrenceRule]) {
                deleteData.push({ occurrence: eventObj, parent: this.getParentEvent(eventObj) });
            }
            else {
                deleteData.push(eventObj);
            }
        }
        const args = {
            requestType: 'eventRemove', cancel: false,
            addedRecords: [], changedRecords: [], deletedRecords: eventData
        };
        args.data = deleteData;
        this.parent.trigger(actionBegin, args, (deleteArgs) => {
            if (!deleteArgs.cancel) {
                const fields = this.parent.eventFields;
                const editParams = { addedRecords: [], changedRecords: [], deletedRecords: [] };
                for (let a = 0, count = deleteArgs.deletedRecords.length; a < count; a++) {
                    let isDelete = isNullOrUndefined(deleteArgs.deletedRecords[parseInt(a.toString(), 10)][this.parent.eventFields.recurrenceRule]);
                    if (!isDelete) {
                        const parentEvent = deleteData[parseInt(a.toString(), 10)].parent;
                        const isEdited = editParams.changedRecords.filter((obj) => obj[fields.id] === parentEvent[fields.id]);
                        const editedDate = deleteArgs.deletedRecords[parseInt(a.toString(), 10)][fields.startTime];
                        if (isEdited.length > 0) {
                            const editedData = isEdited[0];
                            editedData[fields.recurrenceException] =
                                this.excludeDateCheck(editedDate, editedData[fields.recurrenceException]);
                        }
                        else {
                            parentEvent[fields.recurrenceException] =
                                this.excludeDateCheck(editedDate, parentEvent[fields.recurrenceException]);
                        }
                        if (isEdited.length === 0) {
                            editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEvent, true));
                        }
                        isDelete = deleteArgs.deletedRecords[parseInt(a.toString(), 10)][fields.id] !== parentEvent[fields.id];
                    }
                    if (isDelete) {
                        editParams.deletedRecords.push(deleteArgs.deletedRecords[parseInt(a.toString(), 10)]);
                    }
                }
                const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());
                const crudArgs = {
                    requestType: 'eventRemoved', cancel: false, data: deleteArgs.deletedRecords, promise: promise, editParams: editParams
                };
                this.refreshData(crudArgs);
            }
        });
    }
    processSave(data) {
        const eventData = (data instanceof Array) ? data : [data];
        const editData = [];
        for (const eventObj of eventData) {
            if (eventObj[this.parent.eventFields.recurrenceRule]) {
                editData.push({ occurrence: eventObj, parent: this.getParentEvent(eventObj) });
            }
            else {
                editData.push(eventObj);
            }
        }
        const args = { requestType: 'eventChange', cancel: false, addedRecords: [], changedRecords: eventData, deletedRecords: [] };
        args.data = editData;
        this.parent.trigger(actionBegin, args, (editArgs) => {
            if (!editArgs.cancel) {
                const fields = this.parent.eventFields;
                const editParams = { addedRecords: [], changedRecords: [], deletedRecords: [] };
                for (const record of editArgs.changedRecords) {
                    if (!isNullOrUndefined(record[fields.recurrenceRule]) && isNullOrUndefined(record[fields.recurrenceException])) {
                        const exceptionString = getRecurrenceStringFromDate(record[fields.startTime]);
                        const parentEle = this.getParentEvent(record);
                        parentEle[fields.recurrenceException] = isNullOrUndefined(parentEle[fields.recurrenceException]) ?
                            exceptionString : parentEle[fields.recurrenceException].concat(',' + exceptionString);
                        record[fields.id] = this.parent.getEventMaxID();
                        record[fields.recurrenceException] = exceptionString;
                        editParams.addedRecords.push(this.parent.eventBase.processTimezone(record, true));
                        editParams.changedRecords.push(this.parent.eventBase.processTimezone(parentEle, true));
                    }
                    else {
                        editParams.changedRecords.push(this.parent.eventBase.processTimezone(record, true));
                    }
                }
                const promise = this.parent.dataModule.dataManager.saveChanges(editParams, fields.id, this.getTable(), this.getQuery());
                const crudArgs = { requestType: 'eventChanged', cancel: false, data: editArgs.changedRecords, promise: promise, editParams: editParams };
                this.refreshData(crudArgs);
            }
        });
    }
    getParentEvent(event, isParent = false) {
        const parentEvent = this.parent.eventBase.getParentEvent(event, isParent) || event;
        if (parentEvent[this.parent.eventFields.startTimezone] || parentEvent[this.parent.eventFields.endTimezone]) {
            this.parent.eventBase.timezoneConvert(parentEvent);
        }
        return parentEvent;
    }
    excludeDateCheck(eventStartTime, exceptionDateList) {
        const exDate = getRecurrenceStringFromDate(eventStartTime);
        if (!isNullOrUndefined(exceptionDateList)) {
            if (exceptionDateList.indexOf(exDate) === -1) {
                exceptionDateList = !(isNullOrUndefined(exceptionDateList)) ? exceptionDateList + ',' + exDate : exDate;
            }
        }
        else {
            exceptionDateList = exDate;
        }
        return exceptionDateList;
    }
    processRecurrenceRule(parentEvent, followEvent) {
        const fields = this.parent.eventFields;
        const recurrenceRule = parentEvent[fields.recurrenceRule];
        let endDate;
        if (followEvent instanceof Date) {
            endDate = new Date(+followEvent);
        }
        else {
            endDate = new Date(+followEvent[fields.startTime]);
            const newRecurrenceRule = followEvent[fields.recurrenceRule];
            if (newRecurrenceRule) {
                const startDate = parentEvent[fields.startTime];
                const ruleException = (this.parent.currentAction === 'DeleteFollowingEvents') ? followEvent[fields.recurrenceException] : null;
                const dateCollection = generate(startDate, newRecurrenceRule, ruleException, this.parent.activeViewOptions.firstDayOfWeek);
                const untilDate = new Date(dateCollection.slice(-1)[0]);
                untilDate.setHours(endDate.getHours(), endDate.getMinutes(), endDate.getSeconds());
                endDate.setHours(startDate.getHours(), startDate.getMinutes(), startDate.getSeconds());
                followEvent[fields.recurrenceRule] = this.getUpdatedRecurrenceRule(newRecurrenceRule, new Date(+untilDate), false);
            }
        }
        parentEvent[fields.recurrenceRule] = this.getUpdatedRecurrenceRule(recurrenceRule, addDays(new Date(endDate.getTime()), -1), true);
    }
    getUpdatedRecurrenceRule(recurrenceRule, untilDate, isParent) {
        const splitRule = recurrenceRule.split(';');
        let updatedRule = '';
        for (let rule of splitRule) {
            if (rule !== '') {
                const ruleKey = rule.split('=')[0];
                let ruleValue = rule.split('=')[1];
                if (ruleKey === 'COUNT' || ruleKey === 'UNTIL') {
                    ruleValue = getRecurrenceStringFromDate(untilDate);
                    rule = rule.replace(rule, 'UNTIL=' + ruleValue);
                }
                updatedRule += rule + ';';
            }
        }
        if (isParent && updatedRule.indexOf('UNTIL') === -1) {
            updatedRule += 'UNTIL=' + getRecurrenceStringFromDate(untilDate);
        }
        return updatedRule;
    }
    isBlockEvent(eventData) {
        const eventCollection = (eventData instanceof Array) ? eventData : [eventData];
        let value = false;
        for (const event of eventCollection) {
            value = event[this.parent.eventFields.isBlock] || false;
        }
        return value;
    }
    /**
     * To destroy the crud module.
     *
     * @returns {void}
     * @private
     */
    destroy() {
        this.crudObj = null;
        this.parent = null;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Work cell interactions
 */
class WorkCellInteraction {
    constructor(parent) {
        this.parent = parent;
        EventHandler.add(this.parent.element, 'mouseover', this.onHover, this);
    }
    cellMouseDown(e) {
        if (this.isPreventAction(e)) {
            return;
        }
        this.parent.notify(cellMouseDown, { event: e });
    }
    cellClick(e) {
        if (this.isPreventAction(e)) {
            return;
        }
        const queryStr = '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' + HEADER_CELLS_CLASS;
        const target = closest(e.target, queryStr);
        if (isNullOrUndefined(target)) {
            return;
        }
        if (!isNullOrUndefined(closest(e.target, '.' + NEW_EVENT_CLASS))) {
            this.parent.eventWindow.openEditor(this.parent.activeCellsData, 'Add');
            return;
        }
        const navigateEle = closest(e.target, '.' + NAVIGATE_CLASS);
        const navigateView = this.parent.getNavigateView();
        const sameView = this.parent.currentView === navigateView;
        if (isNullOrUndefined(navigateEle) || sameView ||
            isNullOrUndefined(this.parent.viewOptions[navigateView.charAt(0).toLowerCase() + navigateView.slice(1)])) {
            if (this.parent.activeViewOptions.readonly && this.parent.currentView !== 'MonthAgenda') {
                if (this.parent.quickPopup) {
                    this.parent.quickPopup.quickPopupHide();
                }
                return;
            }
            if (this.parent.isAdaptive && (e.target.classList.contains(MORE_INDICATOR_CLASS) ||
                closest(e.target, '.' + MORE_INDICATOR_CLASS))) {
                return;
            }
            const isWorkCell = target.classList.contains(WORK_CELLS_CLASS) ||
                target.classList.contains(ALLDAY_CELLS_CLASS);
            if (isWorkCell && e.shiftKey && e.which === 1 && this.parent.keyboardInteractionModule) {
                this.parent.keyboardInteractionModule.onMouseSelection(e);
                return;
            }
            this.parent.activeCellsData = this.parent.getCellDetails(target);
            const args = extend(this.parent.activeCellsData, { cancel: false, event: e, name: 'cellClick' });
            this.parent.trigger(cellClick, args, (clickArgs) => {
                if (!clickArgs.cancel) {
                    if (isWorkCell) {
                        this.parent.selectCell(target);
                    }
                    if (this.parent.allowInline) {
                        const inlineArgs = {
                            element: clickArgs.element,
                            groupIndex: clickArgs.groupIndex, type: 'Cell'
                        };
                        this.parent.notify(inlineClick, inlineArgs);
                    }
                    else {
                        this.parent.notify(cellClick, clickArgs);
                    }
                }
                else {
                    if (this.parent.quickPopup) {
                        this.parent.quickPopup.quickPopupHide();
                    }
                }
            });
        }
        else {
            const date = this.parent.getDateFromElement(target);
            if (!isNullOrUndefined(date) && !this.parent.isAdaptive && this.parent.isMinMaxDate(date)) {
                this.parent.setProperties({ selectedDate: date }, true);
                this.parent.changeView(this.parent.getNavigateView(), e);
            }
        }
    }
    cellDblClick(e) {
        const queryStr = '.' + WORK_CELLS_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' + HEADER_CELLS_CLASS;
        const target = closest(e.target, queryStr);
        if (this.parent.activeViewOptions.readonly || this.isPreventAction(e) || isNullOrUndefined(target)) {
            return;
        }
        const args = extend(this.parent.activeCellsData, { cancel: false, event: e, name: 'cellDoubleClick' });
        this.parent.trigger(cellDoubleClick, args, (clickArgs) => {
            const date = new Date(clickArgs.startTime.getTime());
            if (!this.parent.isMinMaxDate(new Date(date.setHours(0, 0, 0, 0)))) {
                return;
            }
            if (!clickArgs.cancel) {
                this.parent.eventWindow.openEditor(this.parent.activeCellsData, 'Add');
            }
        });
    }
    onHover(e) {
        const targetSelector = '.' + WORK_CELLS_CLASS + ',.' + TIME_SLOT_CLASS + ',.' + ALLDAY_CELLS_CLASS + ',.' +
            HEADER_CELLS_CLASS + ',.' + RESOURCE_CELLS_CLASS + ',.' + APPOINTMENT_CLASS + ',.' + WEEK_NUMBER_CLASS +
            ',.' + MONTH_HEADER_CLASS;
        const hoverTarget = closest(e.target, targetSelector);
        if (hoverTarget) {
            const hoverArgs = { element: hoverTarget, event: e };
            this.parent.trigger(hover, hoverArgs);
        }
    }
    isPreventAction(e) {
        if (closest(e.target, '.' + NAVIGATE_CLASS)) {
            return false;
        }
        if (closest(e.target, '.' + APPOINTMENT_WRAPPER_CLASS) &&
            !closest(e.target, '.' + MORE_INDICATOR_CLASS)) {
            return true;
        }
        let target = closest(e.target, '.' + APPOINTMENT_CLASS + ',.' + RESOURCE_GROUP_CELLS_CLASS);
        if (!isNullOrUndefined(target)) {
            return true;
        }
        target = closest(e.target, '.' + HEADER_CELLS_CLASS);
        if (this.parent.activeView.isTimelineView() && !isNullOrUndefined(target)) {
            return true;
        }
        return false;
    }
    destroy() {
        EventHandler.remove(this.parent.element, 'mouseover', this.onHover);
    }
}

var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Configuration that applies on each appointment field options of scheduler.
 */
class FieldOptions extends ChildProperty {
}
__decorate$8([
    Property()
], FieldOptions.prototype, "name", void 0);
__decorate$8([
    Property()
], FieldOptions.prototype, "default", void 0);
__decorate$8([
    Property()
], FieldOptions.prototype, "title", void 0);
__decorate$8([
    Property({})
], FieldOptions.prototype, "validation", void 0);

var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A class that holds the collection of event fields that requires to be mapped with the dataSource
 * fields along with its available configuration settings. Each field in it accepts both string and object
 *  data type. When each of the field is assigned with simple `string` value, it is assumed that the dataSource field
 *  name is mapped with it. If the `object` type is defined on each fields, then the validation related settings and mapping of
 *  those fields with dataSource can be given altogether within it.
 */
class Field extends ChildProperty {
}
__decorate$7([
    Property('Id')
], Field.prototype, "id", void 0);
__decorate$7([
    Property('IsBlock')
], Field.prototype, "isBlock", void 0);
__decorate$7([
    Complex({ name: 'Subject' }, FieldOptions)
], Field.prototype, "subject", void 0);
__decorate$7([
    Complex({ name: 'StartTime' }, FieldOptions)
], Field.prototype, "startTime", void 0);
__decorate$7([
    Complex({ name: 'EndTime' }, FieldOptions)
], Field.prototype, "endTime", void 0);
__decorate$7([
    Complex({ name: 'StartTimezone' }, FieldOptions)
], Field.prototype, "startTimezone", void 0);
__decorate$7([
    Complex({ name: 'EndTimezone' }, FieldOptions)
], Field.prototype, "endTimezone", void 0);
__decorate$7([
    Complex({ name: 'Location' }, FieldOptions)
], Field.prototype, "location", void 0);
__decorate$7([
    Complex({ name: 'Description' }, FieldOptions)
], Field.prototype, "description", void 0);
__decorate$7([
    Complex({ name: 'IsAllDay' }, FieldOptions)
], Field.prototype, "isAllDay", void 0);
__decorate$7([
    Complex({ name: 'RecurrenceID' }, FieldOptions)
], Field.prototype, "recurrenceID", void 0);
__decorate$7([
    Complex({ name: 'RecurrenceRule' }, FieldOptions)
], Field.prototype, "recurrenceRule", void 0);
__decorate$7([
    Complex({ name: 'RecurrenceException' }, FieldOptions)
], Field.prototype, "recurrenceException", void 0);
__decorate$7([
    Property('IsReadonly')
], Field.prototype, "isReadonly", void 0);
__decorate$7([
    Property('FollowingID')
], Field.prototype, "followingID", void 0);

var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Holds the configuration of event related options and dataSource binding to Schedule.
 */
class EventSettings extends ChildProperty {
}
__decorate$6([
    Property()
], EventSettings.prototype, "template", void 0);
__decorate$6([
    Property([])
], EventSettings.prototype, "dataSource", void 0);
__decorate$6([
    Property()
], EventSettings.prototype, "query", void 0);
__decorate$6([
    Complex({}, Field)
], EventSettings.prototype, "fields", void 0);
__decorate$6([
    Property(false)
], EventSettings.prototype, "enableTooltip", void 0);
__decorate$6([
    Property('AllDayRow')
], EventSettings.prototype, "spannedEventPlacement", void 0);
__decorate$6([
    Property(1)
], EventSettings.prototype, "minimumEventDuration", void 0);
__decorate$6([
    Property()
], EventSettings.prototype, "tooltipTemplate", void 0);
__decorate$6([
    Property()
], EventSettings.prototype, "resourceColorField", void 0);
__decorate$6([
    Property(false)
], EventSettings.prototype, "editFollowingEvents", void 0);
__decorate$6([
    Property(true)
], EventSettings.prototype, "allowAdding", void 0);
__decorate$6([
    Property(true)
], EventSettings.prototype, "allowEditing", void 0);
__decorate$6([
    Property(true)
], EventSettings.prototype, "allowDeleting", void 0);
__decorate$6([
    Property(false)
], EventSettings.prototype, "enableMaxHeight", void 0);
__decorate$6([
    Property(false)
], EventSettings.prototype, "enableIndicator", void 0);
__decorate$6([
    Property(false)
], EventSettings.prototype, "ignoreWhitespace", void 0);
__decorate$6([
    Property()
], EventSettings.prototype, "sortComparer", void 0);
__decorate$6([
    Property()
], EventSettings.prototype, "includeFiltersInQuery", void 0);

var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * A class that holds the resource grouping related configurations on Schedule.
 */
class Group extends ChildProperty {
}
__decorate$9([
    Property(false)
], Group.prototype, "byDate", void 0);
__decorate$9([
    Property(true)
], Group.prototype, "byGroupID", void 0);
__decorate$9([
    Property(false)
], Group.prototype, "allowGroupEdit", void 0);
__decorate$9([
    Property([])
], Group.prototype, "resources", void 0);
__decorate$9([
    Property(true)
], Group.prototype, "enableCompactView", void 0);
__decorate$9([
    Property()
], Group.prototype, "headerTooltipTemplate", void 0);
__decorate$9([
    Property(false)
], Group.prototype, "hideNonWorkingDays", void 0);

var __decorate$10 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * A class that represents the resource related configurations and its data binding options.
 */
class Resources extends ChildProperty {
}
__decorate$10([
    Property()
], Resources.prototype, "field", void 0);
__decorate$10([
    Property()
], Resources.prototype, "title", void 0);
__decorate$10([
    Property()
], Resources.prototype, "name", void 0);
__decorate$10([
    Property(false)
], Resources.prototype, "allowMultiple", void 0);
__decorate$10([
    Property([])
], Resources.prototype, "dataSource", void 0);
__decorate$10([
    Property()
], Resources.prototype, "query", void 0);
__decorate$10([
    Property('Id')
], Resources.prototype, "idField", void 0);
__decorate$10([
    Property('Text')
], Resources.prototype, "textField", void 0);
__decorate$10([
    Property('Expanded')
], Resources.prototype, "expandedField", void 0);
__decorate$10([
    Property('GroupID')
], Resources.prototype, "groupIDField", void 0);
__decorate$10([
    Property('Color')
], Resources.prototype, "colorField", void 0);
__decorate$10([
    Property('StartHour')
], Resources.prototype, "startHourField", void 0);
__decorate$10([
    Property('EndHour')
], Resources.prototype, "endHourField", void 0);
__decorate$10([
    Property('WorkDays')
], Resources.prototype, "workDaysField", void 0);
__decorate$10([
    Property('CssClass')
], Resources.prototype, "cssClassField", void 0);

/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable max-len */
class ResourceBase {
    constructor(parent) {
        this.resourceCollection = [];
        this.leftPixel = 25;
        this.resourceDateTree = [];
        this.parent = parent;
    }
    renderResourceHeaderIndent(tr) {
        const resColTd = createElement('td', { className: RESOURCE_LEFT_TD_CLASS });
        const resColDiv = createElement('div', { className: RESOURCE_TEXT_CLASS });
        if (this.parent.activeViewOptions.headerIndentTemplate) {
            const data = { className: [resColTd.className], type: 'emptyCells' };
            this.parent.renderHeaderIndentTemplate(data, resColTd);
        }
        else {
            resColTd.appendChild(resColDiv);
        }
        const args = { elementType: 'emptyCells', element: resColTd };
        this.parent.trigger(renderCell, args);
        tr.appendChild(resColTd);
    }
    hideResourceRows(tBody) {
        if (this.resourceCollection.length <= 1 || this.parent.virtualScrollModule) {
            return;
        }
        const trCount = this.lastResourceLevel.length;
        for (let i = 0; i < trCount; i++) {
            const resData = this.lastResourceLevel[parseInt(i.toString(), 10)].resourceData;
            const res = this.lastResourceLevel[parseInt(i.toString(), 10)].resource;
            if (resData.ClassName === RESOURCE_PARENT_CLASS && !resData[res.expandedField] &&
                !isNullOrUndefined(resData[res.expandedField])) {
                const trCollection = [].slice.call(tBody.children);
                const slicedCollection = trCollection.slice(i + 1, i + (parseInt(resData.Count, 10) + 1));
                addClass(slicedCollection, HIDDEN_CLASS);
            }
        }
    }
    createResourceColumn() {
        const resColl = this.resourceCollection;
        const resDiv = createElement('div', { className: RESOURCE_COLUMN_WRAP_CLASS });
        const tbl = this.parent.activeView.createTableLayout(RESOURCE_COLUMN_TABLE_CLASS);
        if (!this.parent.uiStateValues.isGroupAdaptive && this.parent.rowAutoHeight && this.parent.activeView.isTimelineView()
            && this.parent.activeViewOptions.group.resources.length > 0) {
            addClass([tbl], AUTO_HEIGHT);
        }
        const tBody = tbl.querySelector('tbody');
        let resData = this.generateTreeData(true);
        this.countCalculation(resColl.slice(0, -2), resColl.slice(0, -1));
        this.renderedResources = this.lastResourceLevel;
        if (this.parent.virtualScrollModule) {
            const resourceCount = this.parent.virtualScrollModule.getRenderedCount();
            this.setExpandedResources();
            resData = this.expandedResources.slice(0, resourceCount);
            this.renderedResources = resData;
        }
        append(this.getContentRows(resData), tBody);
        this.hideResourceRows(tBody);
        tbl.appendChild(tBody);
        resDiv.appendChild(tbl);
        return resDiv;
    }
    setRenderedResources() {
        const resColl = this.resourceCollection;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const temp = this.generateTreeData(true);
        this.countCalculation(resColl.slice(0, -2), resColl.slice(0, -1));
        this.renderedResources = this.lastResourceLevel;
    }
    setExpandedResources() {
        const resources = [];
        for (let i = 0; i < this.lastResourceLevel.length; i++) {
            const resource = this.lastResourceLevel[parseInt(i.toString(), 10)].resourceData;
            const count = resource.Count;
            resources.push(this.lastResourceLevel[parseInt(i.toString(), 10)]);
            const isExpanded = resource[this.lastResourceLevel[parseInt(i.toString(), 10)].resource.expandedField];
            if (!isNullOrUndefined(isExpanded) && !isExpanded && count > 0) {
                i = i + count;
            }
        }
        this.expandedResources = resources;
    }
    getContentRows(resData, isVirtualScroll) {
        const resRows = [];
        let left;
        let rIndex;
        const resColl = this.resourceCollection;
        const tr = createElement('tr');
        const td = createElement('td', { attrs: { tabindex: isVirtualScroll ? '-1' : '0' } });
        for (let i = 0; i < resData.length; i++) {
            const ntd = td.cloneNode();
            rIndex = findIndexInData(resColl, 'name', resData[parseInt(i.toString(), 10)].resource.name);
            if (rIndex === resColl.length - 1) {
                extend(resData[parseInt(i.toString(), 10)].resourceData, { ClassName: RESOURCE_CHILD_CLASS });
                this.renderedResources[parseInt(i.toString(), 10)].className = [RESOURCE_CHILD_CLASS];
            }
            else {
                extend(resData[parseInt(i.toString(), 10)].resourceData, { ClassName: RESOURCE_PARENT_CLASS });
                this.renderedResources[parseInt(i.toString(), 10)].className = [RESOURCE_PARENT_CLASS];
            }
            left = (rIndex * this.leftPixel) + 'px';
            if (resData[parseInt(i.toString(), 10)].resourceData.ClassName === RESOURCE_PARENT_CLASS
                && !isNullOrUndefined(resData[parseInt(i.toString(), 10)].resourceData.Count) && (resData[parseInt(i.toString(), 10)].resourceData.Count > 0)) {
                let iconClass;
                if (resData[parseInt(i.toString(), 10)].resourceData[resColl[parseInt(rIndex.toString(), 10)].expandedField] ||
                    isNullOrUndefined(resData[parseInt(i.toString(), 10)].resourceData[resColl[parseInt(rIndex.toString(), 10)].expandedField])) {
                    iconClass = RESOURCE_COLLAPSE_CLASS;
                }
                else {
                    iconClass = RESOURCE_EXPAND_CLASS;
                }
                const iconDiv = createElement('div');
                addClass([iconDiv], [RESOURCE_TREE_ICON_CLASS, iconClass]);
                this.setMargin(iconDiv, left);
                ntd.appendChild(iconDiv);
                if (this.resourceCollection.length > 1) {
                    EventHandler.add(iconDiv, 'click', this.onTreeIconClick, this);
                }
            }
            this.parent.activeView.setResourceHeaderContent(ntd, resData[parseInt(i.toString(), 10)], RESOURCE_TEXT_CLASS);
            ntd.setAttribute('data-group-index', resData[parseInt(i.toString(), 10)].groupIndex.toString());
            ntd.setAttribute('aria-label', resData[parseInt(i.toString(), 10)].resourceData[resData[parseInt(i.toString(), 10)].resource.textField] + ' resource');
            if (!this.parent.activeViewOptions.resourceHeaderTemplate) {
                this.setMargin(ntd.querySelector('.' + RESOURCE_TEXT_CLASS), left);
            }
            const classCollection = [RESOURCE_CELLS_CLASS, resData[parseInt(i.toString(), 10)].resourceData.ClassName];
            addClass([ntd], classCollection);
            const args = { elementType: 'resourceHeader', element: ntd, groupIndex: resData[parseInt(i.toString(), 10)].groupIndex };
            this.parent.trigger(renderCell, args);
            const ntr = tr.cloneNode();
            ntr.appendChild(ntd);
            resRows.push(ntr);
        }
        return resRows;
    }
    setMargin(element, value) {
        if (!this.parent.enableRtl) {
            element.style.marginLeft = value;
        }
        else {
            element.style.marginRight = value;
        }
    }
    countCalculation(parentCollection, wholeCollection) {
        let collection;
        for (let y = 0; y < parentCollection.length; y++) {
            const data = parentCollection[parentCollection.length - (y + 1)].dataSource;
            for (let x = 0; x < data.length; x++) {
                let totalCount = 0;
                if (this.parent.activeViewOptions.group.byGroupID) {
                    const query = new Query().where(wholeCollection[wholeCollection.length - 1].groupIDField, 'equal', data[parseInt(x.toString(), 10)][parentCollection[parentCollection.length - (y + 1)].idField]);
                    collection = new DataManager(wholeCollection[wholeCollection.length - 1].dataSource).executeLocal(query);
                }
                else {
                    collection = wholeCollection[wholeCollection.length - 1].dataSource;
                }
                for (let z = 0; z < collection.length; z++) {
                    totalCount = totalCount + parseInt(collection[parseInt(z.toString(), 10)].Count, 10);
                }
                totalCount = totalCount + parseInt(data[parseInt(x.toString(), 10)].Count, 10);
                extend(data[parseInt(x.toString(), 10)], { Count: totalCount });
            }
            wholeCollection = wholeCollection.slice(0, -1);
        }
    }
    onTreeIconClick(e) {
        if (this.parent.eventTooltip) {
            this.parent.eventTooltip.close();
        }
        const target = e.target;
        let hide;
        const trElement = closest(target, '.' + RESOURCE_PARENT_CLASS)
            .parentElement;
        const index = parseInt(trElement.children[0].getAttribute('data-group-index'), 10);
        let args = {
            cancel: false, event: e, groupIndex: index,
            requestType: !target.classList.contains(RESOURCE_COLLAPSE_CLASS) ? 'resourceExpand' : 'resourceCollapse'
        };
        this.parent.trigger(actionBegin, args, (actionArgs) => {
            if (!actionArgs.cancel) {
                if (target.classList.contains(RESOURCE_COLLAPSE_CLASS)) {
                    classList(target, [RESOURCE_EXPAND_CLASS], [RESOURCE_COLLAPSE_CLASS]);
                    hide = true;
                }
                else {
                    classList(target, [RESOURCE_COLLAPSE_CLASS], [RESOURCE_EXPAND_CLASS]);
                    hide = false;
                }
                const eventElements = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS + ',.' + MORE_INDICATOR_CLASS));
                for (const element of eventElements) {
                    remove(element);
                }
                if (this.parent.virtualScrollModule) {
                    this.updateVirtualContent(index, hide, e, target);
                }
                else {
                    this.updateContent(index, hide);
                }
                const data = { cssProperties: this.parent.getCssProperties(), module: 'scroll' };
                this.parent.notify(scrollUiUpdate, data);
                args = {
                    cancel: false, event: e, groupIndex: index,
                    requestType: target.classList.contains(RESOURCE_COLLAPSE_CLASS) ? 'resourceExpanded' : 'resourceCollapsed'
                };
                this.parent.refreshEvents(false);
                this.parent.trigger(actionComplete, args);
            }
        });
    }
    updateContent(index, hide) {
        const rowCollection = [];
        const workCellCollection = [];
        const headerRowCollection = [];
        let pNode;
        const clickedRes = this.lastResourceLevel[parseInt(index.toString(), 10)].resourceData;
        const resRows = [].slice.call(this.parent.element.querySelectorAll('.' + RESOURCE_COLUMN_WRAP_CLASS + ' ' + 'tr'));
        const contentRows = [].slice.call(this.parent.element.querySelectorAll('.' + CONTENT_WRAP_CLASS + ' ' + 'tbody tr'));
        const eventRows = [].slice.call(this.parent.element.querySelectorAll('.' + CONTENT_WRAP_CLASS + ' .' + APPOINTMENT_CONTAINER_CLASS));
        for (let j = 0; j < clickedRes.Count; j++) {
            rowCollection.push(resRows[index + j + 1]);
            workCellCollection.push(contentRows[index + j + 1]);
            headerRowCollection.push(eventRows[index + j + 1]);
        }
        const clonedCollection = this.lastResourceLevel;
        for (let i = 0; i < rowCollection.length; i++) {
            let expanded = true;
            pNode = rowCollection[parseInt(i.toString(), 10)].children[0].classList.contains(RESOURCE_PARENT_CLASS);
            clonedCollection[parseInt(index.toString(), 10)].resourceData[clonedCollection[parseInt(index.toString(), 10)].resource.expandedField] = !hide;
            if (hide) {
                if (pNode) {
                    const trElem = rowCollection[parseInt(i.toString(), 10)].querySelector('.' + RESOURCE_TREE_ICON_CLASS);
                    if (trElem) {
                        classList(trElem, [RESOURCE_EXPAND_CLASS], [RESOURCE_COLLAPSE_CLASS]);
                    }
                }
                if (!rowCollection[parseInt(i.toString(), 10)].classList.contains(HIDDEN_CLASS)) {
                    addClass([rowCollection[parseInt(i.toString(), 10)], workCellCollection[parseInt(i.toString(), 10)], headerRowCollection[parseInt(i.toString(), 10)]], HIDDEN_CLASS);
                }
            }
            else {
                if (pNode) {
                    const rowIndex = rowCollection[parseInt(i.toString(), 10)].rowIndex;
                    if (!clonedCollection[parseInt(rowIndex.toString(), 10)].resourceData[clonedCollection[parseInt(rowIndex.toString(), 10)].resource.expandedField]
                        && !isNullOrUndefined(clonedCollection[parseInt(rowIndex.toString(), 10)].resourceData[clonedCollection[parseInt(rowIndex.toString(), 10)].resource.expandedField])) {
                        rowCollection.splice(i + 1, (parseInt(clonedCollection[parseInt(rowIndex.toString(), 10)].resourceData.Count, 10)));
                        workCellCollection.splice(i + 1, (parseInt(clonedCollection[parseInt(rowIndex.toString(), 10)].resourceData.Count, 10)));
                        headerRowCollection.splice(i + 1, (parseInt(clonedCollection[parseInt(rowIndex.toString(), 10)].resourceData.Count, 10)));
                        expanded = false;
                    }
                    if (expanded) {
                        const trElem = rowCollection[parseInt(i.toString(), 10)].querySelector('.' + RESOURCE_TREE_ICON_CLASS);
                        if (trElem) {
                            classList(trElem, [RESOURCE_COLLAPSE_CLASS], [RESOURCE_EXPAND_CLASS]);
                        }
                    }
                }
                if (rowCollection[parseInt(i.toString(), 10)].classList.contains(HIDDEN_CLASS)) {
                    removeClass([rowCollection[parseInt(i.toString(), 10)], workCellCollection[parseInt(i.toString(), 10)], headerRowCollection[parseInt(i.toString(), 10)]], HIDDEN_CLASS);
                }
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateVirtualContent(index, expand, e, target) {
        this.lastResourceLevel[parseInt(index.toString(), 10)].resourceData[this.lastResourceLevel[parseInt(index.toString(), 10)].resource.expandedField] = !expand;
        this.setExpandedResources();
        const resourceCount = this.parent.virtualScrollModule.getRenderedCount();
        const startIndex = this.expandedResources.indexOf(this.renderedResources[0]);
        this.renderedResources = this.expandedResources.slice(startIndex, startIndex + resourceCount);
        if (this.renderedResources.length < resourceCount) {
            let sIndex = this.expandedResources.length - resourceCount;
            sIndex = (sIndex > 0) ? sIndex : 0;
            this.renderedResources = this.expandedResources.slice(sIndex, this.expandedResources.length);
        }
        const virtualTrack = this.parent.element.querySelector('.' + VIRTUAL_TRACK_CLASS);
        this.parent.virtualScrollModule.updateVirtualTrackHeight(virtualTrack);
        const resTable = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS + ' ' + 'table');
        const contentTable = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' ' + 'table');
        const eventTable = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);
        this.parent.virtualScrollModule.updateContent(resTable, contentTable, eventTable, this.renderedResources);
        const timeIndicator = this.parent.element.querySelector('.' + CURRENT_TIMELINE_CLASS);
        if (!isNullOrUndefined(timeIndicator)) {
            timeIndicator.style.height =
                this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS).offsetHeight + 'px';
        }
    }
    renderResourceHeader() {
        const resourceWrapper = createElement('div', { className: RESOURCE_TOOLBAR_CONTAINER });
        resourceWrapper.innerHTML = '<div class="' + RESOURCE_HEADER_TOOLBAR + '"><div class="' + RESOURCE_MENU + '">' +
            '<div class="e-icons ' + RESOURCE_MENU_ICON + '"></div></div><div class="' + RESOURCE_LEVEL_TITLE + '"></div></div>';
        if (this.parent.currentView === 'MonthAgenda') {
            const target = this.parent.activeView.getPanel().querySelector('.' + CONTENT_WRAP_CLASS);
            target.insertBefore(resourceWrapper, target.querySelector('.' + WRAPPER_CONTAINER_CLASS));
        }
        else {
            this.parent.element.insertBefore(resourceWrapper, this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS));
        }
        this.renderResourceHeaderText();
        EventHandler.add(resourceWrapper.querySelector('.' + RESOURCE_MENU_ICON), 'click', this.menuClick, this);
    }
    renderResourceTree() {
        this.popupOverlay = createElement('div', { className: RESOURCE_TREE_POPUP_OVERLAY });
        const treeWrapper = createElement('div', { className: RESOURCE_TREE_POPUP + ' e-popup-close' });
        if (this.parent.currentView === 'MonthAgenda') {
            const target = this.parent.activeView.getPanel().querySelector('.' + WRAPPER_CONTAINER_CLASS);
            target.insertBefore(treeWrapper, target.children[0]);
            target.appendChild(this.popupOverlay);
        }
        else {
            this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS).appendChild(treeWrapper);
            this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS).appendChild(this.popupOverlay);
        }
        const resourceTree = createElement('div', { className: RESOURCE_TREE });
        treeWrapper.appendChild(resourceTree);
        this.treeViewObj = new TreeView({
            cssClass: this.parent.cssClass,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            fields: {
                dataSource: [].slice.call(this.generateTreeData()),
                id: 'resourceId',
                text: 'resourceName',
                child: 'resourceChild'
            },
            nodeTemplate: this.parent.resourceHeaderTemplate,
            nodeClicked: this.resourceClick.bind(this),
            created: this.resourceTreeCreated.bind(this)
        });
        this.treeViewObj.appendTo(resourceTree);
        this.treeViewObj.expandAll();
        this.treePopup = new Popup(treeWrapper, {
            targetType: 'relative',
            actionOnScroll: 'none',
            content: this.treeViewObj.element,
            relateTo: this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS),
            enableRtl: this.parent.enableRtl,
            hideAnimation: { name: 'SlideLeftOut', duration: 500 },
            showAnimation: { name: 'SlideLeftIn', duration: 500 },
            viewPortElement: this.parent.element.querySelector('.' + (this.parent.currentView === 'MonthAgenda' ?
                WRAPPER_CONTAINER_CLASS : TABLE_CONTAINER_CLASS))
        });
        this.parent.on(documentClick, this.documentClick, this);
    }
    resourceTreeCreated() {
        if (this.parent.activeViewOptions.resourceHeaderTemplate && this.parent.portals && this.treeViewObj.portals) {
            this.parent.portals = this.parent.portals.concat(this.treeViewObj.portals);
            this.parent.renderTemplates();
        }
    }
    generateTreeData(isTimeLine) {
        const treeCollection = [];
        const resTreeColl = [];
        let groupIndex = 0;
        for (let i = 0, len = this.resourceTreeLevel.length; i < len; i++) {
            const treeHandler = (treeLevel, index, levelId) => {
                const resource = this.resourceCollection[parseInt(index.toString(), 10)];
                let treeArgs;
                let resObj;
                if (!isTimeLine) {
                    treeArgs = {
                        resourceId: levelId,
                        resourceName: treeLevel.resourceData[resource.textField],
                        resource: treeLevel.resource,
                        resourceData: treeLevel.resourceData
                    };
                }
                else {
                    resObj = {
                        type: 'resourceHeader', resource: treeLevel.resource,
                        resourceData: treeLevel.resourceData, groupIndex: groupIndex,
                        groupOrder: treeLevel.groupOrder
                    };
                    resTreeColl.push(resObj);
                    groupIndex++;
                }
                if (treeLevel.child.length > 0 && !isTimeLine) {
                    treeArgs.resourceChild = [];
                }
                let count = 1;
                for (const tree of treeLevel.child) {
                    if (!isTimeLine) {
                        treeArgs.resourceChild.push(treeHandler(tree, index + 1, levelId + '-' + count));
                    }
                    else {
                        treeHandler(tree, index + 1, levelId + '-' + count);
                    }
                    count += 1;
                }
                if (isTimeLine) {
                    extend(resObj.resourceData, { Count: count - 1 });
                }
                return treeArgs;
            };
            if (!isTimeLine) {
                treeCollection.push(treeHandler(this.resourceTreeLevel[parseInt(i.toString(), 10)], 0, (i + 1).toString()));
            }
            else {
                treeHandler(this.resourceTreeLevel[parseInt(i.toString(), 10)], 0, (i + 1).toString());
            }
        }
        if (isTimeLine) {
            this.lastResourceLevel = resTreeColl;
            return resTreeColl;
        }
        else {
            return treeCollection;
        }
    }
    renderResourceHeaderText() {
        const resource = this.lastResourceLevel[this.parent.uiStateValues.groupIndex];
        const headerCollection = [];
        for (let i = 0, len = resource.groupOrder.length; i < len; i++) {
            const resourceLevel = this.resourceCollection[parseInt(i.toString(), 10)];
            const resourceText = resourceLevel.dataSource.filter((resData) => resData[resourceLevel.idField] === resource.groupOrder[parseInt(i.toString(), 10)]);
            const resourceName = createElement('div', { className: RESOURCE_NAME });
            this.parent.sanitize(resourceText[0][resourceLevel.textField], resourceName);
            headerCollection.push(resourceName);
            const levelIcon = createElement('div', { className: 'e-icons e-icon-next' });
            headerCollection.push(levelIcon);
        }
        headerCollection.pop();
        const target = (this.parent.currentView === 'MonthAgenda') ? this.parent.activeView.getPanel() : this.parent.element;
        const headerWrapper = target.querySelector('.' + RESOURCE_LEVEL_TITLE);
        removeChildren(headerWrapper);
        for (const header of headerCollection) {
            headerWrapper.appendChild(header);
        }
        if (this.lastResourceLevel.length === 1) {
            addClass([this.parent.element.querySelector('.' + RESOURCE_MENU)], DISABLE_CLASS);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    menuClick(event) {
        if (this.parent.element.querySelector('.' + RESOURCE_TREE_POPUP).classList.contains(POPUP_OPEN)) {
            this.treePopup.hide();
            removeClass([this.popupOverlay], ENABLE_CLASS);
        }
        else {
            const treeNodes = [].slice.call(this.treeViewObj.element.querySelectorAll('.e-list-item:not(.e-has-child)'));
            removeClass(treeNodes, 'e-active');
            addClass([treeNodes[this.parent.uiStateValues.groupIndex]], 'e-active');
            this.treePopup.show();
            addClass([this.popupOverlay], ENABLE_CLASS);
        }
    }
    selectResourceByIndex(groupIndex) {
        if (this.lastResourceLevel && groupIndex > -1 && groupIndex < this.lastResourceLevel.length) {
            this.triggerEvents(groupIndex);
        }
    }
    resourceClick(event) {
        if (!event.node.classList.contains('e-has-child')) {
            this.treePopup.hide();
            removeClass([this.popupOverlay], ENABLE_CLASS);
            const treeNodes = [].slice.call(this.treeViewObj.element.querySelectorAll('.e-list-item:not(.e-has-child)'));
            const groupIndex = treeNodes.indexOf(event.node);
            this.triggerEvents(groupIndex, event);
            event.event.preventDefault();
        }
    }
    triggerEvents(groupIndex, event) {
        let args = { cancel: false, event: (event) ? event.event : null, groupIndex: groupIndex, requestType: 'resourceChange' };
        this.parent.trigger(actionBegin, args, (actionArgs) => {
            if (!actionArgs.cancel) {
                this.parent.uiStateValues.groupIndex = actionArgs.groupIndex;
                this.parent.renderModule.render(this.parent.currentView);
                args = {
                    cancel: false, event: (event) ? event.event : null, groupIndex: this.parent.uiStateValues.groupIndex, requestType: 'resourceChanged'
                };
                this.parent.trigger(actionComplete, args);
            }
        });
    }
    documentClick(args) {
        if (closest(args.event.target, '.' + RESOURCE_TREE_POPUP)) {
            return;
        }
        const treeWrapper = this.parent.element.querySelector('.' + RESOURCE_TREE_POPUP);
        if (treeWrapper && treeWrapper.classList.contains(POPUP_OPEN)) {
            this.treePopup.hide();
            removeClass([this.popupOverlay], ENABLE_CLASS);
        }
    }
    bindResourcesData(isSetModel) {
        this.parent.showSpinner();
        const promises = [];
        for (const resource of this.parent.resources) {
            const dataModule = new Data(this.parent, resource.dataSource, resource.query);
            promises.push(dataModule.getData(dataModule.generateQuery()));
        }
        Promise.all(promises).then((e) => this.dataManagerSuccess(e, isSetModel))
            .catch((e) => this.parent.crudModule.dataManagerFailure(e));
    }
    dataManagerSuccess(e, isSetModel) {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.parent.resourceCollection = [];
        for (let i = 0, length = e.length; i < length; i++) {
            const resource = this.parent.resources[parseInt(i.toString(), 10)];
            const resourceObj = this.getResourceModel(resource, e[parseInt(i.toString(), 10)].result);
            this.parent.resourceCollection.push(resourceObj);
        }
        this.refreshLayout(isSetModel);
    }
    getResourceModel(resource, resourceData) {
        const resourceObj = {
            field: resource.field,
            title: resource.title,
            name: resource.name,
            allowMultiple: resource.allowMultiple,
            dataSource: resourceData || resource.dataSource,
            idField: resource.idField,
            textField: resource.textField,
            groupIDField: resource.groupIDField,
            colorField: resource.colorField,
            startHourField: resource.startHourField,
            endHourField: resource.endHourField,
            workDaysField: resource.workDaysField,
            expandedField: resource.expandedField,
            cssClassField: resource.cssClassField
        };
        return resourceObj;
    }
    refreshLayout(isSetModel) {
        if (isNullOrUndefined(this.parent.uiStateValues.groupIndex) || !(this.parent.enablePersistence)) {
            this.parent.uiStateValues.groupIndex = 0;
        }
        this.parent.renderElements(isSetModel);
    }
    setResourceCollection() {
        let requiredResources = [];
        this.resourceCollection = [];
        this.colorIndex = null;
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            for (const resource of this.parent.activeViewOptions.group.resources) {
                const index = findIndexInData(this.parent.resourceCollection, 'name', resource);
                if (index >= 0) {
                    requiredResources.push(this.parent.resourceCollection[parseInt(index.toString(), 10)]);
                }
            }
        }
        else if (this.parent.resourceCollection.length > 0) {
            requiredResources = this.parent.resourceCollection;
        }
        let index = 0;
        for (const resource of requiredResources) {
            const resources = this.getResourceModel(resource);
            if (resource.name === this.parent.eventSettings.resourceColorField) {
                this.colorIndex = index;
            }
            index++;
            this.resourceCollection.push(resources);
        }
        if (isNullOrUndefined(this.colorIndex)) {
            this.colorIndex = this.resourceCollection.length - 1;
        }
    }
    generateResourceLevels(innerDates, isTimeLine) {
        const resources = this.resourceCollection;
        const resTreeGroup = [];
        let lastColumnDates = [];
        const group = (resources, index, prevResource, prevResourceData, prevOrder) => {
            const resTree = [];
            const resource = resources[0];
            if (resource) {
                let data;
                if (prevResourceData && this.parent.activeViewOptions.group.byGroupID) {
                    const id = prevResourceData[prevResource.idField];
                    data = resource.dataSource.filter((e) => e[resource.groupIDField] === id);
                }
                else {
                    data = resource.dataSource;
                }
                for (let i = 0; i < data.length; i++) {
                    let groupOrder = [];
                    if (prevOrder && prevOrder.length > 0) {
                        groupOrder = groupOrder.concat(prevOrder);
                    }
                    groupOrder.push(data[parseInt(i.toString(), 10)][resource.idField]);
                    const items = group(resources.slice(1), index + 1, resource, data[parseInt(i.toString(), 10)], groupOrder);
                    // Here validate child item empty top level resource only
                    if (index === 0 && items.length === 0 && this.resourceCollection.length > 1) {
                        continue;
                    }
                    let dateCol = [];
                    let renderDates = this.parent.activeView.renderDates;
                    let resWorkDays;
                    if (!this.parent.activeViewOptions.group.byDate && index + 1 === this.resourceCollection.length) {
                        const workDays = data[parseInt(i.toString(), 10)][resource.workDaysField];
                        const resStartHour = data[parseInt(i.toString(), 10)][resource.startHourField];
                        const resEndHour = data[parseInt(i.toString(), 10)][resource.endHourField];
                        if (workDays && workDays.length > 0) {
                            renderDates = this.parent.activeView.getRenderDates(workDays);
                            resWorkDays = workDays;
                            dateCol = this.parent.activeView.getDateSlots(renderDates, workDays);
                        }
                        else {
                            resWorkDays = this.parent.activeViewOptions.workDays;
                            dateCol = innerDates;
                        }
                        const dateSlots = this.generateCustomHours(dateCol, resStartHour, resEndHour, groupOrder);
                        lastColumnDates = lastColumnDates.concat(dateSlots);
                    }
                    const resCssClass = data[parseInt(i.toString(), 10)][resource.cssClassField];
                    const slotData = {
                        type: 'resourceHeader', className: ['e-resource-cells'],
                        resourceLevelIndex: index, groupOrder: groupOrder,
                        resource: resource, resourceData: data[parseInt(i.toString(), 10)],
                        colSpan: this.parent.activeViewOptions.group.byDate ? 1 : dateCol.length,
                        renderDates: renderDates, workDays: resWorkDays, cssClass: resCssClass,
                        child: items
                    };
                    resTree.push(slotData);
                }
                if (!resTreeGroup[parseInt(index.toString(), 10)]) {
                    resTreeGroup[parseInt(index.toString(), 10)] = [];
                }
                if (resTree.length > 0) {
                    resTreeGroup[parseInt(index.toString(), 10)].push(resTree);
                }
                return resTree;
            }
            return [];
        };
        this.resourceTreeLevel = group(resources, 0);
        return (isTimeLine) ? [] : this.generateHeaderLevels(resTreeGroup, lastColumnDates, innerDates);
    }
    generateCustomHours(renderDates, startHour, endHour, groupOrder) {
        const dateSlots = extend([], renderDates, null, true);
        for (const dateSlot of dateSlots) {
            if (startHour) {
                dateSlot.startHour = this.parent.getStartEndTime(startHour);
            }
            if (endHour) {
                dateSlot.endHour = this.parent.getStartEndTime(endHour);
            }
            if (groupOrder) {
                dateSlot.groupOrder = groupOrder;
            }
        }
        return dateSlots;
    }
    generateHeaderLevels(resTreeGroup, lastColumnDates, headerDates) {
        const headerLevels = [];
        for (let i = resTreeGroup.length - 1; i >= 0; i--) {
            let temp = 0;
            for (const currentLevelChilds of resTreeGroup[parseInt(i.toString(), 10)]) {
                for (const currentLevelChild of currentLevelChilds) {
                    if (resTreeGroup[i + 1] && resTreeGroup[i + 1].length > 0) {
                        const nextLevelChilds = resTreeGroup[parseInt((i + 1).toString(), 10)][parseInt(temp.toString(), 10)];
                        if (!nextLevelChilds) {
                            continue;
                        }
                        let colSpan = 0;
                        for (const nextLevelChild of nextLevelChilds) {
                            if (!this.parent.activeViewOptions.group.byGroupID || (this.parent.activeViewOptions.group.byGroupID &&
                                nextLevelChild.resourceData[nextLevelChild.resource.groupIDField] ===
                                    currentLevelChild.resourceData[currentLevelChild.resource.idField])) {
                                colSpan += nextLevelChild.colSpan;
                            }
                        }
                        currentLevelChild.colSpan = colSpan;
                    }
                    currentLevelChild.groupIndex = temp;
                    temp++;
                    headerLevels[currentLevelChild.resourceLevelIndex] = headerLevels[currentLevelChild.resourceLevelIndex] || [];
                    headerLevels[currentLevelChild.resourceLevelIndex].push(currentLevelChild);
                }
            }
        }
        this.lastResourceLevel = headerLevels.slice(-1)[0] || [];
        if (!this.parent.activeViewOptions.group.byDate) {
            let index = 0;
            for (const lastLevelResource of this.lastResourceLevel) {
                for (let i = 0; i < lastLevelResource.colSpan; i++) {
                    lastColumnDates[parseInt(index.toString(), 10)].groupIndex = lastLevelResource.groupIndex;
                    index++;
                }
            }
            headerLevels.push(lastColumnDates);
            return headerLevels;
        }
        const dateHeaderLevels = [];
        const levels = extend([], headerLevels, null, true);
        const datesColumn = [];
        if (this.parent.activeViewOptions.group.hideNonWorkingDays) {
            const renderDates = [];
            let dateIndex = 0;
            for (const headerDate of headerDates) {
                this.resourceDateTree[parseInt(dateIndex.toString(), 10)] = [];
                const currentDateLevels = [];
                for (let j = 0; j < this.lastResourceLevel.length; j++) {
                    let workDays = this.lastResourceLevel[parseInt(j.toString(), 10)].resourceData[this.lastResourceLevel[parseInt(j.toString(), 10)].resource.workDaysField];
                    if (!workDays) {
                        workDays = this.parent.activeViewOptions.workDays;
                    }
                    if (workDays.indexOf(headerDate.date.getDay()) !== -1) {
                        const resTd = extend({}, this.lastResourceLevel[parseInt(j.toString(), 10)], null, true);
                        resTd.date = headerDate.date;
                        this.lastResourceLevel[parseInt(j.toString(), 10)].workDays = workDays;
                        resTd.startHour = this.parent.getStartEndTime(resTd.resourceData[resTd.resource.startHourField]) ||
                            headerDate.startHour;
                        resTd.endHour = this.parent.getStartEndTime(resTd.resourceData[resTd.resource.endHourField]) ||
                            headerDate.endHour;
                        this.resourceDateTree[parseInt(dateIndex.toString(), 10)].push(resTd);
                        for (let k = 0; k < resTd.groupOrder.length; k++) {
                            if (!currentDateLevels[parseInt(k.toString(), 10)]) {
                                currentDateLevels[parseInt(k.toString(), 10)] = [];
                            }
                            if (k === resTd.groupOrder.length - 1) {
                                if (!renderDates[parseInt(j.toString(), 10)]) {
                                    renderDates[parseInt(j.toString(), 10)] = [];
                                }
                                const filterDates = resTd.renderDates.filter((x) => x.getDay() === headerDate.date.getDay());
                                renderDates[parseInt(j.toString(), 10)] = renderDates[parseInt(j.toString(), 10)].concat(filterDates);
                                currentDateLevels[parseInt(k.toString(), 10)].push(resTd);
                                continue;
                            }
                            const currentLevel = levels[parseInt(k.toString(), 10)];
                            const filteredResource = currentLevel.filter((data) => data.resourceData[data.resource.idField] === resTd.groupOrder[parseInt(k.toString(), 10)]);
                            if (filteredResource && filteredResource.length > 0) {
                                const existedResource = currentDateLevels[parseInt(k.toString(), 10)].filter((data) => data.resourceData[data.resource.idField] === resTd.groupOrder[parseInt(k.toString(), 10)]);
                                if (existedResource && existedResource.length > 0) {
                                    existedResource[0].colSpan += 1;
                                }
                                else {
                                    const filteredTd = extend({}, filteredResource[0], null, true);
                                    filteredTd.colSpan = 1;
                                    currentDateLevels[parseInt(k.toString(), 10)].push(filteredTd);
                                }
                            }
                        }
                    }
                }
                if (currentDateLevels.length > 0) {
                    for (let l = 0; l < levels.length; l++) {
                        if (!dateHeaderLevels[parseInt(l.toString(), 10)]) {
                            dateHeaderLevels[parseInt(l.toString(), 10)] = [];
                        }
                        dateHeaderLevels[parseInt(l.toString(), 10)] = dateHeaderLevels[parseInt(l.toString(), 10)].concat(currentDateLevels[parseInt(l.toString(), 10)]);
                    }
                    headerDate.colSpan = currentDateLevels[currentDateLevels.length - 1].length;
                    datesColumn.push(headerDate);
                }
                dateIndex++;
            }
            this.resourceDateTree = this.resourceDateTree.filter((data) => data.length > 0);
            this.lastResourceLevel.forEach((x, index) => {
                if (renderDates[parseInt(index.toString(), 10)]) {
                    x.renderDates = renderDates[parseInt(index.toString(), 10)].sort((a, b) => a.getTime() - b.getTime());
                }
            });
            dateHeaderLevels.unshift(datesColumn);
            return dateHeaderLevels;
        }
        let dateColSpan = 0;
        for (const firstRowTd of levels[0]) {
            dateColSpan += firstRowTd.colSpan;
        }
        for (const headerDate of headerDates) {
            headerDate.colSpan = dateColSpan;
            datesColumn.push(headerDate);
            const resGroup = extend([], levels, null, true);
            for (let k = 0, length = resGroup.length; k < length; k++) {
                if (k === resGroup.length - 1) {
                    for (const resTd of resGroup[parseInt(k.toString(), 10)]) {
                        resTd.date = headerDate.date;
                        resTd.workDays = headerDate.workDays;
                        resTd.startHour = this.parent.getStartEndTime(resTd.resourceData[resTd.resource.startHourField]) ||
                            headerDate.startHour;
                        resTd.endHour = this.parent.getStartEndTime(resTd.resourceData[resTd.resource.endHourField]) ||
                            headerDate.endHour;
                    }
                }
                if (!dateHeaderLevels[parseInt(k.toString(), 10)]) {
                    dateHeaderLevels[parseInt(k.toString(), 10)] = [];
                }
                dateHeaderLevels[parseInt(k.toString(), 10)] = dateHeaderLevels[parseInt(k.toString(), 10)].concat(resGroup[parseInt(k.toString(), 10)]);
            }
        }
        dateHeaderLevels.unshift(datesColumn);
        return dateHeaderLevels;
    }
    setResourceValues(eventObj, groupIndex) {
        const setValues = (index, field, value) => {
            if (this.resourceCollection[parseInt(index.toString(), 10)].allowMultiple && this.parent.activeViewOptions.group.allowGroupEdit) {
                eventObj[`${field}`] = [value];
            }
            else {
                eventObj[`${field}`] = value;
            }
        };
        if (groupIndex === void 0) {
            groupIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex :
                this.parent.activeCellsData.groupIndex;
        }
        if (this.parent.activeViewOptions.group.resources.length > 0 && !isNullOrUndefined(groupIndex)) {
            const groupOrder = this.lastResourceLevel[parseInt(groupIndex.toString(), 10)].groupOrder;
            for (let index = 0; index < this.resourceCollection.length; index++) {
                setValues(index, this.resourceCollection[parseInt(index.toString(), 10)].field, groupOrder[parseInt(index.toString(), 10)]);
            }
        }
        else if (this.parent.resourceCollection.length > 0) {
            for (let index = 0; index < this.resourceCollection.length; index++) {
                const data = this.resourceCollection[parseInt(index.toString(), 10)].dataSource[0];
                if (data) {
                    setValues(index, this.resourceCollection[parseInt(index.toString(), 10)].field, data[this.resourceCollection[parseInt(index.toString(), 10)].idField]);
                }
            }
        }
    }
    getResourceColor(eventObj, groupOrder) {
        const colorFieldIndex = (!isNullOrUndefined(groupOrder) &&
            this.colorIndex > groupOrder.length - 1) ? groupOrder.length - 1 : this.colorIndex;
        const resource = this.resourceCollection[parseInt(colorFieldIndex.toString(), 10)];
        if (isNullOrUndefined(groupOrder) && this.parent.activeViewOptions.group.allowGroupEdit && resource.allowMultiple) {
            return undefined;
        }
        const id = isNullOrUndefined(groupOrder) ? eventObj[resource.field] : groupOrder[parseInt(colorFieldIndex.toString(), 10)];
        const data = this.filterData(resource.dataSource, resource.idField, id);
        if (data.length > 0) {
            return data[0][resource.colorField];
        }
        return undefined;
    }
    getCssClass(eventObj) {
        const resource = this.resourceCollection.slice(-1)[0];
        if (this.parent.activeViewOptions.group.allowGroupEdit && resource.allowMultiple) {
            return undefined;
        }
        const data = this.filterData(resource.dataSource, resource.idField, eventObj[resource.field]);
        if (data.length > 0) {
            return data[0][resource.cssClassField];
        }
        return undefined;
    }
    getResourceRenderDates() {
        // eslint-disable-next-line prefer-spread
        const resourceDates = [].concat.apply([], this.lastResourceLevel.map((e) => e.renderDates));
        const removeDuplicateDates = (dateColl) => dateColl.filter((date, index, dates) => dates.map((dateObj) => dateObj.getTime()).indexOf(date.getTime()) === index);
        const renderDates = removeDuplicateDates(resourceDates);
        renderDates.sort((a, b) => a.getTime() - b.getTime());
        return renderDates;
    }
    filterData(dataSource, field, value) {
        return dataSource.filter((data) => data[`${field}`] === value);
    }
    getResourceData(eventObj, index, groupEditIndex) {
        if (this.parent.activeViewOptions.group.allowGroupEdit) {
            const resourceObj = {};
            for (const groupIndex of groupEditIndex) {
                const resourceLevel = this.lastResourceLevel[parseInt(groupIndex.toString(), 10)].groupOrder;
                for (let level = 0, length = resourceLevel.length; level < length; level++) {
                    const fieldName = this.resourceCollection[parseInt(level.toString(), 10)].field;
                    if (isNullOrUndefined(resourceObj[`${fieldName}`])) {
                        resourceObj[`${fieldName}`] = [];
                    }
                    resourceObj[`${fieldName}`].push(resourceLevel[parseInt(level.toString(), 10)]);
                }
            }
            eventObj = extend(eventObj, resourceObj);
        }
        else {
            for (let level = 0, length = this.resourceCollection.length; level < length; level++) {
                if (this.lastResourceLevel[parseInt(index.toString(), 10)]) {
                    eventObj[this.resourceCollection[parseInt(level.toString(), 10)].field] = this.lastResourceLevel[parseInt(index.toString(), 10)].groupOrder[parseInt(level.toString(), 10)];
                }
            }
        }
    }
    addResource(resources, name, index) {
        const resourceCollection = (resources instanceof Array) ? resources : [resources];
        for (const resource of this.parent.resourceCollection) {
            if (resource.name === name) {
                resourceCollection.forEach((addObj, i) => new DataManager({ json: resource.dataSource }).insert(addObj, null, null, index + i));
                break;
            }
        }
        this.refreshLayout(true);
    }
    removeResource(resourceId, name) {
        const resourceCollection = (resourceId instanceof Array) ? resourceId : [resourceId];
        for (const resource of this.parent.resourceCollection) {
            if (resource.name === name) {
                resourceCollection.forEach((removeObj) => new DataManager({ json: resource.dataSource }).remove(resource.idField, removeObj));
                break;
            }
        }
        this.refreshLayout(true);
    }
    getIndexFromResourceId(id, name, resourceData, event, parentField) {
        name = name || this.parent.resourceCollection.slice(-1)[0].name;
        if (isNullOrUndefined(resourceData)) {
            resourceData = this.resourceCollection.filter((e) => e.name === name)[0];
            if (isNullOrUndefined(resourceData)) {
                return null;
            }
        }
        const resource = resourceData.dataSource.filter((e) => {
            if (event && e[resourceData.idField] === id) {
                if (e[resourceData.groupIDField] === event[`${parentField}`]) {
                    return e[resourceData.idField] === id;
                }
                return null;
            }
            else {
                return e[resourceData.idField] === id;
            }
        })[0];
        return (this.lastResourceLevel.map((e) => e.resourceData).indexOf(resource));
    }
    resourceExpand(id, name, hide) {
        const resource = this.parent.resourceCollection.filter((e) => {
            if (e.name === name) {
                return e;
            }
            return null;
        })[0];
        let index = 0;
        const resourceData = resource.dataSource.filter((e) => e[resource.idField] === id)[0];
        if (!this.parent.activeViewOptions.group.byGroupID) {
            index = this.getIndexFromResourceId(id, name, resource);
        }
        else {
            index = this.lastResourceLevel.map((e) => e.resourceData).indexOf(resourceData);
        }
        const target = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS + ' ' + `[data-group-index="${index}"]` +
            ' ' + '.' + RESOURCE_TREE_ICON_CLASS);
        if (target) {
            if (target.classList.contains(RESOURCE_EXPAND_CLASS) && !hide) {
                target.click();
            }
            else if (target.classList.contains(RESOURCE_COLLAPSE_CLASS) && hide) {
                target.click();
            }
        }
    }
    resourceScroll(id, name) {
        if (this.parent.isAdaptive || ['Agenda', 'MonthAgenda'].indexOf(this.parent.currentView) > -1) {
            return;
        }
        const levelName = name || this.parent.resourceCollection.slice(-1)[0].name;
        let levelIndex = this.parent.resourceCollection.length - 1;
        const resource = this.parent.resourceCollection.filter((e, index) => {
            if (e.name === levelName) {
                levelIndex = index;
                return e;
            }
            return null;
        })[0];
        const scrollElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        let index = 0;
        if (this.parent.activeView.isTimelineView()) {
            if (!this.parent.activeViewOptions.group.byGroupID) {
                index = this.getIndexFromResourceId(id, levelName, resource);
            }
            else {
                const resourceData = resource.dataSource.filter((e) => e[resource.idField] === id)[0];
                index = this.lastResourceLevel.map((e) => e.resourceData).indexOf(resourceData);
            }
            if (this.parent.virtualScrollModule) {
                const virtual = this.parent.element.querySelector('.' + VIRTUAL_TRACK_CLASS);
                const averageRowHeight = Math.round(virtual.offsetHeight / this.expandedResources.length);
                if (this.parent.rowAutoHeight) {
                    scrollElement.scrollTop = 0;
                    this.parent.virtualScrollModule.virtualScrolling();
                }
                scrollElement.scrollTop = (index * averageRowHeight) - (((this.parent.virtualScrollModule.bufferCount - 1) * averageRowHeight));
                this.parent.virtualScrollModule.virtualScrolling();
                if (this.parent.rowAutoHeight) {
                    const td = this.parent.element.querySelector(`.${WORK_CELLS_CLASS}[data-group-index="${index}"]`);
                    if (td && !td.parentElement.classList.contains(HIDDEN_CLASS)) {
                        scrollElement.scrollTop =
                            (scrollElement.scrollTop < td.offsetTop) ? td.offsetTop : scrollElement.scrollTop + td.offsetTop;
                    }
                }
                else {
                    scrollElement.scrollTop = (index * averageRowHeight);
                }
            }
            else {
                const td = this.parent.element.querySelector(`.${WORK_CELLS_CLASS}[data-group-index="${index}"]`);
                if (td && !td.parentElement.classList.contains(HIDDEN_CLASS)) {
                    scrollElement.scrollTop = td.offsetTop;
                }
            }
        }
        else {
            if (!this.parent.activeViewOptions.group.byGroupID) {
                index = this.getIndexFromResourceId(id, levelName, resource);
            }
            else {
                if (levelName === this.parent.resourceCollection.slice(-1)[0].name) {
                    index = this.lastResourceLevel.map((e) => e.resourceData[resource.idField]).indexOf(id);
                }
                else {
                    index = resource.dataSource.map((e) => e[resource.idField]).indexOf(id);
                }
            }
            const offsetTarget = this.parent.element.querySelector(`.${HEADER_ROW_CLASS}:nth-child(${levelIndex + 1})`);
            const offset = [].slice.call(offsetTarget.children).map((node) => node.offsetLeft);
            scrollElement.scrollLeft = offset[parseInt(index.toString(), 10)];
        }
    }
    destroy() {
        this.parent.off(documentClick, this.documentClick);
        if (this.treeViewObj) {
            if (this.treeViewObj.portals && this.treeViewObj.portals.length > 0) {
                const treeViewTemplates = this.treeViewObj.portals.map((x) => x.propName);
                if (treeViewTemplates.length > 0) {
                    this.parent.resetTemplates(treeViewTemplates);
                }
            }
            this.treeViewObj.destroy();
            this.treeViewObj = null;
        }
        if (this.treePopup) {
            this.treePopup.destroy();
            this.treePopup = null;
            remove(this.parent.element.querySelector('.' + RESOURCE_TREE_POPUP));
            remove(this.parent.element.querySelector('.' + RESOURCE_TREE_POPUP_OVERLAY));
        }
        const resToolBarEle = this.parent.element.querySelector('.' + RESOURCE_TOOLBAR_CONTAINER);
        if (resToolBarEle) {
            remove(resToolBarEle);
        }
    }
}

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Represents the Schedule component that displays a list of events scheduled against specific date and timings,
 * thus helping us to plan and manage it properly.
 * ```html
 * <div id="schedule"></div>
 * ```
 * ```typescript
 * <script>
 *   var scheduleObj = new Schedule();
 *   scheduleObj.appendTo("#schedule");
 * </script>
 * ```
 */
let Schedule = class Schedule extends Component {
    /**
     * Constructor for creating the Schedule widget
     *
     * @param {ScheduleModel} options Accepts the schedule model properties to initiate the rendering
     * @param {string | HTMLElement} element Accepts the DOM element reference
     */
    constructor(options, element) {
        super(options, element);
    }
    /**
     * Core method that initializes the control rendering.
     *
     * @returns {void}
     * @private
     */
    render() {
        const addClasses = [];
        const removeClasses = [];
        addClasses.push(ROOT);
        if (this.enableRtl) {
            addClasses.push(RTL);
        }
        else {
            removeClasses.push(RTL);
        }
        if (this.isAdaptive) {
            addClasses.push(DEVICE_CLASS);
        }
        else {
            removeClasses.push(DEVICE_CLASS);
        }
        if (this.allowMultiDrag) {
            addClasses.push(MULTI_DRAG);
        }
        else {
            removeClasses.push(MULTI_DRAG);
        }
        if (this.cssClass) {
            const cssClass = this.cssClass.split(' ');
            for (const cls of cssClass) {
                addClasses.push(cls);
            }
        }
        classList(this.element, addClasses, removeClasses);
        this.validateDate();
        createSpinner({ target: this.element });
        this.scrollModule = new Scroll(this);
        this.scrollModule.setWidth();
        this.scrollModule.setHeight();
        this.renderModule = new Render(this);
        this.eventBase = new EventBase(this);
        this.workCellAction = new WorkCellInteraction(this);
        if (this.allowKeyboardInteraction) {
            this.keyboardInteractionModule = new KeyboardInteraction(this);
        }
        this.inlineModule = new InlineEdit(this);
        this.initializeDataModule();
        this.renderTableContainer();
        this.activeViewOptions = this.getActiveViewOptions();
        this.initializeResources();
        this.wireEvents();
    }
    renderTableContainer() {
        if (!this.element.querySelector('.' + TABLE_CONTAINER_CLASS)) {
            this.element.appendChild(this.createElement('div', { className: TABLE_CONTAINER_CLASS }));
        }
    }
    /**
     * Method to render react templates
     *
     * @param {Function} callback - Specifies the callBack method
     * @returns {void}
     * @private
     */
    renderTemplates(callback) {
        if (this.isReact) {
            this.renderReactTemplates(callback);
        }
        else if (callback) {
            callback();
        }
    }
    /**
     * Method to reset react templates
     *
     * @param {string[]} templates Accepts the template ID
     * @returns {void}
     * @private
     */
    resetTemplates(templates) {
        if (this.isAngular || this.isReact) {
            this.clearTemplate(templates);
        }
    }
    /**
     * This method renders untrusted strings and scripts securely by sanitizing them first.
     *
     * @param {string} value - A string value representing the HTML string value to be sanitized.
     * @param {HTMLElement} element - An HTML element to which the sanitized or unsanitized HTML string will be assigned.
     * @returns {void}
     * @private
     */
    sanitize(value, element) {
        if (this.enableHtmlSanitizer) {
            element.innerText = SanitizeHtmlHelper.sanitize(value);
        }
        else {
            element.innerHTML = value;
        }
    }
    initializeResources(isSetModel = false) {
        if (this.resources.length > 0) {
            this.resourceBase = new ResourceBase(this);
            this.resourceBase.bindResourcesData(isSetModel);
        }
        else {
            this.resourceBase = null;
            this.resourceCollection = [];
            this.renderElements(isSetModel);
        }
    }
    /**
     * Method to render the layout elements
     *
     * @param {boolean} isLayoutOnly Accepts the boolean value to render layout or not
     * @returns {void}
     * @private
     */
    renderElements(isLayoutOnly) {
        if (isLayoutOnly) {
            this.initializeView(this.currentView);
            this.eventWindow.refresh();
            return;
        }
        this.destroyHeaderModule();
        if (this.showHeaderBar) {
            this.headerModule = new HeaderRenderer(this);
        }
        this.renderTableContainer();
        if (Browser.isDevice || Browser.isTouch) {
            this.scheduleTouchModule = new ScheduleTouch(this);
        }
        this.initializeView(this.currentView);
        this.destroyPopups();
        if (!this.isPrinting) {
            this.initializePopups();
        }
    }
    validateDate(selectedDate = this.selectedDate) {
        // persist the selected date value
        let date = selectedDate instanceof Date ? new Date(selectedDate.getTime()) : new Date(selectedDate);
        const minDate = this.minDate instanceof Date ? new Date(this.minDate.getTime()) : new Date(this.minDate);
        const maxDate = this.maxDate instanceof Date ? new Date(this.maxDate.getTime()) : new Date(this.maxDate);
        if (minDate <= maxDate) {
            if (date < minDate) {
                date = minDate;
            }
            if (date > maxDate) {
                date = maxDate;
            }
            this.setProperties({ selectedDate: new Date('' + date), minDate: new Date('' + minDate), maxDate: new Date('' + maxDate) }, true);
            if (this.eventWindow) {
                this.eventWindow.updateMinMaxDateToEditor();
            }
        }
        else {
            throw Error('minDate should be equal or less than maxDate');
        }
    }
    getViewIndex(viewName) {
        for (let item = 0; item < this.viewCollections.length; item++) {
            const checkIndex = this.viewCollections[parseInt(item.toString(), 10)].option;
            if (checkIndex === viewName) {
                return item;
            }
        }
        return -1;
    }
    setViewOptions(isModuleLoad = false) {
        this.viewOptions = {};
        this.viewCollections = [];
        let viewName;
        let selectedView;
        const prevIndex = this.viewIndex;
        let count = 0;
        this.viewIndex = -1;
        for (const view of this.views) {
            const isOptions = (typeof view === 'string') ? false : true;
            if (typeof view === 'string') {
                viewName = view;
                if (this.currentView === viewName) {
                    selectedView = viewName;
                    this.viewIndex = count;
                }
            }
            else {
                viewName = view.option;
                if (view.isSelected) {
                    selectedView = viewName;
                    this.viewIndex = count;
                }
            }
            const obj = extend({ option: viewName }, isOptions ? view : {});
            const fieldViewName = viewName.charAt(0).toLowerCase() + viewName.slice(1);
            obj.cellHeaderTemplateName = obj.cellHeaderTemplate ? obj.option : '';
            obj.dateHeaderTemplateName = obj.dateHeaderTemplate ? obj.option : '';
            obj.dateRangeTemplateName = obj.dateRangeTemplate ? obj.option : '';
            obj.cellTemplateName = obj.cellTemplate ? obj.option : '';
            obj.dayHeaderTemplateName = obj.dayHeaderTemplate ? obj.option : '';
            obj.monthHeaderTemplateName = obj.monthHeaderTemplate ? obj.option : '';
            obj.resourceHeaderTemplateName = obj.resourceHeaderTemplate ? obj.option : '';
            obj.headerIndentTemplateName = obj.headerIndentTemplate ? obj.option : '';
            obj.eventTemplateName = obj.eventTemplate ? obj.option : '';
            if (!isNullOrUndefined(obj.firstDayOfWeek) && obj.firstDayOfWeek === 0) {
                delete obj.firstDayOfWeek;
            }
            if (!isNullOrUndefined(obj.interval) && obj.interval === 1) {
                delete obj.interval;
            }
            this.viewCollections.push(obj);
            if (isNullOrUndefined(this.viewOptions[`${fieldViewName}`])) {
                this.viewOptions[`${fieldViewName}`] = [obj];
            }
            else {
                this.viewOptions[`${fieldViewName}`].push(obj);
            }
            count++;
        }
        if (!isModuleLoad && selectedView) {
            this.setProperties({ currentView: selectedView }, true);
        }
        if (this.viewIndex === -1) {
            const currentIndex = this.getViewIndex(this.currentView);
            this.viewIndex = ((typeof this.views[0] !== 'string') && (!isNullOrUndefined(prevIndex) && prevIndex !== -1)) ? prevIndex :
                (currentIndex === -1) ? 0 : currentIndex;
        }
    }
    getActiveViewOptions() {
        const timeScale = {
            enable: this.timeScale.enable,
            interval: this.timeScale.interval,
            slotCount: this.timeScale.slotCount,
            majorSlotTemplate: this.timeScale.majorSlotTemplate,
            minorSlotTemplate: this.timeScale.minorSlotTemplate
        };
        const isYearView = this.viewCollections[this.viewIndex].option.indexOf('Year') > -1;
        const group = {
            byDate: isYearView ? false : this.group.byDate,
            byGroupID: this.group.byGroupID,
            allowGroupEdit: this.group.allowGroupEdit,
            resources: this.group.resources,
            headerTooltipTemplate: this.group.headerTooltipTemplate,
            enableCompactView: this.group.enableCompactView,
            hideNonWorkingDays: ['Day', 'Week', 'WorkWeek', 'Month'].indexOf(this.currentView) > -1 ? this.group.hideNonWorkingDays : false
        };
        const workDays = this.viewCollections[this.viewIndex].workDays ? [] : this.workDays;
        const scheduleOptions = {
            dateFormat: this.dateFormat,
            endHour: this.endHour,
            isSelected: false,
            option: null,
            readonly: this.readonly,
            startHour: this.startHour,
            allowVirtualScrolling: false,
            cellHeaderTemplate: this.cellHeaderTemplate,
            dayHeaderTemplate: this.dayHeaderTemplate,
            monthHeaderTemplate: this.monthHeaderTemplate,
            cellTemplate: this.cellTemplate,
            eventTemplate: this.eventSettings.template,
            dateHeaderTemplate: this.dateHeaderTemplate,
            dateRangeTemplate: this.dateRangeTemplate,
            resourceHeaderTemplate: this.resourceHeaderTemplate,
            headerIndentTemplate: this.headerIndentTemplate,
            firstMonthOfYear: this.firstMonthOfYear,
            firstDayOfWeek: this.firstDayOfWeek,
            workDays: workDays,
            monthsCount: this.monthsCount,
            showWeekend: this.showWeekend,
            showWeekNumber: this.showWeekNumber,
            displayName: null,
            interval: 1,
            timeScale: timeScale,
            timeFormat: this.internalTimeFormat,
            group: group,
            headerRows: this.headerRows,
            orientation: 'Horizontal',
            numberOfWeeks: 0,
            displayDate: null
        };
        const viewOptions = this.viewCollections[this.viewIndex];
        const viewsData = extend(scheduleOptions, viewOptions, undefined, true);
        if (this.firstDayOfWeek !== 0 && viewOptions.firstDayOfWeek && this.firstDayOfWeek !== viewOptions.firstDayOfWeek) {
            viewsData.firstDayOfWeek = this.firstDayOfWeek;
        }
        if (viewsData.displayDate) {
            viewsData.displayDate = viewsData.displayDate instanceof Date ? new Date(viewsData.displayDate.getTime()) :
                new Date(viewsData.displayDate);
        }
        return viewsData;
    }
    initializeDataModule() {
        this.eventFields = {
            id: this.eventSettings.fields.id,
            isBlock: this.eventSettings.fields.isBlock,
            subject: this.eventSettings.fields.subject.name,
            startTime: this.eventSettings.fields.startTime.name,
            endTime: this.eventSettings.fields.endTime.name,
            startTimezone: this.eventSettings.fields.startTimezone.name,
            endTimezone: this.eventSettings.fields.endTimezone.name,
            location: this.eventSettings.fields.location.name,
            description: this.eventSettings.fields.description.name,
            isAllDay: this.eventSettings.fields.isAllDay.name,
            recurrenceID: this.eventSettings.fields.recurrenceID.name,
            recurrenceRule: this.eventSettings.fields.recurrenceRule.name,
            recurrenceException: this.eventSettings.fields.recurrenceException.name,
            isReadonly: this.eventSettings.fields.isReadonly,
            followingID: this.eventSettings.fields.followingID
        };
        this.setEditorTitles();
        this.dataModule = new Data(this, this.eventSettings.dataSource, this.eventSettings.query);
        this.crudModule = new Crud(this);
    }
    setEditorTitles() {
        this.editorTitles = {
            subject: this.eventSettings.fields.subject.title || this.localeObj.getConstant('title'),
            startTime: this.eventSettings.fields.startTime.title || this.localeObj.getConstant('start'),
            endTime: this.eventSettings.fields.endTime.title || this.localeObj.getConstant('end'),
            isAllDay: this.eventSettings.fields.isAllDay.title || this.localeObj.getConstant('allDay'),
            startTimezone: this.eventSettings.fields.startTimezone.title || this.localeObj.getConstant('startTimezone'),
            endTimezone: this.eventSettings.fields.endTimezone.title || this.localeObj.getConstant('endTimezone'),
            location: this.eventSettings.fields.location.title || this.localeObj.getConstant('location'),
            description: this.eventSettings.fields.description.title || this.localeObj.getConstant('description'),
            recurrenceRule: this.eventSettings.fields.recurrenceRule.title || this.localeObj.getConstant('repeat')
        };
    }
    initializeView(viewName) {
        this.showSpinner();
        this.activeViewOptions = this.getActiveViewOptions();
        if (this.resourceBase) {
            this.resourceBase.setResourceCollection();
        }
        this.initializeTemplates();
        this.renderModule.render(viewName);
    }
    initializeTemplates() {
        this.cellHeaderTemplateFn = this.templateParser(this.activeViewOptions.cellHeaderTemplate);
        this.dayHeaderTemplateFn = this.templateParser(this.activeViewOptions.dayHeaderTemplate);
        this.monthHeaderTemplateFn = this.templateParser(this.activeViewOptions.monthHeaderTemplate);
        this.cellTemplateFn = this.templateParser(this.activeViewOptions.cellTemplate);
        this.dateHeaderTemplateFn = this.templateParser(this.activeViewOptions.dateHeaderTemplate);
        this.dateRangeTemplateFn = this.templateParser(this.activeViewOptions.dateRangeTemplate);
        this.majorSlotTemplateFn = this.templateParser(this.activeViewOptions.timeScale.majorSlotTemplate);
        this.minorSlotTemplateFn = this.templateParser(this.activeViewOptions.timeScale.minorSlotTemplate);
        this.appointmentTemplateFn = this.templateParser(this.activeViewOptions.eventTemplate);
        this.resourceHeaderTemplateFn = this.templateParser(this.activeViewOptions.resourceHeaderTemplate);
        this.headerIndentTemplateFn = this.templateParser(this.activeViewOptions.headerIndentTemplate);
        this.headerTooltipTemplateFn = this.templateParser(this.activeViewOptions.group.headerTooltipTemplate);
        this.eventTooltipTemplateFn = this.templateParser(this.eventSettings.tooltipTemplate);
        this.editorTemplateFn = this.templateParser(this.editorTemplate);
        this.quickInfoTemplatesHeaderFn = this.templateParser(this.quickInfoTemplates.header);
        this.quickInfoTemplatesContentFn = this.templateParser(this.quickInfoTemplates.content);
        this.quickInfoTemplatesFooterFn = this.templateParser(this.quickInfoTemplates.footer);
    }
    initializePopups() {
        this.eventWindow = new EventWindow(this);
        this.quickPopup = new QuickPopups(this);
    }
    /**
     * Method to get day names
     *
     * @param {string} type Accepts the day name
     * @returns {string[]} Returns the collection of day names
     * @private
     */
    getDayNames(type) {
        const culShortNames = [];
        let cldrObj;
        let nameSpace = '';
        if (this.locale === 'en' || this.locale === 'en-US') {
            nameSpace = 'days.stand-alone.';
            cldrObj = (getValue(nameSpace + type, getDefaultDateObject(this.getCalendarMode())));
        }
        else {
            nameSpace = 'main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.days.format.' + type;
            cldrObj = (getValue(nameSpace, cldrData));
        }
        for (const obj of Object.keys(cldrObj)) {
            culShortNames.push(getValue(obj, cldrObj));
        }
        return culShortNames;
    }
    setCldrTimeFormat() {
        if (!isNullOrUndefined(this.timeFormat)) {
            this.internalTimeFormat = this.timeFormat;
            return;
        }
        if (this.locale === 'en' || this.locale === 'en-US') {
            this.internalTimeFormat = (getValue('timeFormats.short', getDefaultDateObject(this.getCalendarMode())));
        }
        else {
            this.internalTimeFormat = (getValue('main.' + '' + this.locale + '.dates.calendars.' + this.getCalendarMode() + '.timeFormats.short', cldrData));
        }
    }
    /**
     * Method to get calendar mode
     *
     * @returns {string} Returns the calendar mode
     * @private
     */
    getCalendarMode() {
        return this.calendarMode.toLowerCase();
    }
    /**
     * Method to get time in string
     *
     * @param {Date} date Accepts the date object
     * @returns {string} Returns the time in string
     * @private
     */
    getTimeString(date) {
        const time = this.globalize.formatDate(date, {
            format: this.activeViewOptions.timeFormat,
            type: 'time', calendar: this.getCalendarMode()
        });
        return time.toLocaleUpperCase();
    }
    /**
     * Method to get  date object
     *
     * @param {Date} date Accepts the date object
     * @returns {Date} Returns the date object
     * @private
     */
    getDateTime(date) {
        return date instanceof Date ? new Date(date.getTime()) : new Date(date);
    }
    setCalendarMode() {
        if (this.calendarMode === 'Islamic') {
            this.calendarUtil = new Islamic();
        }
        else {
            this.calendarUtil = new Gregorian();
        }
    }
    /**
     * Method to change the current view
     *
     * @param {View} view Accepts the view name
     * @param {Event} event Accepts the event object
     * @param {boolean} muteOnChange Accepts the value to enable or disable mute on change
     * @param {number} index Accepts the index value
     * @returns {void}
     * @private
     */
    changeView(view, event, muteOnChange, index) {
        if (isNullOrUndefined(index)) {
            index = this.getViewIndex(view);
        }
        if (!muteOnChange && index === this.viewIndex && this.currentView === view || index < 0) {
            return;
        }
        const previousView = this.activeViewOptions ? this.activeViewOptions.option : this.currentView;
        let args = { requestType: 'viewNavigate', cancel: false, event: event };
        this.trigger(actionBegin, args, (actionArgs) => {
            if (!actionArgs.cancel) {
                const navArgs = {
                    action: 'view', cancel: false, currentDate: this.selectedDate, previousView: previousView, currentView: view, viewIndex: index
                };
                this.trigger(navigating, navArgs, (navigationArgs) => {
                    if (!navigationArgs.cancel) {
                        const isVertical = ['Day', 'Week', 'WorkWeek'].indexOf(view) > -1 && ['Day', 'Week', 'WorkWeek'].indexOf(previousView) < 0;
                        this.uiStateValues.isInitial = isVertical || view.indexOf('Timeline') > -1 || view.indexOf('Year') > -1;
                        this.uiStateValues.top = view.indexOf('Timeline') > -1 && previousView.indexOf('Timeline') < 0 ? 0 : this.uiStateValues.top;
                        this.viewIndex = navigationArgs.viewIndex;
                        this.setProperties({ currentView: view }, true);
                        if (this.headerModule) {
                            this.headerModule.updateActiveView();
                            this.headerModule.setCalendarDate(this.selectedDate);
                            this.headerModule.setCalendarView();
                        }
                        this.initializeView(this.currentView);
                        this.animateLayout();
                        args = { requestType: 'viewNavigate', cancel: false, event: event };
                        this.trigger(actionComplete, args);
                    }
                    else {
                        this.currentView = previousView;
                    }
                });
            }
            else {
                this.currentView = previousView;
            }
        });
    }
    /**
     * Method to change the view date
     *
     * @param {Date} selectedDate Accepts the selected date
     * @param {Event} event Accepts the event object
     * @returns {void}
     * @private
     */
    changeDate(selectedDate, event) {
        let args = { requestType: 'dateNavigate', cancel: false, event: event };
        this.trigger(actionBegin, args, (actionArgs) => {
            if (!actionArgs.cancel) {
                const navArgs = {
                    action: 'date', cancel: false, previousDate: this.selectedDate, currentDate: selectedDate
                };
                this.trigger(navigating, navArgs, (navigationArgs) => {
                    if (!navigationArgs.cancel) {
                        this.uiStateValues.isInitial = this.activeView.isTimelineView() && this.currentView !== 'TimelineYear';
                        this.validateDate(navigationArgs.currentDate);
                        if (this.headerModule) {
                            this.headerModule.setCalendarDate(navigationArgs.currentDate);
                        }
                        if (this.currentView === 'MonthAgenda' && this.monthAgendaModule) {
                            this.monthAgendaModule.monthAgendaDate = new Date('' + this.selectedDate);
                        }
                        this.initializeView(this.currentView);
                        this.animateLayout();
                        args = { requestType: 'dateNavigate', cancel: false, event: event };
                        this.trigger(actionComplete, args);
                    }
                });
            }
        });
    }
    /**
     * Method to validate min and max date
     *
     * @param {Date} date Accepts the date object
     * @returns {boolean} Returns the boolean result to validate the min and max date
     * @private
     */
    isMinMaxDate(date = this.selectedDate) {
        return ((date.getTime() >= this.minDate.getTime()) && (date.getTime() <= this.maxDate.getTime()));
    }
    /**
     * Method to validate the selected date
     *
     * @param {Date} date Accepts the date object
     * @returns {boolean} Returns the boolean value for given date is selected date or not
     * @private
     */
    isSelectedDate(date) {
        return date.setHours(0, 0, 0, 0) === new Date('' + this.selectedDate).setHours(0, 0, 0, 0);
    }
    /**
     * Method to get the current time
     *
     * @param {Date} date Accepts the date object
     * @returns {Date} Returns the date object after performing the timezone conversion
     * @private
     */
    getCurrentTime(date = new Date()) {
        if (this.timezone) {
            return this.tzModule.convert(date, this.tzModule.getLocalTimezoneName(), this.timezone);
        }
        return date;
    }
    /** Method to get navigate view
     *
     * @returns {View} Return the navigate view name
     * @private
     */
    getNavigateView() {
        if (this.activeView.isTimelineView()) {
            return this.currentView === 'TimelineMonth' || this.currentView === 'TimelineYear' ? 'TimelineDay' : 'Agenda';
        }
        return 'Day';
    }
    animateLayout() {
        if (!this.activeView.element) {
            return;
        }
        new Animation({ duration: 600, name: 'FadeIn', timingFunction: 'easeIn' }).animate(this.activeView.element);
    }
    /**
     * To provide the array of modules needed for control rendering
     *
     * @returns {ModuleDeclaration[]} Returns the declared modules
     * @private
     */
    requiredModules() {
        const modules = [];
        this.setViewOptions(true);
        for (let view of Object.keys(this.viewOptions)) {
            view = (view === 'timelineDay' || view === 'timelineWeek' || view === 'timelineWorkWeek') ? 'timelineViews' : view;
            modules.push({ member: view, args: [this] });
        }
        if (this.allowDragAndDrop) {
            modules.push({ member: 'dragAndDrop', args: [this] });
        }
        if (this.allowResizing) {
            modules.push({ member: 'resize', args: [this] });
        }
        modules.push({ member: 'excelExport', args: [this] });
        modules.push({ member: 'iCalendarExport', args: [this] });
        modules.push({ member: 'iCalendarImport', args: [this] });
        modules.push({ member: 'print', args: [this] });
        return modules;
    }
    /**
     * Initializes the values of private members.
     *
     * @returns {void}
     * @private
     */
    preRender() {
        this.isAdaptive = Browser.isDevice || isIPadDevice();
        this.globalize = new Internationalization(this.locale);
        this.tzModule = new Timezone();
        if (this && isNullOrUndefined(this.uiStateValues) || !(this.enablePersistence)) {
            this.uiStateValues = {
                expand: false, isInitial: true, left: 0, top: 0, isGroupAdaptive: false,
                isIgnoreOccurrence: false, groupIndex: 0, action: false, isBlock: false, isCustomMonth: true, isPreventTimezone: false
            };
        }
        this.currentTimezoneDate = this.getCurrentTime();
        this.activeCellsData = { startTime: new Date(this.currentTimezoneDate), endTime: new Date(this.currentTimezoneDate), isAllDay: false };
        this.activeEventData = { event: undefined, element: undefined };
        this.getDefaultLocale();
        this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);
        this.setCldrTimeFormat();
        this.setCalendarMode();
        this.eventsData = [];
        this.eventsProcessed = [];
        this.blockData = [];
        this.blockProcessed = [];
        this.resourceCollection = [];
        this.currentAction = null;
        this.selectedElements = [];
        this.setViewOptions();
    }
    getDefaultLocale() {
        this.defaultLocale = {
            day: 'Day',
            week: 'Week',
            workWeek: 'Work Week',
            month: 'Month',
            year: 'Year',
            agenda: 'Agenda',
            weekAgenda: 'Week Agenda',
            workWeekAgenda: 'Work Week Agenda',
            monthAgenda: 'Month Agenda',
            today: 'Today',
            noEvents: 'No events',
            emptyContainer: 'There are no events scheduled on this day.',
            allDay: 'All day',
            start: 'Start',
            end: 'End',
            more: 'more',
            close: 'Close',
            cancel: 'Cancel',
            noTitle: '(No Title)',
            delete: 'Delete',
            deleteEvent: 'Delete Event',
            deleteMultipleEvent: 'Delete Multiple Events',
            selectedItems: 'Items selected',
            deleteSeries: 'Entire Series',
            edit: 'Edit',
            editSeries: 'Entire Series',
            editEvent: 'Edit Event',
            createEvent: 'Create',
            subject: 'Subject',
            addTitle: 'Add title',
            moreDetails: 'More Details',
            save: 'Save',
            editContent: 'How would you like to change the appointment in the series?',
            deleteContent: 'Are you sure you want to delete this event?',
            deleteMultipleContent: 'Are you sure you want to delete the selected events?',
            newEvent: 'New Event',
            title: 'Title',
            location: 'Location',
            description: 'Description',
            timezone: 'Timezone',
            startTimezone: 'Start Timezone',
            endTimezone: 'End Timezone',
            repeat: 'Repeat',
            saveButton: 'Save',
            cancelButton: 'Cancel',
            deleteButton: 'Delete',
            recurrence: 'Recurrence',
            wrongPattern: 'The recurrence pattern is not valid.',
            seriesChangeAlert: 'Do you want to cancel the changes made to specific ' +
                'instances of this series and match it to the whole series again?',
            createError: 'The duration of the event must be shorter than how frequently it occurs. ' +
                'Shorten the duration, or change the recurrence pattern in the recurrence event editor.',
            sameDayAlert: 'Two occurrences of the same event cannot occur on the same day.',
            occurenceAlert: 'Cannot reschedule an occurrence of the recurring appointment if it skips over ' +
                'a later occurrence of the same appointment.',
            editRecurrence: 'Edit Recurrence',
            repeats: 'Repeats',
            alert: 'Alert',
            startEndError: 'The selected end date occurs before the start date.',
            invalidDateError: 'The entered date value is invalid.',
            blockAlert: 'Events cannot be scheduled within the blocked time range.',
            ok: 'Ok',
            yes: 'Yes',
            no: 'No',
            occurrence: 'Occurrence',
            series: 'Series',
            previous: 'Previous',
            next: 'Next',
            timelineDay: 'Timeline Day',
            timelineWeek: 'Timeline Week',
            timelineWorkWeek: 'Timeline Work Week',
            timelineMonth: 'Timeline Month',
            timelineYear: 'Timeline Year',
            editFollowingEvent: 'Following Events',
            deleteTitle: 'Delete Event',
            editTitle: 'Edit Event',
            beginFrom: 'Begin From',
            endAt: 'Ends At',
            expandAllDaySection: 'Expand-all-day-section',
            collapseAllDaySection: 'Collapse-all-day-section',
            searchTimezone: 'Search Timezone',
            noRecords: 'No records found'
        };
    }
    wireEvents() {
        EventHandler.add(window, 'resize', this.onScheduleResize, this);
        EventHandler.add(window, 'orientationchange', this.onScheduleResize, this);
        EventHandler.add(document, Browser.touchStartEvent, this.onDocumentClick, this);
    }
    /**
     * Method to remove selected class
     *
     * @returns {void}
     * @private
     */
    removeSelectedClass() {
        const selectedCells = this.getSelectedCells();
        for (const cell of selectedCells) {
            if (this.currentView !== 'Year') {
                cell.setAttribute('aria-selected', 'false');
            }
            cell.removeAttribute('tabindex');
        }
        removeClass(selectedCells, SELECTED_CELL_CLASS);
        if (this.keyboardInteractionModule && this.keyboardInteractionModule.selectedCells.length > 0) {
            this.keyboardInteractionModule.selectedCells = [];
        }
    }
    /**
     * Method to add selected class
     *
     * @param {HTMLTableCellElement[]} cells Accepts the collection of elements
     * @param {HTMLTableCellElement} focusCell Accepts the focus element
     * @param {boolean} isPreventScroll Accepts the boolean value to prevent scroll
     * @returns {void}
     * @private
     */
    addSelectedClass(cells, focusCell, isPreventScroll) {
        if (this.currentView !== 'Year') {
            for (const cell of cells) {
                cell.setAttribute('aria-selected', 'true');
            }
        }
        addClass(cells, SELECTED_CELL_CLASS);
        if (focusCell) {
            focusCell.setAttribute('tabindex', '0');
            focusCell.focus({ preventScroll: isPreventScroll || false });
        }
    }
    /**
     * Method to select cell
     *
     * @param {HTMLElement | HTMLTableCellElement} element Accepts the select element
     * @returns {void}
     * @private
     */
    selectCell(element) {
        this.removeSelectedClass();
        this.addSelectedClass([element], element);
    }
    /**
     * Method to get all day row element
     *
     * @returns {Element} Returns the all day row element
     * @private
     */
    getAllDayRow() {
        return this.element.querySelector('.' + ALLDAY_ROW_CLASS);
    }
    /**
     * Method to get content table element
     *
     * @returns {HTMLElement} Returns the content table element
     * @private
     */
    getContentTable() {
        return this.activeView.element.querySelector('.' + CONTENT_TABLE_CLASS + ' tbody');
    }
    /**
     * Method to get all content table rows
     *
     * @returns {HTMLElement[]} Returns the content table rows
     * @private
     */
    getTableRows() {
        return [].slice.call(this.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody tr:not(.' + HIDDEN_CLASS + ')'));
    }
    /**
     * Method to get work cell elements
     *
     * @returns {Element[]} Returns the all work cell elements
     * @private
     */
    getWorkCellElements() {
        return [].slice.call(this.element.querySelectorAll('.' + WORK_CELLS_CLASS));
    }
    /**
     * Method to get the index from date collection
     *
     * @param {Date[]} collection Accepts the collections of date
     * @param {Date} date Accepts the date object
     * @returns {number} Returns the index compared date with date collections
     * @private
     */
    getIndexOfDate(collection, date) {
        return collection.map(Number).indexOf(+date);
    }
    /**
     * Method to find all day cell
     *
     * @param {Element} td Accepts the DOM Element
     * @returns {boolean} Returns the boolean value
     * @private
     */
    isAllDayCell(td) {
        if (['Month', 'TimelineMonth', 'TimelineYear', 'MonthAgenda'].indexOf(this.currentView) > -1 ||
            td.classList.contains(ALLDAY_CELLS_CLASS) ||
            td.classList.contains(HEADER_CELLS_CLASS) || !this.activeViewOptions.timeScale.enable) {
            return true;
        }
        if (this.activeView.isTimelineView() && this.activeViewOptions.headerRows.length > 0 &&
            this.activeViewOptions.headerRows.slice(-1)[0].option !== 'Hour') {
            return true;
        }
        return false;
    }
    /**
     * Method to get date from element
     *
     * @param {Element} td Accepts the DOM element
     * @returns {Date} Returns the date object
     * @private
     */
    getDateFromElement(td) {
        let dateString;
        if (!isNullOrUndefined(td)) {
            dateString = td.getAttribute('data-date');
        }
        if (!isNullOrUndefined(dateString)) {
            const dateInMS = parseInt(dateString, 10);
            const date = new Date(dateInMS);
            return date;
        }
        return undefined;
    }
    /**
     * Method to get target element from given selector
     *
     * @param {string} selector Accepts the element selector
     * @param {number} left Accepts the pageX value
     * @param {number} top Accepts the pageY value
     * @returns {Element[]} Returns the collection of elements based on the given selector
     * @private
     */
    getTargetElement(selector, left, top) {
        const element = document.elementFromPoint(left, top);
        let targetElement;
        if (element) {
            targetElement = element.closest(selector);
        }
        return (targetElement) ? [targetElement] : null;
    }
    /**
     * Method to process cell header template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getCellHeaderTemplate() {
        return this.cellHeaderTemplateFn;
    }
    /**
     * Method to process cell header template in year view.
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getDayHeaderTemplate() {
        return this.dayHeaderTemplateFn;
    }
    /**
     * Method to process cell header template in year view.
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getMonthHeaderTemplate() {
        return this.monthHeaderTemplateFn;
    }
    /**
     * Method to process cell template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getCellTemplate() {
        return this.cellTemplateFn;
    }
    /**
     * Method to process date header template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getDateHeaderTemplate() {
        return this.dateHeaderTemplateFn;
    }
    /**
     * Method to process date range template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getDateRangeTemplate() {
        return this.dateRangeTemplateFn;
    }
    /**
     * Method to process major slot template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getMajorSlotTemplate() {
        return this.majorSlotTemplateFn;
    }
    /**
     * Method to process minor slot template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getMinorSlotTemplate() {
        return this.minorSlotTemplateFn;
    }
    /**
     * Method to process appointment template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getAppointmentTemplate() {
        return this.appointmentTemplateFn;
    }
    /**
     * Method to process appointment tooltip template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getEventTooltipTemplate() {
        return this.eventTooltipTemplateFn;
    }
    /**
     * Method to process header tooltip template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getHeaderTooltipTemplate() {
        return this.headerTooltipTemplateFn;
    }
    /**
     * Method to process editor template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getEditorTemplate() {
        return this.editorTemplateFn;
    }
    /**
     * Method to process quick info header template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getQuickInfoTemplatesHeader() {
        return this.quickInfoTemplatesHeaderFn;
    }
    /**
     * Method to process quick info content template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getQuickInfoTemplatesContent() {
        return this.quickInfoTemplatesContentFn;
    }
    /**
     * Method to process quick info footer template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getQuickInfoTemplatesFooter() {
        return this.quickInfoTemplatesFooterFn;
    }
    /**
     * Method to process resource header template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getResourceHeaderTemplate() {
        return this.resourceHeaderTemplateFn;
    }
    /**
     * Method to process indent template
     *
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    getHeaderIndentTemplate() {
        return this.headerIndentTemplateFn;
    }
    /**
     * Method to get dynamic CSS properties
     *
     * @returns {ScrollCss} Returns the CSS properties dynamically
     * @private
     */
    getCssProperties() {
        const cssProps = {
            border: this.enableRtl ? 'borderLeftWidth' : 'borderRightWidth',
            padding: this.enableRtl ? 'paddingLeft' : 'paddingRight',
            rtlBorder: this.enableRtl ? 'borderRightWidth' : 'borderLeftWidth',
            rtlPadding: this.enableRtl ? 'paddingRight' : 'paddingLeft'
        };
        return cssProps;
    }
    /**
     * Method to remove new event element in adaptive mode
     *
     * @returns {void}
     * @private
     */
    removeNewEventElement() {
        const eventClone = this.element.querySelector('.' + NEW_EVENT_CLASS);
        if (!isNullOrUndefined(eventClone)) {
            remove(eventClone);
        }
    }
    /**
     * Method to get start end time from string
     *
     * @param {string} startEndTime Accepts the start end time string value
     * @returns {Date} Returns the date object
     * @private
     */
    getStartEndTime(startEndTime) {
        if (!isNullOrUndefined(startEndTime) && startEndTime !== '') {
            const startEndDate = resetTime(new Date(this.currentTimezoneDate) || this.getCurrentTime());
            const timeString = startEndTime.split(':');
            if (timeString.length === 2) {
                startEndDate.setHours(parseInt(timeString[0], 10), parseInt(timeString[1], 10), 0);
            }
            return startEndDate;
        }
        return null;
    }
    onDocumentClick(args) {
        this.notify(documentClick, { event: args });
    }
    onScheduleResize() {
        if (isNullOrUndefined(this.activeView) || ((this.isAdaptive || isMobile()) && document.activeElement
            && document.activeElement.classList.contains(SUBJECT_CLASS))) {
            return;
        }
        if (this.activeViewOptions.timeScale.enable && this.activeView) {
            this.activeView.highlightCurrentTime();
        }
        if (this.quickPopup) {
            this.quickPopup.onClosePopup();
        }
        if (this.currentView === 'Month' || ((this.currentView !== 'Agenda' && this.currentView !== 'MonthAgenda')
            && !this.activeViewOptions.timeScale.enable) || this.activeView.isTimelineView()) {
            this.activeView.resetColWidth();
            this.notify(scrollUiUpdate, { cssProperties: this.getCssProperties(), isPreventScrollUpdate: true });
            this.refreshEvents(false);
        }
        else {
            this.notify(contentReady, {});
        }
    }
    /**
     * Method to process the templates
     *
     * @param {string} template Accepts the template in string
     * @returns {CallbackFunction} Returns the callback function
     * @private
     */
    templateParser(template) {
        if (template) {
            try {
                if (document.querySelectorAll(template).length) {
                    return compile(document.querySelector(template).innerHTML.trim());
                }
                else {
                    return compile(template);
                }
            }
            catch (error) {
                return compile(template);
            }
        }
        return undefined;
    }
    /**
     * Retrieves the selected cells.
     *
     * @returns {Element[]} The elements of currently selected cells will be returned.
     * @private
     */
    getSelectedCells() {
        return [].slice.call(this.element.querySelectorAll('.' + SELECTED_CELL_CLASS));
    }
    /**
     * Method to generate the announcement string
     *
     * @param {Object} event Accepts the event object
     * @param {string} subject Accepts the subject text
     * @returns {string} Returns the announcement string
     * @private
     */
    getAnnouncementString(event, subject) {
        let resourceName;
        if (this.quickPopup && this.activeViewOptions.group.resources.length > 0) {
            const constantText = '"s event - ';
            resourceName = this.quickPopup.getResourceText({ event: event }, 'event') + constantText;
        }
        const recordSubject = (subject || (event[this.eventFields.subject] || this.eventSettings.fields.subject.default));
        const skeleton = 'full';
        const startDateText = this.globalize.formatDate(event[this.eventFields.startTime], {
            type: 'dateTime', skeleton: skeleton, calendar: this.getCalendarMode()
        });
        const endDateText = this.globalize.formatDate(event[this.eventFields.endTime], {
            type: 'dateTime', skeleton: skeleton, calendar: this.getCalendarMode()
        });
        let announcementString = recordSubject + ' ' + this.localeObj.getConstant('beginFrom') + ' '
            + startDateText + ' ' + this.localeObj.getConstant('endAt') + ' ' + endDateText;
        if (resourceName) {
            announcementString = resourceName + ' ' + announcementString;
        }
        return announcementString;
    }
    /**
     * Method to process the element boundary validation
     *
     * @param {number} pageY Accepts the pageY value
     * @param {number} pageX Accepts the pageX value
     * @returns {ResizeEdges} Returns the boundary validation object
     * @private
     */
    boundaryValidation(pageY, pageX) {
        const autoScrollDistance = 30;
        const scrollEdges = { left: false, right: false, top: false, bottom: false };
        const viewBoundaries = this.element.querySelector('.' + CONTENT_WRAP_CLASS).getBoundingClientRect();
        if ((pageY < viewBoundaries.top + autoScrollDistance + window.pageYOffset) &&
            (pageY > viewBoundaries.top + window.pageYOffset)) {
            scrollEdges.top = true;
        }
        if ((pageY > (viewBoundaries.bottom - autoScrollDistance) + window.pageYOffset) &&
            (pageY < viewBoundaries.bottom + window.pageYOffset)) {
            scrollEdges.bottom = true;
        }
        if ((pageX < viewBoundaries.left + autoScrollDistance + window.pageXOffset) &&
            (pageX > viewBoundaries.left + window.pageXOffset)) {
            scrollEdges.left = true;
        }
        if ((pageX > (viewBoundaries.right - autoScrollDistance) + window.pageXOffset) &&
            (pageX < viewBoundaries.right + window.pageXOffset)) {
            scrollEdges.right = true;
        }
        return scrollEdges;
    }
    /**
     * Method to get the week number.
     *
     * @param {Date[]} dates Accepts the date collections
     * @returns {number} Returns the week number
     * @private
     */
    getWeekNumberContent(dates) {
        let weekNumber;
        if (this.weekRule === 'FirstDay') {
            const weekNumberDate = getWeekLastDate(dates.slice(-1)[0], this.firstDayOfWeek);
            weekNumber = this.globalize.formatNumber(getWeekNumber(weekNumberDate));
        }
        else if (this.weekRule === 'FirstFourDayWeek') {
            const weekFirstDate = getWeekFirstDate(dates.slice(-1)[0], this.firstDayOfWeek);
            const weekLastDate = getWeekLastDate(dates.slice(-1)[0], this.firstDayOfWeek);
            const weekMidDate = getWeekMiddleDate(weekFirstDate, weekLastDate);
            weekNumber = this.globalize.formatNumber(getWeekNumber(weekMidDate));
        }
        else if (this.weekRule === 'FirstFullWeek') {
            const weekFirstDate = getWeekFirstDate(dates.slice(-1)[0], this.firstDayOfWeek);
            weekNumber = this.globalize.formatNumber(getWeekNumber(weekFirstDate));
        }
        return weekNumber;
    }
    /**
     * Method to render the header indent template.
     *
     * @param {TdData} data Accepts the td data
     * @param {Element} td Accepts the td element
     * @returns {void}
     * @private
     */
    renderHeaderIndentTemplate(data, td) {
        if (this.activeViewOptions.headerIndentTemplate) {
            const scheduleId = this.element.id + '_';
            const viewName = this.activeViewOptions.headerIndentTemplateName;
            const templateId = scheduleId + viewName + 'headerIndentTemplate';
            const indentTemplate = [].slice.call(this.getHeaderIndentTemplate()(data, this, 'headerIndentTemplate', templateId, false));
            append(indentTemplate, td);
        }
    }
    /**
     * Method to check for refreshing the targeted resource row events.
     *
     * @returns {boolean} Returns the boolean value
     * @private
     */
    isSpecificResourceEvents() {
        return this.activeViewOptions.group.resources.length > 0 && !this.activeViewOptions.group.allowGroupEdit &&
            !this.rowAutoHeight && !this.virtualScrollModule && this.activeViewOptions.group.byGroupID;
    }
    unWireEvents() {
        EventHandler.remove(window, 'resize', this.onScheduleResize);
        EventHandler.remove(window, 'orientationchange', this.onScheduleResize);
        EventHandler.remove(document, Browser.touchStartEvent, this.onDocumentClick);
    }
    /**
     * Core method to return the component name.
     *
     * @returns {string} Returns the module name
     * @private
     */
    getModuleName() {
        return 'schedule';
    }
    /**
     * Returns the properties to be maintained in the persisted state.
     *
     * @returns {string} Returns the persistance data
     * @private
     */
    getPersistData() {
        return this.addOnPersist(['currentView', 'selectedDate', 'scrollTop', 'scrollLeft']);
    }
    /**
     * Called internally, if any of the property value changed.
     *
     * @returns {void}
     * @private
     */
    onPropertyChanged(newProp, oldProp) {
        if (this.isReact && isNullOrUndefined(this.activeView)) {
            return;
        }
        const state = {
            isRefresh: false, isResource: false, isDate: false, isView: false, isLayout: false, isDataManager: false
        };
        for (const prop of Object.keys(newProp)) {
            switch (prop) {
                case 'views':
                    this.setViewOptions();
                    if (this.headerModule) {
                        this.headerModule.updateItems();
                    }
                    state.isView = true;
                    break;
                case 'currentView':
                    state.isView = true;
                    break;
                case 'minDate':
                case 'maxDate':
                case 'selectedDate':
                    state.isDate = true;
                    break;
                case 'dateFormat':
                    this.activeViewOptions = this.getActiveViewOptions();
                    if (this.headerModule) {
                        this.headerModule.updateDateRange();
                    }
                    break;
                case 'showHeaderBar':
                    this.destroyHeaderModule();
                    if (newProp.showHeaderBar) {
                        this.headerModule = new HeaderRenderer(this);
                        this.headerModule.updateDateRange();
                    }
                    this.notify(scrollUiUpdate, { cssProperties: this.getCssProperties() });
                    if (this.activeView.isTimelineView()) {
                        this.refreshEvents(false);
                    }
                    break;
                case 'workDays':
                    if (JSON.stringify(oldProp.workDays) !== JSON.stringify(newProp.workDays)) {
                        state.isLayout = true;
                    }
                    break;
                case 'showWeekend':
                case 'startHour':
                case 'endHour':
                case 'workHours':
                case 'readonly':
                case 'headerRows':
                case 'showWeekNumber':
                case 'rowAutoHeight':
                    state.isLayout = true;
                    break;
                case 'locale':
                case 'calendarMode':
                    this.globalize = new Internationalization(this.locale);
                    this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);
                    this.setCldrTimeFormat();
                    this.setCalendarMode();
                    state.isRefresh = true;
                    break;
                case 'firstDayOfWeek':
                    this.activeViewOptions.firstDayOfWeek = newProp.firstDayOfWeek;
                    if (this.eventWindow) {
                        this.eventWindow.refreshRecurrenceEditor();
                    }
                    state.isLayout = true;
                    break;
                case 'showTimeIndicator':
                    if (this.activeViewOptions.timeScale.enable && this.activeView) {
                        this.activeView.highlightCurrentTime();
                    }
                    break;
                case 'cellHeaderTemplate':
                    this.activeViewOptions.cellHeaderTemplate = newProp.cellHeaderTemplate;
                    this.cellHeaderTemplateFn = this.templateParser(this.activeViewOptions.cellHeaderTemplate);
                    state.isLayout = true;
                    break;
                case 'cellTemplate':
                    this.activeViewOptions.cellTemplate = newProp.cellTemplate;
                    this.cellTemplateFn = this.templateParser(this.activeViewOptions.cellTemplate);
                    state.isLayout = true;
                    break;
                case 'dateHeaderTemplate':
                    this.activeViewOptions.dateHeaderTemplate = newProp.dateHeaderTemplate;
                    this.dateHeaderTemplateFn = this.templateParser(this.activeViewOptions.dateHeaderTemplate);
                    state.isLayout = true;
                    break;
                case 'dateRangeTemplate':
                    this.activeViewOptions.dateRangeTemplate = newProp.dateRangeTemplate;
                    this.dateRangeTemplateFn = this.templateParser(this.activeViewOptions.dateRangeTemplate);
                    if (this.headerModule) {
                        this.headerModule.updateDateRange();
                    }
                    break;
                case 'dayHeaderTemplate':
                    this.activeViewOptions.dayHeaderTemplate = newProp.dayHeaderTemplate;
                    this.dayHeaderTemplateFn = this.templateParser(this.activeViewOptions.dayHeaderTemplate);
                    state.isLayout = true;
                    break;
                case 'monthHeaderTemplate':
                    this.activeViewOptions.monthHeaderTemplate = newProp.monthHeaderTemplate;
                    this.monthHeaderTemplateFn = this.templateParser(this.activeViewOptions.monthHeaderTemplate);
                    state.isLayout = true;
                    break;
                case 'resourceHeaderTemplate':
                    this.activeViewOptions.resourceHeaderTemplate = newProp.resourceHeaderTemplate;
                    this.resourceHeaderTemplateFn = this.templateParser(this.activeViewOptions.resourceHeaderTemplate);
                    state.isLayout = true;
                    break;
                case 'timezone':
                    this.eventBase.timezonePropertyChange(oldProp.timezone);
                    this.headerModule.setCalendarTimezone();
                    break;
                case 'enableRtl':
                    this.setRtlClass();
                    state.isRefresh = true;
                    break;
                default:
                    this.extendedPropertyChange(prop, newProp, oldProp, state);
                    break;
            }
        }
        this.propertyChangeAction(state);
    }
    propertyChangeAction(state) {
        if (state.isRefresh) {
            this.refresh();
        }
        else if (state.isResource) {
            this.initializeResources(true);
        }
        else if (state.isView) {
            this.changeView(this.currentView, null, true);
        }
        else if (state.isDate) {
            this.changeDate(this.selectedDate);
        }
        else if (state.isLayout) {
            this.activeCellsData = null;
            this.initializeView(this.currentView);
        }
        else if (state.isDataManager && this.crudModule) {
            if (this.dragAndDropModule) {
                this.dragAndDropModule.actionObj.action = '';
                removeClass([this.element], EVENT_ACTION_CLASS);
            }
            this.crudModule.refreshDataManager();
        }
    }
    allDayRowScrollUpdate() {
        const dateHeader = this.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);
        const allDayRow = this.element.querySelector('.' + ALLDAY_ROW_CLASS);
        if (this.height === 'auto' || !this.enableAllDayScroll) {
            addClass([dateHeader], ALLDAY_APPOINTMENT_AUTO);
            if (dateHeader.classList.contains(ALLDAY_APPOINTMENT_SCROLL)) {
                removeClass([dateHeader], ALLDAY_APPOINTMENT_SCROLL);
            }
            if (this.uiStateValues.expand) {
                const allDayCells = [].slice.call(this.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS));
                allDayCells[0].style.height = (allDayRow.style.height) ? allDayRow.style.height : allDayCells[1].style.height;
            }
        }
        else {
            if (dateHeader.classList.contains(ALLDAY_APPOINTMENT_AUTO)) {
                removeClass([dateHeader], ALLDAY_APPOINTMENT_AUTO);
            }
            this.eventBase.allDayExpandScroll(dateHeader);
        }
        if (!this.uiStateValues.expand) {
            allDayRow.style.height = '';
        }
    }
    extendedPropertyChange(prop, newProp, oldProp, state) {
        switch (prop) {
            case 'width':
            case 'height':
            case 'enableAllDayScroll':
                if (['Day', 'Week', 'WorkWeek'].indexOf(this.currentView) > -1) {
                    this.allDayRowScrollUpdate();
                }
                this.notify(uiUpdate, { module: 'scroll', properties: { width: newProp.width, height: newProp.height } });
                break;
            case 'cssClass':
                if (oldProp.cssClass) {
                    removeClass([this.element], oldProp.cssClass.split(' '));
                }
                if (newProp.cssClass) {
                    addClass([this.element], newProp.cssClass.split(' '));
                }
                break;
            case 'hideEmptyAgendaDays':
            case 'agendaDaysCount':
                this.activeViewOptions = this.getActiveViewOptions();
                state.isView = true;
                break;
            case 'eventSettings':
                this.onEventSettingsPropertyChanged(newProp.eventSettings, oldProp.eventSettings, state);
                break;
            case 'allowKeyboardInteraction':
                if (this.keyboardInteractionModule) {
                    this.keyboardInteractionModule.destroy();
                    this.keyboardInteractionModule = null;
                }
                if (newProp.allowKeyboardInteraction) {
                    this.keyboardInteractionModule = new KeyboardInteraction(this);
                }
                break;
            case 'timezoneDataSource':
                if (this.eventWindow) {
                    this.eventWindow.refresh();
                }
                break;
            case 'editorTemplate':
                if (!isNullOrUndefined(this.editorTemplate)) {
                    this.editorTemplateFn = this.templateParser(this.editorTemplate);
                }
                if (this.eventWindow) {
                    this.eventWindow.setDialogContent();
                }
                break;
            case 'quickInfoTemplates':
                if (this.quickInfoTemplates.header) {
                    this.quickInfoTemplatesHeaderFn = this.templateParser(this.quickInfoTemplates.header);
                }
                if (this.quickInfoTemplates.content) {
                    this.quickInfoTemplatesContentFn = this.templateParser(this.quickInfoTemplates.content);
                }
                if (this.quickInfoTemplates.footer) {
                    this.quickInfoTemplatesFooterFn = this.templateParser(this.quickInfoTemplates.footer);
                }
                break;
            case 'group':
                this.onGroupSettingsPropertyChanged(newProp.group, oldProp.group, state);
                break;
            case 'resources':
                state.isResource = true;
                break;
            case 'timeScale':
                this.activeViewOptions.timeScale.interval = newProp.timeScale.interval || this.activeViewOptions.timeScale.interval;
                this.activeViewOptions.timeScale.slotCount = newProp.timeScale.slotCount || this.activeViewOptions.timeScale.slotCount;
                if (this.eventWindow) {
                    this.eventWindow.refreshDateTimePicker();
                }
                state.isLayout = true;
                break;
            case 'allowDragAndDrop':
            case 'allowResizing':
            case 'eventDragArea':
                this.refreshEvents(false);
                break;
            case 'weekRule':
                state.isLayout = true;
                break;
            case 'firstMonthOfYear':
                this.activeViewOptions.firstMonthOfYear = newProp.firstMonthOfYear;
                this.viewIndex = this.activeView.viewIndex;
                state.isLayout = true;
                break;
            case 'monthsCount':
                this.activeViewOptions.monthsCount = newProp.monthsCount;
                this.viewIndex = this.activeView.viewIndex;
                state.isLayout = true;
                break;
            case 'timeFormat':
                this.internalTimeFormat = newProp.timeFormat || this.activeViewOptions.timeFormat;
                if (this.eventWindow) {
                    this.eventWindow.refreshDateTimePicker();
                }
                state.isLayout = true;
                break;
            case 'enableAdaptiveUI':
                if (this.showHeaderBar && this.headerModule) {
                    this.destroyHeaderModule();
                    this.headerModule = new HeaderRenderer(this);
                    this.headerModule.updateDateRange();
                }
                state.isLayout = true;
                break;
            case 'headerIndentTemplate':
                this.activeViewOptions.headerIndentTemplate = newProp.headerIndentTemplate;
                this.headerIndentTemplateFn = this.templateParser(this.activeViewOptions.headerIndentTemplate);
                state.isLayout = true;
                break;
        }
    }
    setRtlClass() {
        if (this.enableRtl) {
            addClass([this.element], 'e-rtl');
        }
        else {
            removeClass([this.element], 'e-rtl');
        }
    }
    onGroupSettingsPropertyChanged(newProp, oldProp, state) {
        for (const prop of Object.keys(newProp)) {
            if (prop === 'headerTooltipTemplate') {
                this.headerTooltipTemplateFn = this.templateParser(newProp.headerTooltipTemplate);
            }
            else {
                state.isLayout = true;
                if (this.eventWindow) {
                    this.eventWindow.refresh();
                }
            }
        }
    }
    onEventSettingsPropertyChanged(newProp, oldProp, state) {
        for (const prop of Object.keys(newProp)) {
            switch (prop) {
                case 'dataSource':
                case 'query':
                case 'fields':
                case 'includeFiltersInQuery':
                    this.initializeDataModule();
                    state.isDataManager = true;
                    break;
                case 'template':
                    this.activeViewOptions.eventTemplate = newProp.template;
                    this.appointmentTemplateFn = this.templateParser(this.activeViewOptions.eventTemplate);
                    state.isDataManager = true;
                    break;
                case 'enableTooltip':
                    if (this.eventTooltip) {
                        this.eventTooltip.destroy();
                        this.eventTooltip = null;
                    }
                    if (newProp.enableTooltip) {
                        this.eventTooltip = new EventTooltip(this);
                    }
                    break;
                case 'tooltipTemplate':
                    this.eventTooltipTemplateFn = this.templateParser(this.eventSettings.tooltipTemplate);
                    break;
                case 'resourceColorField':
                    if (this.resourceBase) {
                        this.resourceBase.setResourceCollection();
                    }
                    state.isDataManager = true;
                    break;
                case 'editFollowingEvents':
                    if (this.quickPopup) {
                        this.quickPopup.refreshQuickDialog();
                    }
                    break;
                case 'allowAdding':
                case 'allowEditing':
                case 'allowDeleting':
                    if (this.showHeaderBar && this.headerModule) {
                        this.headerModule.updateAddIcon();
                    }
                    if (this.eventWindow) {
                        this.eventWindow.refresh();
                    }
                    break;
                case 'spannedEventPlacement':
                case 'minimumEventDuration':
                case 'enableMaxHeight':
                case 'enableIndicator':
                    this.refreshEvents(false);
                    break;
                case 'ignoreWhitespace':
                    state.isLayout = true;
                    break;
            }
        }
    }
    destroyHeaderModule() {
        if (this.headerModule) {
            this.headerModule.destroy();
            this.headerModule = null;
        }
    }
    destroyPopups() {
        if (this.quickPopup) {
            this.quickPopup.destroy();
            this.quickPopup = null;
        }
        if (this.eventWindow) {
            this.eventWindow.destroy();
            this.eventWindow = null;
        }
    }
    /**
     * Allows to show the spinner on schedule at the required scenarios.
     *
     * @function showSpinner
     * @returns {void}
     */
    showSpinner() {
        showSpinner(this.element);
    }
    /**
     * When the spinner is shown manually using `showSpinner` method, it can be hidden using this `hideSpinner` method.
     *
     * @function hideSpinner
     * @returns {void}
     */
    hideSpinner() {
        hideSpinner(this.element);
    }
    /**
     * Sets different working hours on the required working days by accepting the required start and end time as well as the date collection
     *  as its parameters.
     *
     * @function setWorkHours
     * @param {Date} dates Collection of dates on which the given start and end hour range needs to be applied.
     * @param {string} start Defines the work start hour.
     * @param {string} end Defines the work end hour.
     * @param {number} groupIndex Defines the resource index from last level.
     * @returns {void}
     */
    setWorkHours(dates, start, end, groupIndex) {
        let cells = [];
        cells = this.getWorkHourCells(dates, start, end, groupIndex);
        addClass(cells, WORK_HOURS_CLASS);
    }
    /**
     * Removes or resets different working hours on the required working days by accepting the required start and end time as well as the
     * date collection as its parameters.
     * if no parameters has been passed to this function, it will remove all the work hours.
     *
     * @param {Date} dates Collection of dates on which the given start and end hour range need to be applied.
     * @param {string} start Defines the work start hour.
     * @param {string} end Defines the work end hour.
     * @param {number} groupIndex Defines the resource index from last level.
     * @returns {void}
     */
    resetWorkHours(dates = this.activeView.renderDates, start, end, groupIndex) {
        if (dates && start && end) {
            const cells = this.getWorkHourCells(dates, start, end, groupIndex);
            removeClass(cells, WORK_HOURS_CLASS);
        }
        else {
            const workHourCells = [].slice.call(this.element.querySelectorAll('.' + WORK_HOURS_CLASS));
            removeClass(workHourCells, WORK_HOURS_CLASS);
        }
    }
    getWorkHourCells(dates, start, end, groupIndex) {
        if (['Agenda', 'MonthAgenda', 'Month', 'TimelineMonth'].indexOf(this.currentView) > -1) {
            return [];
        }
        let startHour = this.getStartEndTime(start);
        let endHour = this.getStartEndTime(end);
        const tableEle = this.getContentTable();
        if (isNullOrUndefined(startHour) || isNullOrUndefined(endHour) || !tableEle) {
            return [];
        }
        startHour.setMilliseconds(0);
        endHour.setMilliseconds(0);
        const viewStartHour = this.activeView.getStartHour();
        if (startHour < viewStartHour) {
            startHour = viewStartHour;
        }
        const viewEndHour = this.activeView.getEndHour();
        if (endHour > viewEndHour) {
            endHour = viewEndHour;
        }
        const msMajorInterval = this.activeViewOptions.timeScale.interval * MS_PER_MINUTE;
        const msInterval = msMajorInterval / this.activeViewOptions.timeScale.slotCount;
        let startIndex = Math.round((startHour.getTime() - viewStartHour.getTime()) / msInterval);
        let endIndex = Math.ceil((endHour.getTime() - viewStartHour.getTime()) / msInterval);
        const tempStartIndex = startIndex;
        const tempEndIndex = endIndex;
        const cells = [];
        for (let date of dates) {
            date = this.getDateTime(date);
            resetTime(date);
            let renderDates = this.activeView.renderDates;
            if (!isNullOrUndefined(groupIndex) && this.resourceBase && !this.activeView.isTimelineView()) {
                renderDates = this.resourceBase.lastResourceLevel[parseInt(groupIndex.toString(), 10)].renderDates;
            }
            const colIndex = this.getIndexOfDate(renderDates, date);
            if (colIndex >= 0) {
                if (this.activeView.isTimelineView()) {
                    const slotsPerDay = Math.round((viewEndHour.getTime() - viewStartHour.getTime()) / msInterval);
                    startIndex = tempStartIndex + (colIndex * slotsPerDay);
                    endIndex = tempEndIndex + (colIndex * slotsPerDay);
                }
                for (let i = startIndex; i < endIndex; i++) {
                    if (this.activeView.isTimelineView()) {
                        const rowIndex = (!isNullOrUndefined(groupIndex)) ? groupIndex : 0;
                        cells.push(tableEle.rows[parseInt(rowIndex.toString(), 10)].cells[parseInt(i.toString(), 10)]);
                    }
                    else {
                        if (!isNullOrUndefined(groupIndex)) {
                            const selector = '.' + WORK_CELLS_CLASS + '[data-group-index="' + groupIndex + '"]';
                            const tds = [].slice.call(tableEle.rows[parseInt(i.toString(), 10)].querySelectorAll(selector));
                            cells.push(tds[parseInt(colIndex.toString(), 10)]);
                        }
                        else {
                            cells.push(tableEle.rows[parseInt(i.toString(), 10)].cells[parseInt(colIndex.toString(), 10)]);
                        }
                    }
                }
            }
        }
        return cells;
    }
    /**
     * Retrieves the start and end time information of the specific cell element.
     *
     * @function getCellDetails
     * @param {Element | Element[]} tdCol Accepts the single or collection of elements.
     * @returns {CellClickEventArgs} Object An object holding the startTime, endTime and all-day information along with the target HTML element will be returned.
     */
    getCellDetails(tdCol) {
        const td = (tdCol instanceof Array) ? tdCol : [tdCol];
        const firstTd = getElement(td[0]);
        const lastTd = getElement(td.slice(-1)[0]);
        const startTime = this.getDateFromElement(firstTd);
        let endTime = this.getDateFromElement(lastTd);
        if (isNullOrUndefined(startTime) || isNullOrUndefined(endTime)) {
            return undefined;
        }
        const endDateFromColSpan = this.activeView.isTimelineView() && !isNullOrUndefined(lastTd.getAttribute('colSpan')) &&
            this.headerRows.length > 0;
        const duration = endDateFromColSpan ? parseInt(lastTd.getAttribute('colSpan'), 10) : 1;
        if (!this.activeViewOptions.timeScale.enable || endDateFromColSpan || lastTd.classList.contains(ALLDAY_CELLS_CLASS) ||
            lastTd.classList.contains(HEADER_CELLS_CLASS)) {
            endTime = addDays(new Date(endTime.getTime()), duration);
        }
        else {
            endTime = this.activeView.getEndDateFromStartDate(endTime);
        }
        const data = {
            startTime: startTime,
            endTime: endTime,
            isAllDay: this.isAllDayCell(firstTd),
            element: tdCol
        };
        const groupIndex = firstTd.getAttribute('data-group-index');
        if (!isNullOrUndefined(groupIndex)) {
            data.groupIndex = parseInt(groupIndex, 10);
        }
        return data;
    }
    /**
     * Retrieves the selected cell elements.
     *
     * @function getSelectedElements
     * @returns {Element[]} The elements of currently selected cells will be returned.
     */
    getSelectedElements() {
        if (this.keyboardInteractionModule && this.keyboardInteractionModule.selectedCells.length > 0) {
            return this.keyboardInteractionModule.selectedCells;
        }
        return this.getSelectedCells();
    }
    /**
     * To get the resource collection
     *
     * @function getResourceCollections
     * @returns {ResourcesModel[]} Returns the resource collections
     */
    getResourceCollections() {
        return this.resourceCollection;
    }
    /**
     * To set the resource collection
     *
     * @function setResourceCollections
     * @param {ResourcesModel[]} resourceCol Accepts the resource collections in ResourcesModel type
     * @returns {void}
     */
    setResourceCollections(resourceCol) {
        this.setProperties({ resources: resourceCol }, false);
    }
    /**
     * Current View could be change based on the provided parameters.
     *
     * @function changeCurrentView
     * @param {View} viewName Accept the view in the viewCollections.
     * @param {number} viewIndex Accept the viewIndex in the viewCollections.
     * @returns {void}
     */
    changeCurrentView(viewName, viewIndex) {
        let index = this.getViewIndex(viewName);
        const view = viewName.charAt(0).toLowerCase() + viewName.slice(1);
        const viewOptions = this.viewOptions[`${view}`];
        if (viewOptions) {
            index = this.viewCollections.indexOf(viewOptions[viewIndex || 0]);
        }
        if (index === -1 || index === this.viewIndex) {
            return;
        }
        this.changeView(viewName, null, null, index);
    }
    /**
     * Return the current view Index.
     *
     * @function getCurrentViewIndex
     * @returns {number} Returns the view index
     */
    getCurrentViewIndex() {
        return this.viewIndex;
    }
    /**
     * Retrieves the resource details based on the provided resource index.
     *
     * @param {number} index index of the resources at the last level.
     * @returns {ResourceDetails} Object An object holding the details of resource and resourceData.
     */
    getResourcesByIndex(index) {
        if (this.resourceBase && this.resourceBase.lastResourceLevel) {
            if (index < 0 || index >= this.resourceBase.lastResourceLevel.length) {
                return undefined;
            }
            const data = this.resourceBase.lastResourceLevel[parseInt(index.toString(), 10)];
            const groupData = {};
            this.resourceBase.setResourceValues(groupData, index);
            return { resource: data.resource, resourceData: data.resourceData, groupData: groupData };
        }
        return undefined;
    }
    /**
     * This method allows to expand the resource that available on the scheduler.
     *
     * @function expandResource
     * @param {string | number} resourceId Accepts the resource id in either string or number type
     * @param {string} name Accepts the name of the resource collection
     * @returns {void}
     */
    expandResource(resourceId, name) {
        if (this.activeView.isTimelineView() && this.resourceBase && this.resourceCollection.length > 1) {
            this.resourceBase.resourceExpand(resourceId, name, false);
        }
    }
    /**
     * This method allows to collapse the resource that available on the scheduler.
     *
     * @function collapseResource
     * @param {string | number} resourceId Accepts the resource id in either string or number type
     * @param {string} name Accepts the name of the resource collection
     * @returns {void}
     */
    collapseResource(resourceId, name) {
        if (this.activeView.isTimelineView() && this.resourceBase && this.resourceCollection.length > 1) {
            this.resourceBase.resourceExpand(resourceId, name, true);
        }
    }
    /**
     * Scrolls the Schedule content area to the specified time.
     *
     * @function scrollTo
     * @param {string} hour Accepts the time value in the skeleton format of 'Hm'.
     * @param {Date} scrollDate Accepts the date object value.
     * @returns {void}
     */
    scrollTo(hour, scrollDate) {
        if (this.activeView.scrollToDate && isNullOrUndefined(hour) && scrollDate) {
            this.activeView.scrollToDate(scrollDate);
        }
        else if (this.activeView.scrollToHour) {
            this.activeView.scrollToHour(hour, scrollDate);
        }
    }
    /**
     * This method allows scroll to the position of the any resources that available on the scheduler.
     * This method is applicable for without Agenda and Month agenda views of the schedule.
     *
     * @function scrollToResource
     * @param {string | number} resourceId Accepts the resource id in either string or number type
     * @param {string} groupName Accepts the name of the resource collection
     * @returns {void}
     */
    scrollToResource(resourceId, groupName) {
        if (this.resourceBase && this.resourceBase.lastResourceLevel) {
            this.resourceBase.resourceScroll(resourceId, groupName);
        }
    }
    /**
     * Exports the Scheduler events to a calendar (.ics) file. By default, the calendar is exported with a file name `Calendar.ics`.
     * To change this file name on export, pass the custom string value as `fileName` to get the file downloaded with this provided name.
     *
     * @function exportToICalendar
     * @param {string} fileName Accepts the string value.
     * @param {Object[]} customData Accepts the collection of objects.
     * @returns {void}
     */
    exportToICalendar(fileName, customData) {
        if (this.iCalendarExportModule) {
            this.iCalendarExportModule.initializeCalendarExport(fileName, customData);
        }
        else {
            throw Error('Inject ICalendarExport module');
        }
    }
    /**
     * Imports the events from an .ics file downloaded from any of the calendars like Google or Outlook into the Scheduler.
     * This method accepts the blob object or string format of an .ics file to be imported as a mandatory argument.
     *
     * @function importICalendar
     * @param {Blob | string} fileContent Accepts the file object or string format of an .ics file.
     * @returns {void}
     */
    importICalendar(fileContent) {
        if (this.iCalendarImportModule) {
            this.iCalendarImportModule.initializeCalendarImport(fileContent);
        }
        else {
            throw Error('Inject ICalendarImport module');
        }
    }
    /**
     * Adds the newly created event into the Schedule dataSource.
     *
     * @function addEvent
     * @param {Object | Object[]} data Single or collection of event objects to be added into Schedule.
     * @returns {void}
     */
    addEvent(data) {
        this.crudModule.addEvent(data);
    }
    /**
     * Generates the occurrences of a single recurrence event based on the provided event.
     *
     * @function generateEventOccurrences
     * @param {Object} event Accepts the parent recurrence event from which the occurrences are generated.
     * @param {Date} startDate Accepts the start date for the event occurrences. If not provided, the event's start date will be used.
     * @returns {Object[]} Returns the collection of occurrence event objects.
     */
    generateEventOccurrences(event, startDate) {
        return (this.eventBase) ? this.eventBase.generateOccurrence(event, startDate) : [];
    }
    /**
     * Allows the Scheduler events data to be exported as an Excel file either in .xlsx or .csv file formats.
     * By default, the whole event collection bound to the Scheduler gets exported as an Excel file.
     * To export only the specific events of Scheduler, you need to pass the custom data collection as
     * a parameter to this `exportToExcel` method. This method accepts the export options as arguments such as fileName,
     * exportType, fields, customData, and includeOccurrences. The `fileName` denotes the name to be given for the exported
     * file and the `exportType` allows you to set the format of an Excel file to be exported either as .xlsx or .csv.
     * The custom or specific field collection of event dataSource to be exported can be provided through `fields` option
     * and the custom data collection can be exported by passing them through the `customData` option. There also exists
     * option to export each individual instances of the recurring events to an Excel file, by setting true or false to the
     * `includeOccurrences` option, denoting either to include or exclude the occurrences as separate instances on an exported Excel file.
     *
     * @function exportToExcel
     * @param {ExportOptions} excelExportOptions The export options to be set before start with exporting the Scheduler events to an Excel file.
     * @returns {void}
     */
    exportToExcel(excelExportOptions) {
        if (this.excelExportModule) {
            this.excelExportModule.initializeExcelExport(excelExportOptions);
        }
        else {
            throw Error('Inject ExcelExport module');
        }
    }
    /**
     * Method allows to print the scheduler.
     *
     * @function print
     * @param {ScheduleModel} printOptions The export options to be set before start with exporting
     * the Scheduler events to the print window.
     * @returns {void}
     */
    print(printOptions) {
        if (this.printModule) {
            this.printModule.print(printOptions);
        }
        else {
            throw Error('Inject Print module');
        }
    }
    /**
     * Updates the changes made in the event object by passing it as an parameter into the dataSource.
     *
     * @function saveEvent
     * @param {Object | Object[]} data Single or collection of event objects to be saved into Schedule.
     * @param {CurrentAction} currentAction Denotes the action that takes place either for editing occurrence or series.
     *  The valid current action names are `EditOccurrence` or `EditSeries`.
     * @returns {void}
     */
    saveEvent(data, currentAction) {
        this.crudModule.saveEvent(data, currentAction);
    }
    /**
     * Deletes the events based on the provided ID or event collection in the argument list.
     *
     * @function deleteEvent
     * @param {string | number | Object | Object[]} id Accepts the ID as string or number type or single or collection of the event object which needs to be removed from the Schedule.
     * @param {CurrentAction} currentAction Denotes the delete action that takes place either on occurrence or series events.
     *  The valid current action names are `Delete`, `DeleteOccurrence` or `DeleteSeries`.
     * @returns {void}
     */
    deleteEvent(id, currentAction) {
        this.crudModule.deleteEvent(id, currentAction);
    }
    /**
     * Retrieves the entire collection of events bound to the Schedule.
     *
     * @function getEvents
     * @param {Date} startDate Accepts the start date.
     * @param {Date} endDate Accepts te end date.
     * @param {boolean} includeOccurrences Accepts the boolean value to process the occurrence from recurrence series.
     * @returns {Object[]} Returns the collection of event objects from the Schedule.
     */
    getEvents(startDate, endDate, includeOccurrences) {
        let eventCollections = [];
        if (includeOccurrences) {
            eventCollections = this.eventBase.getProcessedEvents();
        }
        else {
            eventCollections = this.eventsData;
        }
        if (startDate) {
            startDate = this.getDateTime(startDate);
        }
        if (endDate) {
            endDate = this.getDateTime(endDate);
        }
        eventCollections = this.eventBase.filterEventsByRange(eventCollections, startDate, endDate);
        return eventCollections;
    }
    /**
     * Retrieves the entire collection of block events bound to the Schedule.
     *
     * @function getBlockEvents
     * @param {Date} startDate Accepts the start date.
     * @param {Date} endDate Accepts te end date.
     * @param {boolean} includeOccurrences Accepts the boolean value to process the occurrence from recurrence series.
     * @returns {Object[]} Returns the collection of block event objects from the Schedule.
     */
    getBlockEvents(startDate, endDate, includeOccurrences) {
        let eventCollections = [];
        if (includeOccurrences) {
            eventCollections = this.eventBase.getProcessedEvents(this.blockData);
        }
        else {
            eventCollections = this.blockData;
        }
        if (startDate) {
            startDate = this.getDateTime(startDate);
        }
        if (endDate) {
            endDate = this.getDateTime(endDate);
        }
        eventCollections = this.eventBase.filterEventsByRange(eventCollections, startDate, endDate);
        return eventCollections;
    }
    /**
     * Retrieves the occurrences of a single recurrence event based on the provided parent ID.
     *
     * @function getOccurrencesByID
     * @param {number} eventID ID of the parent recurrence data from which the occurrences are fetched.
     * @returns {Object[]} Returns the collection of occurrence event objects.
     */
    getOccurrencesByID(eventID) {
        return this.eventBase.getOccurrencesByID(eventID);
    }
    /**
     * Retrieves all the occurrences that lies between the specific start and end time range.
     *
     * @function getOccurrencesByRange
     * @param {Date} startTime Denotes the start time range.
     * @param {Date} endTime Denotes the end time range.
     * @returns {Object[]} Returns the collection of occurrence event objects that lies between the provided start and end time.
     */
    getOccurrencesByRange(startTime, endTime) {
        startTime = this.getDateTime(startTime);
        endTime = this.getDateTime(endTime);
        return this.eventBase.getOccurrencesByRange(startTime, endTime);
    }
    /**
     * Retrieves the dates that lies on active view of Schedule.
     *
     * @function getCurrentViewDates
     * @returns {Date[]} Returns the collection of dates.
     */
    getCurrentViewDates() {
        return this.activeView ? this.activeView.renderDates : [];
    }
    /**
     * Set the recurrence editor instance from custom editor template.
     *
     * @function setRecurrenceEditor
     * @param {RecurrenceEditor} recurrenceEditor instance has passed to fetch the instance in event window.
     * @returns {void}
     */
    setRecurrenceEditor(recurrenceEditor) {
        this.eventWindow.setRecurrenceEditor(recurrenceEditor);
    }
    /**
     * Get the maximum id of an event.
     *
     * @function getEventMaxID
     * @returns {number | string} Returns the maximum ID from scheduler data collections.
     */
    getEventMaxID() {
        return this.eventBase.getEventMaxID();
    }
    /**
     * Get deleted occurrences from given recurrence series.
     *
     * @function getDeletedOccurrences
     * @param {string | number | Object} recurrenceData Accepts the parent ID of the event object or parent event object
     * @returns {Object[]} Returns the collection of deleted occurrence events.
     */
    getDeletedOccurrences(recurrenceData) {
        return this.eventBase.getDeletedOccurrences(recurrenceData);
    }
    /**
     * Retrieves the events that lies on the current date range of the active view of Schedule.
     *
     * @function getCurrentViewEvents
     * @returns {Object[]} Returns the collection of events.
     */
    getCurrentViewEvents() {
        return this.eventsProcessed;
    }
    /**
     * Refreshes the event dataSource. This method may be useful when the events alone in the schedule needs to be re-rendered.
     *
     * @function refreshEvents
     * @param {boolean} isRemoteRefresh Accepts the boolean to refresh data from remote or local
     * @returns {void}
     */
    refreshEvents(isRemoteRefresh = true) {
        if (isRemoteRefresh) {
            if (this.dragAndDropModule) {
                this.dragAndDropModule.actionObj.action = '';
                removeClass([this.element], EVENT_ACTION_CLASS);
            }
            this.crudModule.refreshDataManager();
        }
        else {
            if (this.uiStateValues) {
                this.uiStateValues.isPreventTimezone = true;
            }
            if (this.crudModule) {
                this.crudModule.refreshProcessedData();
            }
            if (this.uiStateValues) {
                this.uiStateValues.isPreventTimezone = false;
            }
        }
    }
    /**
     * Method to refresh the given Schedule templates
     *
     * @param {string} templateName Accepts the template name
     * @returns {void}
     */
    refreshTemplates(templateName) {
        if (templateName) {
            this.resetTemplates([templateName]);
        }
        else {
            this.resetTemplates();
        }
        switch (templateName) {
            case 'eventTemplate':
                this.appointmentTemplateFn = this.templateParser(this.activeViewOptions.eventTemplate);
                this.refreshEvents(false);
                break;
            case 'dateHeaderTemplate':
                this.dateHeaderTemplateFn = this.templateParser(this.activeViewOptions.dateHeaderTemplate);
                this.activeView.refreshHeader();
                break;
            case 'dateRangeTemplate':
                this.dateRangeTemplateFn = this.templateParser(this.activeViewOptions.dateRangeTemplate);
                if (this.headerModule) {
                    this.headerModule.refresh();
                }
                break;
            case 'resourceHeaderTemplate':
                this.resourceHeaderTemplateFn = this.templateParser(this.activeViewOptions.resourceHeaderTemplate);
                if (this.activeView.isTimelineView()) {
                    this.activeView.refreshResourceHeader();
                }
                else {
                    this.activeView.refreshHeader();
                }
                break;
            case 'quickInfoTemplates':
                if (this.quickPopup) {
                    this.quickPopup.destroy();
                    this.quickPopup = null;
                }
                this.quickPopup = new QuickPopups(this);
                this.quickInfoTemplatesHeaderFn = this.templateParser(this.quickInfoTemplates.header);
                this.quickInfoTemplatesContentFn = this.templateParser(this.quickInfoTemplates.content);
                this.quickInfoTemplatesFooterFn = this.templateParser(this.quickInfoTemplates.footer);
                break;
            case 'editorTemplate':
                if (this.eventWindow) {
                    this.eventWindow.destroy();
                    this.eventWindow = null;
                }
                this.eventWindow = new EventWindow(this);
                this.editorTemplateFn = this.templateParser(this.editorTemplate);
                break;
            case 'tooltipTemplate':
            case 'headerTooltipTemplate':
                if (this.eventTooltip) {
                    this.eventTooltip.destroy();
                    this.eventTooltip = null;
                }
                this.eventTooltip = new EventTooltip(this);
                this.eventTooltipTemplateFn = this.templateParser(this.eventSettings.tooltipTemplate);
                this.headerTooltipTemplateFn = this.templateParser(this.activeViewOptions.group.headerTooltipTemplate);
                break;
            default:
                this.initializeView(this.currentView);
                break;
        }
    }
    /**
     * Refreshes the Schedule layout without re-render.
     *
     * @function refreshLayout
     * @returns {void}
     */
    refreshLayout() {
        this.onScheduleResize();
        if (this.headerModule) {
            this.headerModule.refresh();
        }
        if (this.eventWindow) {
            this.eventWindow.refresh();
        }
    }
    /**
     * To retrieve the appointment object from element.
     *
     * @function getEventDetails
     * @param {Element} element Denotes the event UI element on the Schedule.
     * @returns {Object} Returns the event details.
     */
    getEventDetails(element) {
        element = getElement(element);
        const guid = element.getAttribute('data-guid');
        if (guid) {
            return this.eventBase.getEventByGuid(guid);
        }
        return {};
    }
    /**
     * To check whether the given time range slots are available for event creation or already occupied by other events.
     *
     * @function isSlotAvailable
     * @param {Date | Object} startTime Denotes the start time of the slot.
     * @param {Date} endTime Denotes the end time of the slot.
     * @param {number} groupIndex Defines the resource index from last level.
     * @returns {boolean} Returns true, if the slot that lies in the provided time range does not contain any other events.
     */
    isSlotAvailable(startTime, endTime, groupIndex) {
        let eventStart;
        let eventEnd;
        let eventObj = this.activeEventData.event;
        if (startTime instanceof Date || typeof (startTime) === 'string') {
            eventStart = startTime;
            eventEnd = endTime;
        }
        else {
            eventObj = startTime;
            eventStart = startTime[this.eventFields.startTime];
            eventEnd = startTime[this.eventFields.endTime];
            if (this.resourceBase) {
                groupIndex = this.eventBase.getGroupIndexFromEvent(startTime);
            }
        }
        if (isNullOrUndefined(eventStart) || isNullOrUndefined(eventEnd)) {
            return true;
        }
        eventStart = this.getDateTime(eventStart);
        eventEnd = this.getDateTime(eventEnd);
        let eventCollection = this.eventBase.filterEvents(eventStart, eventEnd);
        if (!isNullOrUndefined(groupIndex) && this.resourceBase && this.resourceBase.lastResourceLevel.length > 0) {
            eventCollection =
                this.eventBase.filterEventsByResource(this.resourceBase.lastResourceLevel[parseInt(groupIndex.toString(), 10)], eventCollection);
        }
        if (eventObj) {
            if (eventObj.Guid) {
                eventCollection = eventCollection.filter((event) => event.Guid !== eventObj.Guid);
            }
            else {
                eventCollection = eventCollection.filter((event) => event[this.eventFields.id] !== eventObj[this.eventFields.id]);
            }
        }
        return (eventCollection.length > 0) ? false : true;
    }
    /**
     * To manually open the event editor on specific time or on certain events.
     *
     * @function openEditor
     * @param {Object} data It can be either cell data or event data.
     * @param {CurrentAction} action Defines the action for which the editor needs to be opened such as either for new event creation or
     *  for editing of existing events. The applicable action names that can be used here are `Add`, `Save`, `EditOccurrence`
     *  and `EditSeries`.
     * @param {boolean} isEventData It allows to decide whether the editor needs to be opened with the clicked cell details or with the
     *  passed event details.
     * @param {number} repeatType It opens the editor with the recurrence options based on the provided repeat type.
     * @returns {void}
     */
    openEditor(data, action, isEventData, repeatType) {
        if (action === 'Add' && !isEventData) {
            data.startTime = this.getDateTime(data.startTime);
            data.endTime = this.getDateTime(data.endTime);
            if (!isNullOrUndefined(data.element)) {
                data.element = getElement(data.element);
            }
        }
        else {
            data[this.eventFields.startTime] = this.getDateTime(data[this.eventFields.startTime]);
            data[this.eventFields.endTime] = this.getDateTime(data[this.eventFields.endTime]);
        }
        this.currentAction = action;
        if (action !== 'Add') {
            this.activeEventData.event = data;
        }
        this.eventWindow.openEditor(data, action, isEventData, repeatType);
    }
    /**
     * To manually close the event editor window
     *
     * @function closeEditor
     * @returns {void}
     */
    closeEditor() {
        if (this.eventWindow) {
            this.eventWindow.dialogClose();
        }
    }
    /**
     * To manually open the quick info popup based on cell or event details.
     *
     * @param {object} data Defines the cell or event data. If the data contains valid ID, it will open event quick info popup,
     * otherwise cell quick info popup displayed.
     * @returns {void}
     */
    openQuickInfoPopup(data) {
        if (this.currentView === 'Year' || isNullOrUndefined(data)) {
            return;
        }
        if (isNullOrUndefined(data[this.eventFields.id])) {
            if (this.currentView === 'Agenda' || this.currentView === 'MonthAgenda' || isNullOrUndefined(this.activeView)) {
                return;
            }
            const cellData = {
                startTime: this.activeCellsData.startTime = this.getDateTime(data[this.eventFields.startTime]),
                endTime: this.activeCellsData.endTime = this.getDateTime(data[this.eventFields.endTime]),
                isAllDay: this.activeCellsData.isAllDay =
                    !isNullOrUndefined(data[this.eventFields.isAllDay]) ? data[this.eventFields.isAllDay] : false
            };
            const startTime = this.activeView.getAdjustedDate(new Date(cellData.startTime));
            if (startTime) {
                let query = '.' + WORK_CELLS_CLASS + '[data-date="' + startTime.getTime() + '"]';
                if (this.activeViewOptions.group.resources.length > 0 && !this.uiStateValues.isGroupAdaptive
                    && this.resourceBase && this.eventBase) {
                    cellData.groupIndex = this.eventBase.getGroupIndexFromEvent(data);
                    query = '.' + WORK_CELLS_CLASS + '[data-date="' + startTime.getTime() + '"][data-group-index="' + cellData.groupIndex + '"]';
                }
                const workCell = this.element.querySelector(query);
                if (workCell) {
                    workCell.focus();
                    cellData.element = workCell;
                    this.notify(cellClick, cellData);
                }
            }
        }
        else {
            const app = this.getCurrentViewEvents().filter((item) => data[this.eventFields.id] === item[this.eventFields.id]);
            if (app.length <= 0) {
                return;
            }
            let selectEvent = app[0];
            if (data[this.eventFields.recurrenceRule]) {
                const occurence = app.filter((x) => x[this.eventFields.startTime].getTime() === data[this.eventFields.startTime].getTime());
                if (occurence.length > 0) {
                    selectEvent = occurence[0];
                }
            }
            const element = this.element.querySelector('div[data-guid="' + selectEvent.Guid + '"]');
            if (element) {
                this.eventBase.removeSelectedAppointmentClass();
                this.eventBase.addSelectedAppointments([element], false);
                this.activeEventData = { event: selectEvent, element: element };
                if (this.currentView === 'Agenda' || this.currentView === 'MonthAgenda') {
                    addClass([this.activeEventData.element], AGENDA_SELECTED_CELL);
                }
                this.notify(eventClick, this.activeEventData);
            }
        }
    }
    /**
     * To manually close the quick info popup
     *
     * @function closeQuickInfoPopup
     * @returns {void}
     */
    closeQuickInfoPopup() {
        if (this.quickPopup) {
            this.quickPopup.quickPopupHide(true);
        }
    }
    /**
     * Closes the tooltip.
     * For example, when the context menu is opened for an event,
     * the tooltip can be closed by calling this method.
     *
     * @function closeTooltip
     * @returns {void}
     */
    closeTooltip() {
        if (this.eventTooltip) {
            this.eventTooltip.close();
        }
    }
    /**
     * Select the resource based on group index in mobile mode.
     *
     * @param {number} groupIndex Defines the resource index based on last level.
     * @returns {void}
     */
    selectResourceByIndex(groupIndex) {
        if (this.resourceBase && this.uiStateValues.isGroupAdaptive) {
            this.resourceBase.selectResourceByIndex(groupIndex);
        }
    }
    /**
     * Select the resources to the based on id.
     *
     * @param {string | number} id id of the resource defined in resources collection.
     * @param {string} name Name of the resource defined in resources collection.
     * @returns {number} Returns the group index
     */
    getIndexFromResourceId(id, name) {
        if (this.resourceBase) {
            return this.resourceBase.getIndexFromResourceId(id, name);
        }
        return null;
    }
    /**
     * Adds the resources to the specified index.
     *
     * @param {Object | Object[]} resources Accepts the resource data in single or collection of data.
     * @param {string} name Name of the resource defined in resources collection.
     * @param {number} index Index or position where the resource should be added.
     * @returns {void}
     */
    addResource(resources, name, index) {
        this.resourceBase.addResource(resources, name, index);
    }
    /**
     * Removes the specified resource.
     *
     * @param {string | string[] | number | number[]} resourceId Specifies the resource id to be removed.
     * @param {string} name Specifies the resource name from which the id should be referred.
     * @returns {void}
     */
    removeResource(resourceId, name) {
        this.resourceBase.removeResource(resourceId, name);
    }
    /**
     * Destroys the Schedule component.
     *
     * @function destroy
     * @returns {void}
     */
    destroy() {
        if (this.eventTooltip) {
            this.eventTooltip.destroy();
            this.eventTooltip = null;
        }
        this.destroyPopups();
        this.hideSpinner();
        this.unWireEvents();
        this.destroyHeaderModule();
        if (this.eventBase) {
            this.eventBase.destroy();
            this.eventBase = null;
        }
        if (this.workCellAction) {
            this.workCellAction.destroy();
            this.workCellAction = null;
        }
        if (this.inlineModule) {
            this.inlineModule.destroy();
            this.inlineModule = null;
        }
        if (this.keyboardInteractionModule) {
            this.keyboardInteractionModule.destroy();
            this.keyboardInteractionModule = null;
        }
        if (this.scrollModule) {
            this.scrollModule.destroy();
            this.scrollModule = null;
        }
        if (this.printModule) {
            this.printModule.destroy();
        }
        if (this.activeView) {
            this.resetTemplates();
            this.activeView.removeEventListener();
            this.activeView.destroy();
            this.activeView = null;
        }
        if (this.scheduleTouchModule) {
            this.scheduleTouchModule.destroy();
            this.scheduleTouchModule = null;
        }
        if (this.crudModule) {
            this.crudModule.destroy();
            this.crudModule = null;
        }
        if (this.dataModule) {
            this.dataModule.destroy();
            this.dataModule = null;
        }
        super.destroy();
        const modules = [
            'dayModule', 'weekModule', 'workWeekModule', 'monthModule', 'monthAgendaModule', 'yearModule', 'agendaModule',
            'timelineViewsModule', 'timelineMonthModule', 'timelineYearModule', 'resizeModule', 'dragAndDropModule',
            'excelExportModule', 'printModule', 'iCalendarExportModule', 'iCalendarImportModule', 'tzModule', 'eventsData',
            'eventsProcessed', 'blockData', 'blockProcessed', 'uiStateValues', 'viewCollections', 'viewOptions', 'defaultLocale',
            'localeObj', 'selectedElements', 'resourceCollection', 'editorTitles', 'eventFields', 'activeViewOptions',
            'activeEventData', 'activeCellsData', 'renderModule'
        ];
        for (const module of modules) {
            this[`${module}`] = null;
        }
        removeChildren(this.element);
        let removeClasses = [ROOT, RTL, DEVICE_CLASS, MULTI_DRAG];
        if (this.cssClass) {
            removeClasses = removeClasses.concat(this.cssClass.split(' '));
        }
        removeClass([this.element], removeClasses);
    }
};
__decorate([
    Property('auto')
], Schedule.prototype, "width", void 0);
__decorate([
    Property('auto')
], Schedule.prototype, "height", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "showHeaderBar", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "showTimeIndicator", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "allowSwiping", void 0);
__decorate([
    Property('Week')
], Schedule.prototype, "currentView", void 0);
__decorate([
    Property(['Day', 'Week', 'WorkWeek', 'Month', 'Agenda'])
], Schedule.prototype, "views", void 0);
__decorate([
    Property(new Date())
], Schedule.prototype, "selectedDate", void 0);
__decorate([
    Property(new Date(1900, 0, 1))
], Schedule.prototype, "minDate", void 0);
__decorate([
    Property(new Date(2099, 11, 31))
], Schedule.prototype, "maxDate", void 0);
__decorate([
    Property()
], Schedule.prototype, "dateFormat", void 0);
__decorate([
    Property('Gregorian')
], Schedule.prototype, "calendarMode", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "showWeekend", void 0);
__decorate([
    Property(0)
], Schedule.prototype, "firstDayOfWeek", void 0);
__decorate([
    Property('FirstDay')
], Schedule.prototype, "weekRule", void 0);
__decorate([
    Property([1, 2, 3, 4, 5])
], Schedule.prototype, "workDays", void 0);
__decorate([
    Property(12)
], Schedule.prototype, "monthsCount", void 0);
__decorate([
    Property('00:00')
], Schedule.prototype, "startHour", void 0);
__decorate([
    Property('24:00')
], Schedule.prototype, "endHour", void 0);
__decorate([
    Property(null)
], Schedule.prototype, "timeFormat", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "enableHtmlSanitizer", void 0);
__decorate([
    Property(false)
], Schedule.prototype, "enableAllDayScroll", void 0);
__decorate([
    Property(false)
], Schedule.prototype, "enableAdaptiveUI", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "allowResizing", void 0);
__decorate([
    Complex({}, WorkHours)
], Schedule.prototype, "workHours", void 0);
__decorate([
    Complex({}, TimeScale)
], Schedule.prototype, "timeScale", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "allowKeyboardInteraction", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "allowDragAndDrop", void 0);
__decorate([
    Property()
], Schedule.prototype, "dateHeaderTemplate", void 0);
__decorate([
    Property()
], Schedule.prototype, "dateRangeTemplate", void 0);
__decorate([
    Property()
], Schedule.prototype, "cellHeaderTemplate", void 0);
__decorate([
    Property()
], Schedule.prototype, "dayHeaderTemplate", void 0);
__decorate([
    Property()
], Schedule.prototype, "monthHeaderTemplate", void 0);
__decorate([
    Property()
], Schedule.prototype, "cellTemplate", void 0);
__decorate([
    Property(false)
], Schedule.prototype, "readonly", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "showQuickInfo", void 0);
__decorate([
    Property(false)
], Schedule.prototype, "allowInline", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "allowMultiCellSelection", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "allowMultiRowSelection", void 0);
__decorate([
    Property(false)
], Schedule.prototype, "quickInfoOnSelectionEnd", void 0);
__decorate([
    Property(false)
], Schedule.prototype, "showWeekNumber", void 0);
__decorate([
    Property(false)
], Schedule.prototype, "rowAutoHeight", void 0);
__decorate([
    Property(false)
], Schedule.prototype, "allowMultiDrag", void 0);
__decorate([
    Property(0)
], Schedule.prototype, "firstMonthOfYear", void 0);
__decorate([
    Property()
], Schedule.prototype, "editorTemplate", void 0);
__decorate([
    Complex({}, QuickInfoTemplates)
], Schedule.prototype, "quickInfoTemplates", void 0);
__decorate([
    Property(7)
], Schedule.prototype, "agendaDaysCount", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "hideEmptyAgendaDays", void 0);
__decorate([
    Property(true)
], Schedule.prototype, "enableRecurrenceValidation", void 0);
__decorate([
    Property()
], Schedule.prototype, "timezone", void 0);
__decorate([
    Complex({}, EventSettings)
], Schedule.prototype, "eventSettings", void 0);
__decorate([
    Property(timezoneData)
], Schedule.prototype, "timezoneDataSource", void 0);
__decorate([
    Property()
], Schedule.prototype, "resourceHeaderTemplate", void 0);
__decorate([
    Property()
], Schedule.prototype, "headerIndentTemplate", void 0);
__decorate([
    Complex({}, Group)
], Schedule.prototype, "group", void 0);
__decorate([
    Collection([], Resources)
], Schedule.prototype, "resources", void 0);
__decorate([
    Collection([], HeaderRows)
], Schedule.prototype, "headerRows", void 0);
__decorate([
    Property()
], Schedule.prototype, "cssClass", void 0);
__decorate([
    Property()
], Schedule.prototype, "eventDragArea", void 0);
__decorate([
    Event()
], Schedule.prototype, "created", void 0);
__decorate([
    Event()
], Schedule.prototype, "destroyed", void 0);
__decorate([
    Event()
], Schedule.prototype, "cellClick", void 0);
__decorate([
    Event()
], Schedule.prototype, "cellDoubleClick", void 0);
__decorate([
    Event()
], Schedule.prototype, "moreEventsClick", void 0);
__decorate([
    Event()
], Schedule.prototype, "hover", void 0);
__decorate([
    Event()
], Schedule.prototype, "select", void 0);
__decorate([
    Event()
], Schedule.prototype, "actionBegin", void 0);
__decorate([
    Event()
], Schedule.prototype, "actionComplete", void 0);
__decorate([
    Event()
], Schedule.prototype, "actionFailure", void 0);
__decorate([
    Event()
], Schedule.prototype, "navigating", void 0);
__decorate([
    Event()
], Schedule.prototype, "renderCell", void 0);
__decorate([
    Event()
], Schedule.prototype, "eventClick", void 0);
__decorate([
    Event()
], Schedule.prototype, "eventRendered", void 0);
__decorate([
    Event()
], Schedule.prototype, "dataBinding", void 0);
__decorate([
    Event()
], Schedule.prototype, "popupOpen", void 0);
__decorate([
    Event()
], Schedule.prototype, "popupClose", void 0);
__decorate([
    Event()
], Schedule.prototype, "dragStart", void 0);
__decorate([
    Event()
], Schedule.prototype, "drag", void 0);
__decorate([
    Event()
], Schedule.prototype, "dragStop", void 0);
__decorate([
    Event()
], Schedule.prototype, "resizeStart", void 0);
__decorate([
    Event()
], Schedule.prototype, "resizing", void 0);
__decorate([
    Event()
], Schedule.prototype, "resizeStop", void 0);
__decorate([
    Event()
], Schedule.prototype, "dataBound", void 0);
Schedule = __decorate([
    NotifyPropertyChanges
], Schedule);

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Base class for the common drag and resize related actions
 */
class ActionBase {
    constructor(parent) {
        this.daysVariation = 0;
        this.parent = parent;
        this.actionObj = {
            X: 0, Y: 0, groupIndex: 0, cellWidth: 0, cellHeight: 0, slotInterval: 0, interval: 0, actionIndex: 0,
            cloneElement: [], originalElement: [], action: null, isAllDay: null, excludeSelectors: null,
            index: 0, navigationInterval: null, scrollInterval: null
        };
        this.scrollArgs = { element: null, width: 0, height: 0 };
        this.resizeEdges = { left: false, right: false, top: false, bottom: false };
        this.scrollEdges = { left: false, right: false, top: false, bottom: false };
    }
    getChangedData(multiData) {
        const eventObj = extend({}, this.actionObj.event, null, true);
        eventObj[this.parent.eventFields.startTime] = this.actionObj.start;
        eventObj[this.parent.eventFields.endTime] = this.actionObj.end;
        if (!isNullOrUndefined(this.actionObj.isAllDay)) {
            eventObj[this.parent.eventFields.isAllDay] = this.actionObj.isAllDay;
        }
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            const originalElement = this.getOriginalElement(this.actionObj.element);
            if (originalElement) {
                let indexCol = originalElement.map((element) => parseInt(element.getAttribute('data-group-index'), 10));
                if (indexCol.indexOf(this.actionObj.groupIndex) === -1 || (!isNullOrUndefined(multiData) && multiData.length > 0)) {
                    const cloneIndex = parseInt(this.actionObj.clone.getAttribute('data-group-index'), 10);
                    indexCol = indexCol.filter((index) => index !== cloneIndex);
                    indexCol.push(this.actionObj.groupIndex);
                    if (multiData && multiData.length > 0) {
                        multiData.forEach((data) => {
                            this.parent.resourceBase.getResourceData(data, this.actionObj.groupIndex, indexCol);
                        });
                    }
                    else {
                        this.parent.resourceBase.getResourceData(eventObj, this.actionObj.groupIndex, indexCol);
                    }
                }
            }
        }
        return eventObj;
    }
    saveChangedData(eventArgs, isMultiSelect = false) {
        this.parent.activeEventData.event = this.actionObj.event;
        this.parent.currentAction = 'Save';
        let currentAction;
        let eventsCollection = [eventArgs.data];
        if (isMultiSelect) {
            eventsCollection = eventArgs.selectedData;
        }
        for (const eventObj of eventsCollection) {
            const isSameResource = (this.parent.activeViewOptions.group.resources.length > 0) ?
                parseInt(this.actionObj.element.getAttribute('data-group-index'), 10) === this.actionObj.groupIndex : true;
            if (+eventObj[this.parent.eventFields.startTime] === +this.actionObj.event[this.parent.eventFields.startTime] &&
                +eventObj[this.parent.eventFields.endTime] === +this.actionObj.event[this.parent.eventFields.endTime] && isSameResource) {
                this.parent.crudModule.crudObj.isCrudAction = false;
                return;
            }
            if (eventObj[this.parent.eventFields.recurrenceRule]) {
                const eveId = (eventObj[this.parent.eventFields.recurrenceID] || eventObj[this.parent.eventFields.id]);
                if (eventObj[this.parent.eventFields.id] === eventObj[this.parent.eventFields.recurrenceID]) {
                    eventObj[this.parent.eventFields.id] = this.parent.eventBase.getEventMaxID();
                    currentAction = 'EditOccurrence';
                }
                if (this.parent.enableRecurrenceValidation
                    && this.parent.eventWindow.editOccurrenceValidation(eveId, eventObj, this.actionObj.event)) {
                    return;
                }
            }
            else {
                currentAction = null;
            }
            if (eventObj[this.parent.eventFields.startTimezone] || eventObj[this.parent.eventFields.endTimezone]) {
                this.parent.eventBase.timezoneConvert(eventObj);
            }
            this.parent.crudModule.saveEvent(eventObj, currentAction);
        }
    }
    calculateIntervalTime(date) {
        const intervalTime = new Date(+date);
        intervalTime.setMinutes(Math.floor(intervalTime.getMinutes() / this.actionObj.interval) * this.actionObj.interval);
        return intervalTime;
    }
    getContentAreaDimension() {
        const viewElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        let trElement = [].slice.call(viewElement.querySelector('tr').children);
        if (!this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0 &&
            !this.parent.isAdaptive && !this.parent.enableAdaptiveUI && !this.parent.virtualScrollModule) {
            trElement = this.getResourceElements(trElement);
        }
        const leftOffset = trElement[0].getBoundingClientRect();
        const rightOffset = trElement.slice(-1)[0].getBoundingClientRect();
        const viewDimension = {
            bottom: viewElement.scrollHeight - 5,
            left: this.parent.enableRtl ? rightOffset.left : leftOffset.left,
            right: this.parent.enableRtl ? leftOffset.right : rightOffset.right,
            top: 0,
            leftOffset: this.parent.enableRtl ? rightOffset.right : leftOffset.right,
            rightOffset: this.parent.enableRtl ? leftOffset.left : rightOffset.left
        };
        return viewDimension;
    }
    getIndex(index) {
        const contentElements = [].slice.call(this.parent.getContentTable().querySelector('tr').children);
        const indexes = { minIndex: 0, maxIndex: contentElements.length - 1 };
        if (this.actionObj.action === 'resize' && this.parent.activeViewOptions.group.resources.length > 0 &&
            !this.parent.uiStateValues.isGroupAdaptive && !this.parent.activeView.isTimelineView()) {
            const groupElements = this.getResourceElements(contentElements);
            indexes.minIndex = groupElements[0].cellIndex;
            indexes.maxIndex = groupElements.slice(-1)[0].cellIndex;
        }
        if (index < indexes.minIndex) {
            index = indexes.minIndex;
        }
        if (index > indexes.maxIndex) {
            index = indexes.maxIndex;
        }
        return index;
    }
    updateTimePosition(date, multiData) {
        let index = 0;
        for (const cloneElement of this.actionObj.cloneElement) {
            const timeElement = cloneElement.querySelector('.' + APPOINTMENT_TIME);
            if (timeElement) {
                let startTime = this.actionObj.start;
                let endTime = this.actionObj.end;
                if (multiData && multiData.length > 0) {
                    startTime = multiData[parseInt(index.toString(), 10)][this.parent.eventFields.startTime];
                    endTime = multiData[parseInt(index.toString(), 10)][this.parent.eventFields.endTime];
                }
                timeElement.innerHTML = this.parent.getTimeString(startTime) + ' - ' +
                    this.parent.getTimeString(endTime);
            }
            index++;
        }
        if (!this.parent.activeViewOptions.timeScale.enable || !this.parent.isAdaptive || this.parent.currentView === 'Month' ||
            this.parent.currentView === 'TimelineMonth') {
            return;
        }
        let timeIndicator = this.parent.element.querySelector('.' + CLONE_TIME_INDICATOR_CLASS);
        if (!timeIndicator) {
            timeIndicator = createElement('div', { className: CLONE_TIME_INDICATOR_CLASS });
            const wrapperClass = this.parent.activeView.isTimelineView() ? DATE_HEADER_WRAP_CLASS : TIME_CELLS_WRAP_CLASS;
            this.parent.element.querySelector('.' + wrapperClass).appendChild(timeIndicator);
        }
        timeIndicator.innerHTML = this.parent.getTimeString(date);
        let offsetValue = 0;
        if (this.parent.activeView.isTimelineView()) {
            if (this.parent.enableRtl) {
                const rightValue = parseInt(this.actionObj.clone.style.right, 10);
                offsetValue = this.actionObj.action === 'drag' || this.resizeEdges.left ?
                    rightValue + this.actionObj.clone.offsetWidth : rightValue;
                timeIndicator.style.right = formatUnit(offsetValue);
            }
            else {
                const leftValue = parseInt(this.actionObj.clone.style.left, 10);
                offsetValue = this.actionObj.action === 'drag' || this.resizeEdges.left ?
                    leftValue : leftValue + this.actionObj.clone.offsetWidth;
                timeIndicator.style.left = formatUnit(offsetValue);
            }
        }
        else {
            offsetValue = this.actionObj.action === 'drag' || this.resizeEdges.top ? this.actionObj.clone.offsetTop :
                this.actionObj.clone.offsetTop + this.actionObj.clone.offsetHeight;
            timeIndicator.style.top = formatUnit(offsetValue);
        }
    }
    getResourceElements(table) {
        return table.filter((element) => parseInt(element.getAttribute('data-group-index'), 10) === this.actionObj.groupIndex);
    }
    getOriginalElement(element) {
        let originalElement;
        const guid = element.getAttribute('data-guid');
        const isMorePopup = element.offsetParent && element.offsetParent.classList.contains(MORE_EVENT_POPUP_CLASS);
        if (isMorePopup || this.parent.activeView.isTimelineView() || (this.actionObj.action !== 'resize' && this.parent.virtualScrollModule)) {
            originalElement = [].slice.call(this.parent.element.querySelectorAll('[data-guid="' + guid + '"]'));
        }
        else {
            const tr = closest(element, 'tr');
            if (tr) {
                originalElement = [].slice.call(tr.querySelectorAll('[data-guid="' + guid + '"]'));
            }
        }
        return originalElement;
    }
    createCloneElement(element) {
        const cloneWrapper = createElement('div', { innerHTML: element.outerHTML });
        const cloneElement = cloneWrapper.children[0];
        const cloneClassLists = [CLONE_ELEMENT_CLASS];
        cloneClassLists.push((this.actionObj.action === 'drag') ? DRAG_CLONE_CLASS : RESIZE_CLONE_CLASS);
        if (this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineMonth') {
            cloneClassLists.push(MONTH_CLONE_ELEMENT_CLASS);
        }
        addClass([cloneElement], cloneClassLists);
        addClass([element], EVENT_ACTION_CLASS);
        if (!isNullOrUndefined(element.parentElement)) {
            element.parentElement.appendChild(cloneElement);
        }
        cloneElement.style.width = formatUnit(cloneElement.offsetWidth - 2);
        const dragElement = document.querySelector(this.parent.eventDragArea);
        if (this.parent.eventDragArea && this.actionObj.action === 'drag' && dragElement) {
            dragElement.appendChild(cloneElement);
        }
        setStyleAttribute(cloneElement, { border: '0px' });
        return cloneElement;
    }
    removeCloneElementClasses() {
        let elements = this.actionObj.originalElement;
        if (this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineYear' ||
            this.parent.currentView === 'Day' || this.parent.currentView === 'Week' || this.parent.currentView === 'WorkWeek') {
            elements = [].slice.call(this.parent.element.querySelectorAll('.' + EVENT_ACTION_CLASS));
        }
        removeClass(elements, EVENT_ACTION_CLASS);
    }
    removeCloneElement() {
        this.actionObj.originalElement = [];
        const dynamicEle = [].slice.call(this.parent.element.querySelectorAll('.e-dynamic-clone'));
        for (const cloneEle of dynamicEle) {
            remove(cloneEle);
        }
        for (const cloneElement of this.actionObj.cloneElement) {
            if (!isNullOrUndefined(cloneElement.parentNode)) {
                remove(cloneElement);
            }
        }
        this.actionObj.cloneElement = [];
        const timeIndicator = this.parent.element.querySelector('.' + CLONE_TIME_INDICATOR_CLASS);
        if (timeIndicator) {
            remove(timeIndicator);
        }
    }
    getCursorElement(e) {
        const pages = this.parent.eventBase.getPageCoordinates(e);
        return document.elementFromPoint(pages.clientX, pages.clientY);
    }
    autoScroll() {
        const parent = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        const yIsScrollable = parent.offsetHeight <= parent.scrollHeight;
        const xIsScrollable = parent.offsetWidth <= parent.scrollWidth;
        const yInBounds = yIsScrollable && parent.scrollTop >= 0 && parent.scrollTop + parent.offsetHeight <= parent.scrollHeight;
        let xInBounds = xIsScrollable && parent.scrollLeft >= 0 && parent.scrollLeft + parent.offsetWidth <= parent.scrollWidth;
        if (this.actionObj.action === 'resize' && this.scrollEdges.right && (parent.scrollLeft + parent.offsetWidth) > parent.scrollWidth) {
            const tdCollections = ([].slice.call(this.parent.getContentTable().querySelector('tr').children)).length - 1;
            const cellIndex = Math.ceil((this.actionObj.clone.offsetLeft + (this.actionObj.clone.offsetWidth)) /
                this.actionObj.cellWidth);
            xInBounds = cellIndex === tdCollections;
        }
        if (yInBounds && (this.scrollEdges.top || this.scrollEdges.bottom)) {
            parent.scrollTop += this.scrollEdges.top ? -this.actionObj.scroll.scrollBy : this.actionObj.scroll.scrollBy;
            if (this.actionObj.action === 'resize') {
                if (parent.scrollHeight !== parent.offsetHeight + parent.scrollTop && parent.scrollTop > 0) {
                    this.actionObj.Y += this.scrollEdges.top ? this.actionObj.scroll.scrollBy : -this.actionObj.scroll.scrollBy;
                }
            }
        }
        if (xInBounds && (this.scrollEdges.left || this.scrollEdges.right)) {
            parent.scrollLeft += this.scrollEdges.left ? -this.actionObj.scroll.scrollBy : this.actionObj.scroll.scrollBy;
            if (this.actionObj.action === 'resize') {
                if (parent.scrollWidth !== parent.offsetWidth + parent.scrollLeft && parent.scrollLeft > 0) {
                    this.actionObj.X += this.scrollEdges.left ? this.actionObj.scroll.scrollBy : -this.actionObj.scroll.scrollBy;
                }
            }
        }
    }
    autoScrollValidation() {
        if (!this.actionObj.scroll.enable) {
            return false;
        }
        const res = this.parent.boundaryValidation(this.actionObj.pageY, this.actionObj.pageX);
        this.scrollEdges = res;
        return res.bottom || res.top || res.left || res.right;
    }
    actionClass(type) {
        if (type === 'addClass') {
            addClass([this.parent.element], EVENT_ACTION_CLASS);
        }
        else {
            removeClass([this.parent.element], EVENT_ACTION_CLASS);
        }
    }
    updateScrollPosition(e) {
        this.scrollEventArgs = e;
        if (this.actionObj.scroll.enable && isNullOrUndefined(this.actionObj.scrollInterval)) {
            this.actionObj.scrollInterval = window.setInterval(() => {
                if (this.autoScrollValidation() && !this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {
                    if (this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.group.resources.length > 0
                        && this.actionObj.groupIndex < 0) {
                        return;
                    }
                    this.autoScroll();
                    if (this.actionObj.action === 'drag') {
                        this.parent.dragAndDropModule.updateDraggingDateTime(this.scrollEventArgs);
                    }
                    else {
                        this.parent.resizeModule.updateResizingDirection(this.scrollEventArgs);
                    }
                }
            }, this.actionObj.scroll.timeDelay);
        }
    }
    updateOriginalElement(cloneElement) {
        let query = '[data-id="' + cloneElement.getAttribute('data-id') + '"]';
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            query = query.concat('[data-group-index = "' + cloneElement.getAttribute('data-group-index') + '"]');
        }
        const elements = [].slice.call(this.parent.element.querySelectorAll(query));
        addClass(elements, EVENT_ACTION_CLASS);
        const eventWrappers = [].slice.call(this.parent.element.querySelectorAll('.' + CLONE_ELEMENT_CLASS));
        removeClass(eventWrappers, EVENT_ACTION_CLASS);
    }
    getUpdatedEvent(startTime, endTime, eventObj) {
        const event = JSON.parse(JSON.stringify(eventObj));
        event[this.parent.eventFields.startTime] = startTime;
        event[this.parent.eventFields.endTime] = endTime;
        return event;
    }
    dynamicYearlyEventsRendering(event, isResize = false) {
        let appWidth = this.actionObj.cellWidth - 7;
        if (isResize && (this.resizeEdges.left || this.resizeEdges.right)) {
            appWidth = this.actionObj.cellWidth * event.count;
        }
        if (!isResize && (this.parent.activeViewOptions.orientation === 'Horizontal' && this.parent.activeViewOptions.group.resources.length === 0)) {
            const eventObj = this.yearEvent.isSpannedEvent(event, event[this.parent.eventFields.startTime]);
            if (eventObj[this.parent.eventFields.startTime].getTime() ===
                eventObj[this.parent.eventFields.endTime].getTime()) {
                eventObj.isSpanned.count = 1;
            }
            appWidth = eventObj.isSpanned.count * this.actionObj.cellWidth;
        }
        if (!isResize && this.parent.activeViewOptions.orientation === 'Vertical' && this.parent.activeViewOptions.group.resources.length !== 0) {
            const eventObj = this.yearEvent.isSpannedEvent(event, event[this.parent.eventFields.startTime]);
            appWidth = eventObj.isSpanned.count * this.actionObj.cellWidth;
        }
        const appointmentElement = this.createAppointmentElement(this.actionObj.groupIndex, event[this.parent.eventFields.subject]);
        appointmentElement.setAttribute('drag', 'true');
        addClass([appointmentElement], CLONE_ELEMENT_CLASS);
        setStyleAttribute(appointmentElement, {
            'width': appWidth + 'px', 'border': '0px', 'pointer-events': 'none',
            'position': 'absolute', 'overflow': 'hidden', 'padding': '3px'
        });
        if (this.actionObj.clone.style.backgroundColor !== '') {
            setStyleAttribute(appointmentElement, { 'backgroundColor': this.actionObj.clone.style.backgroundColor });
        }
        const date = resetTime(event[this.parent.eventFields.startTime]).getTime();
        let query = '.' + WORK_CELLS_CLASS + '[data-date="' + date + '"]';
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            query = '.' + WORK_CELLS_CLASS + '[data-date="' + date + '"][data-group-index="' + this.actionObj.groupIndex + '"]';
        }
        const cellTd = this.parent.element.querySelector(query);
        if (isNullOrUndefined(cellTd)) {
            return;
        }
        if (isResize) {
            const dateHeader = cellTd.querySelector('.' + DATE_HEADER_CLASS);
            let appHeight = this.actionObj.cellHeight * event.count -
                (dateHeader ? dateHeader.offsetHeight : 0) - 7;
            if (this.resizeEdges.right || this.resizeEdges.left) {
                appHeight = parseInt(this.actionObj.clone.style.height, 10);
            }
            setStyleAttribute(appointmentElement, { 'height': appHeight + 'px' });
        }
        this.renderDynamicElement(cellTd, appointmentElement, true);
        this.actionObj.cloneElement.push(appointmentElement);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    renderDynamicElement(cellTd, element, isAppointment = false) {
        if (cellTd.querySelector('.' + APPOINTMENT_WRAPPER_CLASS)) {
            cellTd.querySelector('.' + APPOINTMENT_WRAPPER_CLASS).appendChild(element);
        }
        else {
            const wrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
            wrapper.appendChild(element);
            cellTd.appendChild(wrapper);
        }
    }
    createAppointmentElement(resIndex, innerText) {
        const appointmentWrapper = createElement('div', {
            className: APPOINTMENT_CLASS,
            innerHTML: innerText
        });
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            appointmentWrapper.setAttribute('data-group-index', resIndex.toString());
        }
        return appointmentWrapper;
    }
    dynamicEventsRendering(event) {
        let dateRender = this.parent.activeView.renderDates;
        let workCells = [].slice.call(this.parent.element.querySelectorAll('.' + WORK_CELLS_CLASS));
        let workDays = this.parent.activeViewOptions.workDays;
        let groupOrder;
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            const renderedResource = this.parent.virtualScrollModule && this.parent.virtualScrollModule.isHorizontalScroll ?
                this.parent.resourceBase.renderedResources : this.parent.resourceBase.lastResourceLevel;
            const resources = renderedResource.
                filter((res) => res.groupIndex === this.actionObj.groupIndex);
            dateRender = resources[0].renderDates;
            const elementSelector = `.${WORK_CELLS_CLASS}[data-group-index="${this.actionObj.groupIndex}"]`;
            workCells = [].slice.call(this.parent.element.querySelectorAll(elementSelector));
            workDays = resources[0].workDays;
            groupOrder = resources[0].groupOrder;
        }
        this.monthEvent.dateRender = dateRender;
        this.monthEvent.getSlotDates(workDays);
        if (this.resizeEdges.left || this.resizeEdges.right) {
            const eventWrappers = [].slice.call(this.parent.element.querySelectorAll('.' + CLONE_ELEMENT_CLASS));
            for (const wrapper of eventWrappers) {
                remove(wrapper);
            }
        }
        const spannedEvents = this.monthEvent.splitEvent(event, dateRender);
        for (const event of spannedEvents) {
            const day = this.parent.getIndexOfDate(dateRender, resetTime(event[this.monthEvent.fields.startTime]));
            const diffInDays = event.data.count;
            const appWidth = (diffInDays * this.actionObj.cellWidth) - 7;
            const appointmentElement = this.monthEvent.createAppointmentElement(event, this.actionObj.groupIndex, true);
            appointmentElement.setAttribute('drag', 'true');
            addClass([appointmentElement], CLONE_ELEMENT_CLASS);
            this.monthEvent.applyResourceColor(appointmentElement, event, 'backgroundColor', groupOrder);
            setStyleAttribute(appointmentElement, { 'width': appWidth + 'px', 'border': '0px', 'pointer-events': 'none' });
            const cellTd = workCells[parseInt(day.toString(), 10)];
            if (cellTd && isNullOrUndefined(this.parent.eventDragArea)) {
                this.monthEvent.renderElement(cellTd, appointmentElement, true);
                this.actionObj.cloneElement.push(appointmentElement);
            }
        }
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.actionObj = {};
        this.scrollArgs = {};
        this.resizeEdges = { left: false, right: false, top: false, bottom: false };
        this.scrollEdges = { left: false, right: false, top: false, bottom: false };
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Schedule events resize actions
 */
class Resize extends ActionBase {
    wireResizeEvent(element) {
        const resizeElement = [].slice.call(element.querySelectorAll('.' + EVENT_RESIZE_CLASS));
        for (const element of resizeElement) {
            EventHandler.add(element, Browser.touchStartEvent, this.resizeStart, this);
        }
    }
    resizeHelper() {
        if (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.activeViewOptions.group.allowGroupEdit) {
            for (let i = 0, len = this.actionObj.originalElement.length; i < len; i++) {
                const cloneElement = this.createCloneElement(this.actionObj.originalElement[parseInt(i.toString(), 10)]);
                this.actionObj.cloneElement[parseInt(i.toString(), 10)] = cloneElement;
                if (this.actionObj.element === this.actionObj.originalElement[parseInt(i.toString(), 10)]) {
                    this.actionObj.clone = cloneElement;
                }
            }
        }
        else {
            if (this.actionObj.element) {
                this.actionObj.clone = this.createCloneElement(this.actionObj.element);
            }
            this.actionObj.cloneElement = [this.actionObj.clone];
            this.actionObj.originalElement = [this.actionObj.element];
        }
    }
    resizeStart(e) {
        this.actionObj.action = 'resize';
        this.actionObj.slotInterval = this.parent.activeViewOptions.timeScale.interval / this.parent.activeViewOptions.timeScale.slotCount;
        this.actionObj.interval = this.actionObj.slotInterval;
        const resizeTarget = closest(e.target, '.' + EVENT_RESIZE_CLASS);
        this.actionObj.element = closest(resizeTarget, '.' + APPOINTMENT_CLASS);
        this.actionObj.event = this.parent.eventBase.getEventByGuid(this.actionObj.element.getAttribute('data-guid'));
        const eventObj = extend({}, this.actionObj.event, null, true);
        const resizeArgs = {
            cancel: false,
            data: eventObj,
            element: this.actionObj.element,
            event: e,
            interval: this.actionObj.interval,
            scroll: { enable: true, scrollBy: 30, timeDelay: 100 }
        };
        this.parent.trigger(resizeStart, resizeArgs, (resizeEventArgs) => {
            if (resizeEventArgs.cancel) {
                return;
            }
            this.actionClass('addClass');
            this.parent.uiStateValues.action = true;
            this.resizeEdges = {
                left: resizeTarget.classList.contains(LEFT_RESIZE_HANDLER),
                right: resizeTarget.classList.contains(RIGHT_RESIZE_HANDLER),
                top: resizeTarget.classList.contains(TOP_RESIZE_HANDLER),
                bottom: resizeTarget.classList.contains(BOTTOM_RESIZE_HANDLER)
            };
            this.actionObj.groupIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex : 0;
            const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS).getBoundingClientRect();
            this.actionObj.cellWidth = workCell.width;
            this.actionObj.cellHeight = workCell.height;
            const hRows = this.parent.activeViewOptions.headerRows.map((row) => row.option);
            if (this.parent.activeView.isTimelineView() && hRows.length > 0 && ['Date', 'Hour'].indexOf(hRows.slice(-1)[0]) < 0) {
                const tr = this.parent.getContentTable().querySelector('tr');
                let noOfDays = 0;
                const tdCollections = [].slice.call(tr.children);
                for (const td of tdCollections) {
                    noOfDays += parseInt(td.getAttribute('colspan'), 10);
                }
                const trRect = tr.getBoundingClientRect();
                this.actionObj.cellWidth = trRect.width / noOfDays;
                this.actionObj.cellHeight = trRect.height;
            }
            const pages = this.parent.eventBase.getPageCoordinates(e);
            this.actionObj.X = pages.pageX;
            this.actionObj.Y = pages.pageY;
            this.actionObj.groupIndex = parseInt(this.actionObj.element.getAttribute('data-group-index') || '0', 10);
            this.actionObj.interval = resizeEventArgs.interval;
            this.actionObj.scroll = resizeEventArgs.scroll;
            this.actionObj.start = new Date(eventObj[this.parent.eventFields.startTime].getTime());
            this.actionObj.end = new Date(eventObj[this.parent.eventFields.endTime].getTime());
            this.actionObj.originalElement = this.getOriginalElement(this.actionObj.element);
            if (this.parent.currentView === 'Month') {
                this.daysVariation = -1;
                this.monthEvent = new MonthEvent(this.parent);
            }
            const viewElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
            this.scrollArgs = { element: viewElement, width: viewElement.scrollWidth, height: viewElement.scrollHeight };
            EventHandler.add(document, Browser.touchMoveEvent, this.resizing, this);
            EventHandler.add(document, Browser.touchEndEvent, this.resizeStop, this);
        });
    }
    resizing(e) {
        if (this.parent.quickPopup) {
            this.parent.quickPopup.quickPopupHide();
        }
        if (this.parent.element.querySelectorAll('.' + RESIZE_CLONE_CLASS).length === 0) {
            this.resizeHelper();
        }
        if ((!isNullOrUndefined(e.target)) && e.target.classList.contains(DISABLE_DATES)) {
            return;
        }
        const pages = this.parent.eventBase.getPageCoordinates(e);
        if (this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineYear') {
            const doc = document.documentElement;
            const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
            const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
            this.actionObj.pageX = pages.pageX - left;
            this.actionObj.pageY = pages.pageY - top;
        }
        else {
            this.actionObj.pageX = pages.pageX;
            this.actionObj.pageY = pages.pageY;
        }
        this.updateScrollPosition(e);
        this.updateResizingDirection(e);
        const eventObj = extend({}, this.actionObj.event, null, true);
        const resizeArgs = {
            cancel: false,
            data: eventObj,
            element: this.actionObj.element,
            event: e,
            startTime: this.actionObj.start,
            endTime: this.actionObj.end
        };
        if (this.parent.group.resources.length > 0) {
            resizeArgs.groupIndex = this.actionObj.groupIndex;
        }
        this.parent.trigger(resizing, resizeArgs);
    }
    updateResizingDirection(e) {
        if (this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineYear') {
            this.monthResizing();
            return;
        }
        const resizeValidation = this.resizeValidation(e);
        if (this.resizeEdges.left) {
            if (resizeValidation) {
                const leftStyles = this.getLeftRightStyles(e, true);
                if (parseInt(leftStyles.width, 10) < 1) {
                    return;
                }
                for (const cloneElement of this.actionObj.cloneElement) {
                    setStyleAttribute(cloneElement, leftStyles);
                    addClass([cloneElement], LEFT_RESIZE_HANDLER);
                }
            }
            this.horizontalResizing(!this.parent.enableRtl);
        }
        if (this.resizeEdges.right) {
            if (resizeValidation) {
                const rightStyles = this.getLeftRightStyles(e, false);
                if (parseInt(rightStyles.width, 10) < 1) {
                    return;
                }
                for (const cloneElement of this.actionObj.cloneElement) {
                    setStyleAttribute(cloneElement, rightStyles);
                    addClass([cloneElement], RIGHT_RESIZE_HANDLER);
                }
            }
            this.horizontalResizing(this.parent.enableRtl);
        }
        if (this.resizeEdges.top) {
            if (resizeValidation) {
                const topStyles = this.getTopBottomStyles(e, true);
                if (parseInt(topStyles.height, 10) < 1) {
                    return;
                }
                for (const cloneElement of this.actionObj.cloneElement) {
                    setStyleAttribute(cloneElement, topStyles);
                    addClass([cloneElement], TOP_RESIZE_HANDLER);
                }
            }
            this.verticalResizing(true);
        }
        if (this.resizeEdges.bottom) {
            if (resizeValidation) {
                const bottomStyles = this.getTopBottomStyles(e, false);
                if (parseInt(bottomStyles.height, 10) < 1) {
                    return;
                }
                for (const cloneElement of this.actionObj.cloneElement) {
                    setStyleAttribute(cloneElement, bottomStyles);
                    addClass([cloneElement], BOTTOM_RESIZE_HANDLER);
                }
            }
            this.verticalResizing(false);
        }
    }
    monthResizing() {
        this.removeCloneElement();
        if (isNullOrUndefined(this.actionObj.pageX) || isNullOrUndefined(this.actionObj.pageY)) {
            return;
        }
        const td = document.elementFromPoint(this.actionObj.pageX, this.actionObj.pageY);
        if (isNullOrUndefined(td)) {
            return;
        }
        const resizeTime = this.parent.getDateFromElement(td);
        const isSameCell = this.parent.activeViewOptions.group.resources.length > 0 ?
            parseInt(td.getAttribute('data-group-index'), 10) === this.actionObj.groupIndex : true;
        let startTime = new Date(this.actionObj.event[this.parent.eventFields.startTime].getTime());
        let endTime = new Date(this.actionObj.event[this.parent.eventFields.endTime].getTime());
        if ((!this.parent.enableRtl && this.resizeEdges.left) || (this.parent.enableRtl && this.resizeEdges.right)
            || this.resizeEdges.top) {
            startTime = resizeTime;
        }
        else if ((!this.parent.enableRtl && this.resizeEdges.right) || (this.parent.enableRtl && this.resizeEdges.left)
            || this.resizeEdges.bottom) {
            endTime = addDays(resizeTime, 1);
        }
        if (isSameCell && startTime < endTime) {
            this.actionObj.start = startTime;
            this.actionObj.end = endTime;
            const event = this.getUpdatedEvent(this.actionObj.start, this.actionObj.end, this.actionObj.event);
            if (this.parent.currentView === 'TimelineYear') {
                this.yearEventsRendering(event);
            }
            else {
                this.dynamicEventsRendering(event);
            }
            this.updateOriginalElement(this.actionObj.clone);
        }
    }
    yearEventsRendering(event) {
        const eventWrappers = [].slice.call(this.parent.element.querySelectorAll('.' + CLONE_ELEMENT_CLASS));
        for (const wrapper of eventWrappers) {
            remove(wrapper);
        }
        let endDate = new Date(event[this.parent.eventFields.endTime]);
        let monthDiff = 0;
        if (this.parent.activeViewOptions.group.resources.length === 0) {
            monthDiff = this.getMonthDiff(event[this.parent.eventFields.startTime], addDays(endDate, -1));
        }
        for (let i = 0; i <= monthDiff; i++) {
            let eventObj;
            if (this.parent.activeViewOptions.group.resources.length === 0) {
                eventObj = this.getEventCount(event, this.actionObj.start.getMonth() + i);
            }
            else {
                eventObj = extend({}, event, null, true);
                endDate = this.resizeEdges.left || this.resizeEdges.right ? addDays(endDate, -1) : endDate;
                eventObj.count = this.getMonthDiff(event[this.parent.eventFields.startTime], endDate) + 1;
            }
            this.dynamicYearlyEventsRendering(eventObj, true);
        }
    }
    getMonthDiff(startDate, endDate) {
        let months;
        months = (endDate.getFullYear() - startDate.getFullYear()) * 12;
        months -= startDate.getMonth();
        months += endDate.getMonth();
        return months <= 0 ? 0 : months;
    }
    getEventCount(eventObj, month) {
        const eventData = extend({}, eventObj, null, true);
        const eventStart = eventData[this.parent.eventFields.startTime];
        const eventEnd = eventData[this.parent.eventFields.endTime];
        const monthStart = new Date(this.parent.selectedDate.getFullYear(), month, 1);
        const monthEnd = addDays(new Date(this.parent.selectedDate.getFullYear(), month + 1, 0), 1);
        let count = 1;
        if (eventStart.getTime() < monthStart.getTime()) {
            eventData[this.parent.eventFields.startTime] = monthStart;
        }
        if (eventEnd.getTime() > monthEnd.getTime()) {
            eventData[this.parent.eventFields.endTime] = monthEnd;
        }
        if (this.parent.activeViewOptions.group.resources.length === 0) {
            count = Math.ceil((eventData[this.parent.eventFields.endTime].getTime() -
                eventData[this.parent.eventFields.startTime].getTime()) / MS_PER_DAY);
        }
        eventData.count = count;
        return eventData;
    }
    resizeStop(e) {
        EventHandler.remove(document, Browser.touchMoveEvent, this.resizing);
        EventHandler.remove(document, Browser.touchEndEvent, this.resizeStop);
        clearInterval(this.actionObj.scrollInterval);
        this.actionObj.scrollInterval = null;
        this.removeCloneElementClasses();
        this.removeCloneElement();
        this.actionClass('removeClass');
        this.parent.uiStateValues.action = false;
        const resizeArgs = { cancel: false, data: this.getChangedData(), element: this.actionObj.element, event: e };
        this.parent.trigger(resizeStop, resizeArgs, (resizeEventArgs) => {
            if (resizeEventArgs.cancel) {
                return;
            }
            if (this.parent.isSpecificResourceEvents()) {
                this.parent.crudModule.crudObj.sourceEvent =
                    [this.parent.resourceBase.lastResourceLevel[parseInt(resizeEventArgs.element.getAttribute('data-group-index'), 10)]];
                this.parent.crudModule.crudObj.targetEvent = this.parent.crudModule.crudObj.sourceEvent;
                this.parent.crudModule.crudObj.isCrudAction = true;
            }
            this.saveChangedData(resizeEventArgs);
        });
    }
    verticalResizing(isTop) {
        let offsetValue = this.actionObj.clone.offsetTop;
        if (!isTop) {
            offsetValue += this.actionObj.clone.offsetHeight;
        }
        const minutes = (offsetValue / this.actionObj.cellHeight) * this.actionObj.slotInterval;
        const element = this.actionObj.clone.offsetParent;
        if (isNullOrUndefined(element)) {
            return;
        }
        const resizeTime = resetTime(this.parent.getDateFromElement(element));
        resizeTime.setHours(this.parent.activeView.getStartHour().getHours());
        resizeTime.setMinutes(minutes + this.parent.activeView.getStartHour().getMinutes());
        if (isTop) {
            this.actionObj.start = this.calculateIntervalTime(resizeTime);
        }
        else {
            this.actionObj.end = this.calculateIntervalTime(resizeTime);
        }
        this.updateTimePosition(resizeTime);
    }
    horizontalResizing(isLeft) {
        const eventStart = new Date(this.actionObj.event[this.parent.eventFields.startTime].getTime());
        const eventEnd = new Date(this.actionObj.event[this.parent.eventFields.endTime].getTime());
        let resizeTime;
        let isDateHeader = false;
        let headerName = this.parent.currentView;
        const isTimeViews = ['TimelineDay', 'TimelineWeek', 'TimelineWorkWeek'].indexOf(this.parent.currentView) > -1;
        const isTimelineMonth = this.parent.currentView === 'TimelineMonth';
        const isWithoutScale = isTimelineMonth || isTimeViews && !this.parent.activeViewOptions.timeScale.enable;
        if (this.parent.activeView.isTimelineView()) {
            const tr = this.parent.getContentTable().querySelector('tr');
            if (this.parent.activeViewOptions.headerRows.length > 0) {
                const rows = this.parent.activeViewOptions.headerRows.map((row) => row.option);
                headerName = rows.slice(-1)[0];
                if (isTimelineMonth && headerName === 'Hour') {
                    headerName = rows.slice(-2)[0] || 'Month';
                }
            }
            resizeTime = isLeft ? eventStart : eventEnd;
            let cellIndex = 0;
            const tdCollections = [].slice.call(tr.children);
            let isLastCell = false;
            const pixelsPerMinute = this.actionObj.cellWidth / (this.parent.activeViewOptions.timeScale.interval /
                this.parent.activeViewOptions.timeScale.slotCount);
            let offset = parseFloat(this.parent.enableRtl ? this.actionObj.clone.style.right :
                this.actionObj.clone.style.left);
            offset = Math.round(offset / pixelsPerMinute) * pixelsPerMinute;
            if (['Year', 'Month', 'Week', 'Date'].indexOf(headerName) !== -1) {
                let noOfDays = 0;
                for (const td of tdCollections) {
                    noOfDays += parseInt(td.getAttribute('colspan'), 10);
                }
                let offsetValue = this.parent.enableRtl ? parseInt(this.actionObj.clone.style.right, 10) :
                    parseInt(this.actionObj.clone.style.left, 10);
                offsetValue = Math.round(offsetValue / this.actionObj.cellWidth) * this.actionObj.cellWidth;
                if (!isLeft) {
                    offsetValue += (this.actionObj.clone.getBoundingClientRect().width - this.actionObj.cellWidth);
                }
                cellIndex = Math.floor(offsetValue / Math.floor(tr.getBoundingClientRect().width / noOfDays));
                isDateHeader = isTimeViews && headerName === 'Date';
                cellIndex = isLeft ? cellIndex : isTimelineMonth ? cellIndex + 1 : cellIndex;
                isLastCell = cellIndex === tdCollections.length;
                cellIndex = (cellIndex < 0) ? 0 : (cellIndex >= noOfDays) ? noOfDays - 1 : cellIndex;
            }
            else {
                const cellWidth = this.actionObj.cellWidth;
                cellIndex = isLeft ? Math.floor(offset / this.actionObj.cellWidth) :
                    Math.ceil((offset + (this.actionObj.clone.getBoundingClientRect().width - cellWidth)) / this.actionObj.cellWidth);
                if (this.parent.enableRtl) {
                    let cellOffsetWidth = 0;
                    if (headerName === 'TimelineMonth' || (!this.parent.activeViewOptions.timeScale.enable &&
                        !isTimelineMonth)) {
                        cellOffsetWidth = this.actionObj.cellWidth;
                    }
                    const offsetWidth = (Math.floor(offset / this.actionObj.cellWidth) *
                        this.actionObj.cellWidth) + (isLeft ? 0 : this.actionObj.clone.getBoundingClientRect().width - cellOffsetWidth);
                    cellIndex = Math.floor(offsetWidth / this.actionObj.cellWidth);
                }
                isLastCell = cellIndex === tdCollections.length;
                cellIndex = this.getIndex(cellIndex);
            }
            let resizeDate;
            if (['Year', 'Month', 'Week', 'Date'].indexOf(headerName) !== -1) {
                resizeDate = new Date(this.parent.activeView.renderDates[parseInt(cellIndex.toString(), 10)].getTime());
            }
            else {
                resizeDate = this.parent.getDateFromElement(tr.children[parseInt(cellIndex.toString(), 10)]);
            }
            if (['TimelineMonth', 'Year', 'Month', 'Week', 'Date'].indexOf(headerName) !== -1 ||
                !this.parent.activeViewOptions.timeScale.enable) {
                resizeTime = new Date(resizeDate.setHours(resizeTime.getHours(), resizeTime.getMinutes(), resizeTime.getSeconds()));
            }
            else {
                if (!isLeft) {
                    offset += this.actionObj.clone.getBoundingClientRect().width;
                }
                let spanMinutes = Math.ceil((this.actionObj.slotInterval / this.actionObj.cellWidth) *
                    (offset - Math.floor(offset / this.actionObj.cellWidth) * this.actionObj.cellWidth));
                spanMinutes = (isLastCell || (!isLeft && spanMinutes === 0)) ? this.actionObj.slotInterval : spanMinutes;
                resizeTime = new Date(resizeDate.getTime());
                resizeTime.setMinutes(resizeTime.getMinutes() + spanMinutes);
                this.updateTimePosition(resizeTime);
            }
        }
        else {
            const cloneIndex = closest(this.actionObj.clone, 'td').cellIndex;
            const originalWidth = Math.ceil((isLeft ? this.actionObj.element.getBoundingClientRect().width : 0) /
                this.actionObj.cellWidth) * this.actionObj.cellWidth;
            const noOfDays = Math.ceil((this.actionObj.clone.getBoundingClientRect().width - originalWidth) /
                this.actionObj.cellWidth);
            const tr = closest(this.actionObj.clone, 'tr');
            let dayIndex = isLeft ? cloneIndex - noOfDays : cloneIndex + noOfDays - 1;
            dayIndex = this.getIndex(dayIndex);
            resizeTime = this.parent.getDateFromElement(tr.children[parseInt(dayIndex.toString(), 10)]);
            if (isLeft) {
                resizeTime.setHours(eventStart.getHours(), eventStart.getMinutes(), eventStart.getSeconds());
            }
            else {
                resizeTime.setHours(eventEnd.getHours(), eventEnd.getMinutes(), eventEnd.getSeconds());
            }
        }
        const isNotHourSlot = ['TimelineMonth', 'Year', 'Month', 'Week', 'Date'].indexOf(headerName) !== -1 ||
            !this.parent.activeViewOptions.timeScale.enable;
        if (isLeft) {
            if ((eventEnd.getTime() - resizeTime.getTime()) <= 0) {
                resizeTime = isWithoutScale ? resetTime(eventEnd) : eventStart;
            }
            this.actionObj.start = !isNotHourSlot ? this.calculateIntervalTime(resizeTime) : resizeTime;
        }
        else {
            const isTimeScaleViews = isTimeViews && this.parent.activeViewOptions.timeScale.enable;
            let resizeEnd = ((!isTimeScaleViews || isDateHeader || isTimeViews && ['Week', 'Month', 'Year'].indexOf(headerName) > -1)
                && resizeTime.getHours() === 0 && resizeTime.getMinutes() === 0) ? addDays(resizeTime, 1) : resizeTime;
            if (isWithoutScale && (resizeEnd.getTime() - eventStart.getTime()) <= 0) {
                resizeEnd = addDays(resetTime(eventStart), 1);
            }
            this.actionObj.end = !isNotHourSlot ? this.calculateIntervalTime(resizeEnd) : resizeEnd;
        }
    }
    getTopBottomStyles(e, isTop) {
        const viewElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        const slotInterval = (this.actionObj.cellHeight / this.actionObj.slotInterval) * this.actionObj.interval;
        let clnHeight = isTop ? this.actionObj.element.offsetHeight + (this.actionObj.Y - this.actionObj.pageY) :
            this.actionObj.element.offsetHeight + (this.actionObj.pageY - this.actionObj.Y);
        let clnTop = isTop ? this.actionObj.element.offsetTop -
            (this.actionObj.Y - this.actionObj.pageY) : this.actionObj.clone.offsetTop;
        clnHeight = (clnTop < 0) ? this.actionObj.clone.offsetHeight :
            (this.actionObj.clone.offsetTop + this.actionObj.clone.offsetHeight) > this.scrollArgs.height ?
                this.actionObj.clone.offsetHeight : clnHeight;
        clnTop = (clnTop < 0) ? 0 : clnTop;
        clnTop = isTop ? Math.floor(clnTop / slotInterval) * slotInterval : clnTop;
        clnHeight = clnTop + clnHeight >= viewElement.scrollHeight ? viewElement.scrollHeight - clnTop :
            Math.ceil(clnHeight / slotInterval) * slotInterval;
        if (!isTop && this.actionObj.clone.offsetTop + clnHeight >= this.parent.getContentTable().offsetHeight) {
            clnHeight = this.parent.getContentTable().offsetHeight - this.actionObj.clone.offsetTop;
        }
        const styles = {
            height: formatUnit(clnHeight < this.actionObj.cellHeight ? Math.floor(clnHeight / slotInterval) * slotInterval : clnHeight),
            top: formatUnit((clnHeight < this.actionObj.cellHeight && isTop) ? Math.ceil(clnTop / slotInterval) * slotInterval : clnTop),
            left: '0px', right: '0px', width: '100%'
        };
        return styles;
    }
    getLeftRightStyles(e, isLeft) {
        const styles = {};
        const isTimelineView = this.parent.activeView.isTimelineView();
        const isTimeViews = ['TimelineDay', 'TimelineWeek', 'TimelineWorkWeek'].indexOf(this.parent.currentView) > -1 &&
            this.parent.activeViewOptions.timeScale.enable;
        const slotInterval = (this.actionObj.cellWidth / this.actionObj.slotInterval) * this.actionObj.interval;
        const pageWidth = isLeft ? (this.actionObj.X - this.actionObj.pageX) : (this.actionObj.pageX - this.actionObj.X);
        const targetWidth = isTimelineView ?
            (this.actionObj.element.getBoundingClientRect().width / this.actionObj.cellWidth) * this.actionObj.cellWidth :
            this.parent.currentView === 'Month' ? this.actionObj.element.getBoundingClientRect().width :
                Math.ceil(this.actionObj.element.getBoundingClientRect().width / this.actionObj.cellWidth) * this.actionObj.cellWidth;
        let offsetWidth = targetWidth + (Math.ceil(pageWidth / this.actionObj.cellWidth) * this.actionObj.cellWidth);
        const left = (this.parent.enableRtl) ? parseInt(this.actionObj.element.style.right, 10) : this.actionObj.clone.offsetLeft;
        if (isTimeViews) {
            offsetWidth = targetWidth + (Math.ceil(pageWidth / slotInterval) * slotInterval);
            offsetWidth = (Math.round((left + offsetWidth) / slotInterval) * slotInterval) - left;
            this.actionObj.event[this.parent.eventFields.isAllDay] = false;
        }
        let width = !isLeft && ((offsetWidth + this.actionObj.clone.offsetLeft > this.scrollArgs.width)) ?
            this.actionObj.clone.getBoundingClientRect().width : (offsetWidth < this.actionObj.cellWidth) ? offsetWidth : offsetWidth;
        if (this.parent.enableRtl) {
            let rightValue = isTimelineView ? parseInt(this.actionObj.element.style.right, 10) :
                -(offsetWidth - this.actionObj.cellWidth);
            rightValue = isTimelineView ? rightValue : isLeft ? 0 : rightValue > 0 ? 0 : rightValue;
            if (isTimelineView && !isLeft) {
                rightValue = Math.ceil((this.actionObj.element.offsetLeft + (this.actionObj.element.getBoundingClientRect().width +
                    (this.actionObj.pageX - this.actionObj.X))) / slotInterval) * slotInterval;
                rightValue = rightValue < 0 ? Math.abs(rightValue) : -rightValue;
            }
            rightValue = rightValue >= this.scrollArgs.width ? this.scrollArgs.width - this.actionObj.cellWidth : rightValue;
            styles.right = formatUnit(rightValue);
            width = width + rightValue > this.scrollArgs.width ? this.actionObj.clone.getBoundingClientRect().width : width;
        }
        else {
            let offsetLeft = isLeft ? this.actionObj.element.offsetLeft - (this.actionObj.X - this.actionObj.pageX) :
                this.parent.enableRtl ? this.actionObj.element.offsetLeft : 0;
            if (isTimelineView) {
                offsetLeft = isLeft ? offsetLeft : parseInt(this.actionObj.clone.style.left, 10);
                if (this.parent.enableRtl) {
                    offsetLeft = !isLeft ? (this.actionObj.pageX < this.actionObj.X - this.actionObj.clone.getBoundingClientRect().width)
                        ? parseInt(this.actionObj.clone.style.right, 10) : offsetLeft : offsetLeft;
                }
                else {
                    offsetLeft = isLeft ? (this.actionObj.pageX > this.actionObj.X + this.actionObj.clone.getBoundingClientRect().width &&
                        this.actionObj.clone.getBoundingClientRect().width === this.actionObj.cellWidth) ?
                        parseInt(this.actionObj.clone.style.left, 10) : offsetLeft : offsetLeft;
                }
            }
            const leftValue = offsetLeft;
            offsetLeft = isTimelineView ? isTimeViews ? isLeft ? Math.floor(offsetLeft / slotInterval) * slotInterval : offsetLeft :
                Math.floor(offsetLeft / this.actionObj.cellWidth) * this.actionObj.cellWidth :
                Math.ceil(Math.abs(offsetLeft) / this.actionObj.cellWidth) * this.actionObj.cellWidth;
            if (offsetLeft < 0) {
                offsetLeft = 0;
                width = this.actionObj.clone.getBoundingClientRect().width;
            }
            const cloneWidth = Math.ceil(this.actionObj.clone.getBoundingClientRect().width / this.actionObj.cellWidth) *
                this.actionObj.cellWidth;
            if (isLeft) {
                styles.left = formatUnit(isTimelineView ? offsetLeft : isLeft ? leftValue < 0 ? -offsetLeft :
                    (Math.ceil((targetWidth - cloneWidth) / this.actionObj.cellWidth) * this.actionObj.cellWidth) : offsetLeft);
            }
        }
        styles.width = formatUnit(width);
        return styles;
    }
    resizeValidation(e) {
        const pages = this.parent.eventBase.getPageCoordinates(e);
        const viewDimension = this.getContentAreaDimension();
        const isTimeScale = this.parent.activeView.isTimelineView() && this.parent.activeViewOptions.timeScale.enable;
        let cellWidth = this.actionObj.cellWidth;
        let resizeValidation = false;
        if (this.resizeEdges.left) {
            if (pages.pageX < viewDimension.leftOffset && pages.pageX >= viewDimension.left && isTimeScale) {
                cellWidth = 0;
            }
            resizeValidation = (pages.pageX - cellWidth) >= viewDimension.left;
        }
        if (this.resizeEdges.right) {
            if (pages.pageX > viewDimension.rightOffset && pages.pageX <= viewDimension.right && isTimeScale) {
                cellWidth = 0;
            }
            resizeValidation = (pages.pageX + cellWidth) <= viewDimension.right;
        }
        if (this.resizeEdges.top) {
            resizeValidation = this.actionObj.clone.offsetTop >= viewDimension.top;
        }
        if (this.resizeEdges.bottom) {
            resizeValidation = (this.actionObj.clone.offsetTop + this.actionObj.clone.offsetHeight) <= this.scrollArgs.height;
        }
        return resizeValidation;
    }
    /**
     * Get module name
     *
     * @returns {string} Returns the module name..
     */
    getModuleName() {
        return 'resize';
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
const EVENT_GAP$2 = 2;
/**
 * Year view events render
 */
class YearEvent extends TimelineEvent {
    constructor(parent) {
        super(parent, 'day');
        this.isResource = false;
    }
    renderAppointments() {
        if (this.parent.dragAndDropModule) {
            this.parent.dragAndDropModule.setDragArea();
        }
        this.fields = this.parent.eventFields;
        const elementSelector = (this.parent.currentView === 'Year') ? '.' + APPOINTMENT_CLASS :
            '.' + APPOINTMENT_WRAPPER_CLASS + ',.' + MORE_INDICATOR_CLASS;
        const eventWrappers = [].slice.call(this.parent.element.querySelectorAll(elementSelector));
        for (const wrapper of eventWrappers) {
            remove(wrapper);
        }
        this.renderedEvents = [];
        if (this.parent.currentView === 'Year') {
            this.yearViewEvents();
        }
        else {
            this.removeCellHeight();
            if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
                this.isResource = true;
                this.timelineResourceEvents();
            }
            else {
                this.timelineYearViewEvents();
            }
        }
        this.parent.renderTemplates();
        this.parent.notify(contentReady, {});
    }
    yearViewEvents() {
        const months = this.getMonths();
        for (const month of months) {
            const queryString = `.e-month-calendar:nth-child(${months.indexOf(month) + 1}) td.e-work-cells`;
            const workCells = [].slice.call(this.parent.element.querySelectorAll(queryString));
            const monthDate = new Date(this.parent.selectedDate.getFullYear(), month, 1);
            const monthStart = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));
            const monthEnd = this.parent.calendarUtil.getMonthEndDate(new Date(monthDate.getTime()));
            let startDate = getWeekFirstDate(monthStart, this.parent.firstDayOfWeek);
            const endDate = addDays(getWeekLastDate(monthEnd, this.parent.firstDayOfWeek), 1);
            for (let index = 0; startDate.getTime() < endDate.getTime(); index++) {
                const start = resetTime(new Date(startDate.getTime()));
                const end = addDays(new Date(start.getTime()), 1);
                startDate = addDays(new Date(startDate.getTime()), 1);
                if (!this.parent.isMinMaxDate(start)) {
                    continue;
                }
                const filterEvents = this.parent.eventBase.filterEvents(start, end);
                if (filterEvents.length > 0) {
                    const workCell = workCells[parseInt(index.toString(), 10)];
                    if (workCell) {
                        workCell.appendChild(createElement('div', { className: APPOINTMENT_CLASS }));
                    }
                }
            }
        }
    }
    timelineYearViewEvents() {
        const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')');
        this.cellWidth = workCell.getBoundingClientRect().width;
        this.cellHeader = getOuterHeight(workCell.querySelector('.' + DATE_HEADER_CLASS));
        const eventTable = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);
        this.eventHeight = getElementHeightFromClass(eventTable, APPOINTMENT_CLASS);
        const wrapperCollection = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));
        const months = this.getMonths();
        const groupIndex = (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.uiStateValues.isGroupAdaptive) ?
            this.parent.uiStateValues.groupIndex : undefined;
        for (let row = 0; row < months.length; row++) {
            const wrapper = wrapperCollection[parseInt(row.toString(), 10)];
            let td = row + 1;
            let eventWrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
            wrapper.appendChild(eventWrapper);
            let monthStart = new Date(this.parent.selectedDate.getFullYear(), months[parseInt(row.toString(), 10)], 1);
            const monthEnd = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 0);
            let dayIndex = monthStart.getDay();
            const isSpannedCollection = [];
            if (this.parent.activeViewOptions.orientation === 'Horizontal') {
                this.renderedEvents = [];
            }
            while (monthStart.getTime() <= monthEnd.getTime()) {
                let leftValue;
                let rightValue;
                if (this.parent.activeViewOptions.orientation === 'Vertical') {
                    const wrapper = wrapperCollection[parseInt(dayIndex.toString(), 10)];
                    td = dayIndex + 1;
                    eventWrapper = wrapper.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);
                    if (!eventWrapper) {
                        eventWrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
                        wrapper.appendChild(eventWrapper);
                    }
                    if (this.parent.enableRtl) {
                        rightValue = row * this.cellWidth;
                    }
                    else {
                        leftValue = row * this.cellWidth;
                    }
                }
                else {
                    if (this.parent.enableRtl) {
                        rightValue = ((dayIndex + monthStart.getDate()) - 1) * this.cellWidth;
                    }
                    else {
                        leftValue = ((dayIndex + monthStart.getDate()) - 1) * this.cellWidth;
                    }
                }
                const rowTd = this.parent.element.querySelector(`.e-content-wrap tr:nth-child(${td}) td`);
                this.cellHeight = rowTd.offsetHeight;
                const dayStart = resetTime(new Date(monthStart.getTime()));
                const dayEnd = addDays(new Date(dayStart.getTime()), 1);
                let resource;
                if (this.parent.uiStateValues.isGroupAdaptive) {
                    resource = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];
                }
                let dayEvents = this.parent.eventBase.filterEvents(dayStart, dayEnd, undefined, resource);
                dayEvents = this.parent.eventBase.sortByDateTime(dayEvents);
                for (let index = 0, count = dayEvents.length; index < count; index++) {
                    const eventData = extend({}, dayEvents[parseInt(index.toString(), 10)], null, true);
                    this.updateSpannedEvents(eventData, dayStart, dayEnd);
                    const overlapIndex = this.getIndex(dayStart);
                    eventData.Index = overlapIndex;
                    const availedHeight = this.cellHeader + (this.eventHeight * (overlapIndex + 1)) + EVENT_GAP$2 +
                        this.moreIndicatorHeight;
                    const appArea = this.cellHeight - this.cellHeader - this.moreIndicatorHeight;
                    const renderedAppCount = Math.floor(appArea / (this.eventHeight + EVENT_GAP$2));
                    const moreIndicatorCount = (count - renderedAppCount) <= 0 ? 1 : (count - renderedAppCount);
                    if (this.parent.activeViewOptions.orientation === 'Horizontal') {
                        const isRendered = this.renderedEvents.filter((eventObj) => eventObj.Guid === eventData.Guid);
                        const isSpanned = isSpannedCollection.filter((eventObj) => eventObj.Guid === eventData.Guid);
                        if (isRendered.length > 0 && isRendered[0].MoreIndicator || isSpanned.length > 0 && isSpanned[0].MoreIndicator) {
                            const moreIndex = this.parent.activeViewOptions.orientation === 'Horizontal' ? row : dayIndex;
                            this.renderMoreIndicator(eventWrapper, moreIndicatorCount, dayStart, moreIndex, leftValue, rightValue, groupIndex);
                            continue;
                        }
                        else if (isRendered.length > 0 || isSpanned.length > 0) {
                            continue;
                        }
                    }
                    if (this.parent.rowAutoHeight || this.cellHeight > availedHeight) {
                        this.renderEvent(eventWrapper, eventData, row, leftValue, rightValue, monthStart, dayIndex);
                        this.updateCellHeight(rowTd, availedHeight);
                        isSpannedCollection.push(eventData);
                    }
                    else {
                        const moreIndex = this.parent.activeViewOptions.orientation === 'Horizontal' ? row : dayIndex;
                        this.renderMoreIndicator(eventWrapper, moreIndicatorCount, dayStart, moreIndex, leftValue, rightValue, groupIndex);
                        if (this.parent.activeViewOptions.orientation === 'Horizontal') {
                            eventData.MoreIndicator = true;
                            this.renderedEvents.push(eventData);
                            isSpannedCollection.push(eventData);
                        }
                    }
                }
                monthStart = addDays(new Date(monthStart.getTime()), 1);
                if (this.parent.activeViewOptions.orientation === 'Vertical') {
                    dayIndex++;
                    this.renderedEvents = [];
                }
            }
        }
        if (this.parent.rowAutoHeight && this.parent.activeViewOptions.orientation === 'Vertical') {
            const appContainer = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));
            const tr = [].slice.call(this.parent.element.querySelectorAll('.' + CONTENT_TABLE_CLASS + ' tbody tr'));
            appContainer.forEach((ele, index) => {
                const app = [].slice.call(ele.querySelectorAll('.' + APPOINTMENT_CLASS));
                const appTop = tr[parseInt(index.toString(), 10)].offsetTop + this.cellHeader + EVENT_GAP$2;
                app.forEach((app) => {
                    const overlap = parseInt(app.getAttribute('data-index'), 10);
                    app.style.top = appTop + (overlap * this.eventHeight) + 'px';
                    app.removeAttribute('data-index');
                });
            });
        }
    }
    updateSpannedEvents(eventObj, dayStart, dayEnd) {
        const isLeftRightResize = (this.isResource && this.parent.activeViewOptions.orientation === 'Vertical') ||
            (!this.isResource && this.parent.activeViewOptions.orientation === 'Horizontal');
        const data = { isLeft: true, isRight: true, isBottom: true, isTop: true };
        if (dayStart.getTime() <= eventObj[this.fields.startTime].getTime()) {
            if (isLeftRightResize) {
                data.isLeft = false;
            }
            else {
                data.isTop = false;
            }
        }
        if ((dayEnd.getTime() >= eventObj[this.fields.endTime].getTime()) || (isLeftRightResize && !this.isResource &&
            addDays(dayEnd, -1).getMonth() === eventObj[this.fields.endTime].getMonth()) ||
            (isLeftRightResize && this.isResource && (dayEnd.getTime() <= eventObj[this.fields.endTime].getTime()))) {
            if (isLeftRightResize) {
                data.isRight = false;
            }
            else {
                data.isBottom = false;
            }
        }
        eventObj.data = data;
    }
    timelineResourceEvents() {
        const contentTable = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        const isVerticalScrollbarAvail = contentTable.offsetWidth > contentTable.clientWidth;
        const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS);
        this.cellWidth = workCell.getBoundingClientRect().width;
        this.cellHeader = 0;
        const eventTable = this.parent.element.querySelector('.' + EVENT_TABLE_CLASS);
        this.eventHeight = getElementHeightFromClass(eventTable, APPOINTMENT_CLASS);
        const wrapperCollection = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));
        const resources = this.parent.uiStateValues.isGroupAdaptive ?
            [this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex]] :
            this.parent.activeViewOptions.allowVirtualScrolling ? this.parent.resourceBase.renderedResources :
                this.parent.resourceBase.lastResourceLevel;
        const months = this.getMonths();
        if (this.parent.activeViewOptions.orientation === 'Horizontal') {
            for (let month = 0; month < months.length; month++) {
                const monthStart = new Date(this.parent.selectedDate.getFullYear(), months[parseInt(month.toString(), 10)], 1);
                for (let i = 0, len = resources.length; i < len; i++) {
                    this.renderedEvents = [];
                    this.renderResourceEvent(wrapperCollection[parseInt(month.toString(), 10)], resources[parseInt(i.toString(), 10)], month, i, monthStart);
                }
            }
        }
        else {
            for (let i = 0, len = resources.length; i < len; i++) {
                this.renderedEvents = [];
                for (let month = 0; month < months.length; month++) {
                    const monthStart = new Date(this.parent.selectedDate.getFullYear(), months[parseInt(month.toString(), 10)], 1);
                    this.renderResourceEvent(wrapperCollection[parseInt(i.toString(), 10)], resources[parseInt(i.toString(), 10)], month, i, monthStart);
                }
            }
        }
        if (this.parent.rowAutoHeight && !isVerticalScrollbarAvail && contentTable.offsetWidth > contentTable.clientWidth) {
            const appointments = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));
            appointments.forEach((ele) => {
                ele.style.removeProperty('left');
                ele.style.removeProperty('right');
            });
            const appContainer = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CONTAINER_CLASS));
            const conTable = this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS);
            const tr = [].slice.call(conTable.querySelectorAll('tbody tr'));
            appContainer.forEach((ele, index) => {
                const appWrapper = [].slice.call(ele.children);
                const row = tr[parseInt(index.toString(), 10)];
                appWrapper.forEach((appWrap, cellIndex) => {
                    const td = row.querySelector(`td:nth-child(${cellIndex + 1})`);
                    const app = [].slice.call(appWrap.children);
                    const width = td.getBoundingClientRect().width;
                    const left = td.offsetLeft;
                    if (this.parent.enableRtl) {
                        const right = conTable.offsetWidth - left - td.offsetWidth;
                        app.forEach((app) => {
                            app.style.width = Math.floor(parseInt(app.style.width, 10) / width) * width + 'px';
                            app.style.right = right + 'px';
                        });
                    }
                    else {
                        app.forEach((app) => {
                            app.style.width = Math.floor(parseInt(app.style.width, 10) / width) * width + 'px';
                            app.style.left = left + 'px';
                        });
                    }
                });
            });
        }
    }
    renderResourceEvent(wrapper, resource, month, index, monthStart) {
        const eventWrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
        wrapper.appendChild(eventWrapper);
        const monthEnd = addDays(lastDateOfMonth(new Date(monthStart.getTime())), 1);
        const eventDatas = this.parent.eventBase.filterEvents(monthStart, monthEnd, undefined, resource);
        const rowIndex = this.parent.activeViewOptions.orientation === 'Vertical' ? index : month;
        const td = this.parent.element.querySelector(`.e-content-wrap tr:nth-child(${rowIndex + 1}) td`);
        this.cellHeight = td.offsetHeight;
        this.groupOrder = resource.groupOrder;
        const isSpannedCollection = [];
        for (let a = 0; a < eventDatas.length; a++) {
            const data = eventDatas[parseInt(a.toString(), 10)];
            let overlapIndex;
            const eventData = extend({}, data, null, true);
            if (this.parent.activeViewOptions.group.resources.length > 0) {
                const eventObj = this.isSpannedEvent(eventData, monthStart);
                overlapIndex = this.getIndex(eventObj[this.fields.startTime]);
                eventData.Index = overlapIndex;
            }
            else {
                overlapIndex = this.getIndex(eventData[this.fields.startTime]);
                eventData.Index = overlapIndex;
            }
            const availedHeight = this.cellHeader + (this.eventHeight * (a + 1)) + EVENT_GAP$2 + this.moreIndicatorHeight;
            const leftValue = (this.parent.activeViewOptions.orientation === 'Vertical') ?
                month * this.cellWidth : index * this.cellWidth;
            if (!this.parent.isMinMaxDate(eventData[this.fields.startTime])) {
                return;
            }
            if (this.parent.activeViewOptions.orientation === 'Vertical' && this.parent.activeViewOptions.group.resources.length > 0) {
                const isRendered = this.renderedEvents.filter((eventObj) => eventObj.Guid === eventData.Guid);
                const isSpanned = isSpannedCollection.filter((eventObj) => eventObj.Guid === eventData.Guid);
                if (isRendered.length > 0 || isSpanned.length > 0) {
                    continue;
                }
            }
            if (this.parent.rowAutoHeight || this.cellHeight > availedHeight) {
                this.renderEvent(eventWrapper, eventData, month, leftValue, leftValue, monthStart, index);
                this.updateCellHeight(td, availedHeight);
                isSpannedCollection.push(eventData);
            }
            else {
                const moreIndex = this.parent.activeViewOptions.orientation === 'Horizontal' ? month : index;
                this.renderMoreIndicator(eventWrapper, eventDatas.length - a, monthStart, moreIndex, leftValue, leftValue, index);
                if (this.parent.activeViewOptions.orientation === 'Horizontal') {
                    for (let i = index; i < eventDatas.length; i++) {
                        this.renderedEvents.push(extend({}, eventDatas[parseInt(i.toString(), 10)], { Index: overlapIndex + i }, true));
                    }
                }
                break;
            }
        }
    }
    // eslint-disable-next-line max-len
    renderEvent(wrapper, eventData, row, left, right, monthDate, rowIndex) {
        const eventObj = this.isSpannedEvent(eventData, monthDate);
        const wrap = this.createEventElement(eventObj);
        let width;
        let index;
        if (eventObj.isSpanned.count === 1) {
            const endTime = addDays(eventObj[this.fields.endTime], -1);
            eventObj[this.fields.endTime] = (endTime > eventObj[this.fields.startTime]) ? endTime : eventObj[this.fields.endTime];
        }
        if (eventObj[this.fields.startTime] > eventObj[this.fields.endTime]) {
            return;
        }
        if (this.parent.activeViewOptions.orientation === 'Horizontal') {
            index = row + 1;
            if (eventObj[this.fields.startTime].getTime() === eventObj[this.fields.endTime].getTime()) {
                eventObj.isSpanned.count = 1;
            }
            width = eventObj.isSpanned.count * this.cellWidth;
        }
        else {
            index = rowIndex + 1;
            width = this.isResource ? eventObj.isSpanned.count * this.cellWidth : this.cellWidth;
        }
        const rowTd = this.parent.element.querySelector(`.e-content-wrap tr:nth-child(${index}) td`);
        const top = rowTd.offsetTop + this.cellHeader + (this.eventHeight * eventObj.Index) + EVENT_GAP$2;
        setStyleAttribute(wrap, {
            'width': width + 'px', 'height': this.eventHeight + 'px', 'left': left + 'px', 'right': right + 'px', 'top': top + 'px'
        });
        if (!this.isResource && this.parent.rowAutoHeight && this.parent.activeViewOptions.orientation === 'Vertical') {
            wrap.setAttribute('data-index', eventObj.Index.toString());
        }
        const args = { data: eventObj, element: wrap, cancel: false, type: 'event' };
        this.parent.trigger(eventRendered, args, (eventArgs) => {
            if (!eventArgs.cancel) {
                wrapper.appendChild(wrap);
                this.wireAppointmentEvents(wrap, eventObj);
                if (this.parent.activeViewOptions.group.resources.length > 0) {
                    this.renderedEvents.push(extend({}, eventObj, null, true));
                }
                else if (this.parent.activeViewOptions.orientation === 'Vertical') {
                    this.renderedEvents.push(extend({}, eventObj, null, true));
                }
                else if ((eventObj.isSpanned.isRight || eventObj.isSpanned.isLeft) && this.parent.activeViewOptions.orientation === 'Horizontal'
                    || !eventObj.isSpanned.isRight) {
                    this.renderedEvents.push(extend({}, eventObj, null, true));
                }
            }
        });
    }
    // eslint-disable-next-line max-len
    renderMoreIndicator(wrapper, count, startDate, row, left, right, index) {
        if (this.parent.activeViewOptions.group.resources.length === 0 && wrapper.querySelector('[data-start-date="' + startDate.getTime() + '"]')) {
            return;
        }
        let endDate;
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            endDate = addDays(lastDateOfMonth(new Date(startDate.getTime())), 1);
        }
        else {
            endDate = addDays(new Date(startDate.getTime()), 1);
        }
        const moreIndicator = this.getMoreIndicatorElement(count, startDate, endDate);
        const rowTr = this.parent.element.querySelector(`.e-content-wrap tr:nth-child(${row + 1})`);
        const top = rowTr.offsetTop + (this.cellHeight - this.moreIndicatorHeight);
        left = (Math.floor(left / this.cellWidth) * this.cellWidth);
        right = (Math.floor(right / this.cellWidth) * this.cellWidth);
        setStyleAttribute(moreIndicator, { 'width': this.cellWidth + 'px', 'left': left + 'px', 'right': right + 'px', 'top': top + 'px' });
        if (!isNullOrUndefined(index)) {
            moreIndicator.setAttribute('data-group-index', index.toString());
        }
        wrapper.appendChild(moreIndicator);
        EventHandler.add(moreIndicator, 'click', this.moreIndicatorClick, this);
    }
    createEventElement(record) {
        const eventSubject = (record[this.fields.subject] || this.parent.eventSettings.fields.subject.default
            || this.parent.localeObj.getConstant('addTitle'));
        const eventWrapper = createElement('div', {
            className: APPOINTMENT_CLASS,
            attrs: {
                'data-id': 'Appointment_' + record[this.fields.id],
                'data-guid': record.Guid,
                'role': 'button', 'tabindex': '0',
                'aria-disabled': this.parent.eventBase.getReadonlyAttribute(record),
                'aria-label': this.parent.getAnnouncementString(record)
            }
        });
        if (this.cssClass) {
            addClass([eventWrapper], this.cssClass);
        }
        if (record[this.fields.isReadonly]) {
            addClass([eventWrapper], READ_ONLY);
        }
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            const resIndex = this.getGroupIndexFromEvent(record);
            eventWrapper.setAttribute('data-group-index', resIndex.toString());
        }
        let templateElement = [];
        const eventObj = extend({}, record, null, true);
        if (this.parent.activeViewOptions.eventTemplate) {
            const templateId = this.parent.element.id + '_' + this.parent.activeViewOptions.eventTemplateName + 'eventTemplate';
            templateElement = this.parent.getAppointmentTemplate()(eventObj, this.parent, 'eventTemplate', templateId, false);
        }
        else {
            const locationEle = (record[this.fields.location] || this.parent.eventSettings.fields.location.default || '');
            const subjectEle = createElement('div', {
                className: SUBJECT_CLASS,
                innerHTML: (eventSubject + (locationEle ? ';&nbsp' + locationEle : ''))
            });
            const startTimeEle = createElement('div', {
                className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),
                innerHTML: this.parent.getTimeString(eventObj[this.fields.startTime])
            });
            const endTimeEle = createElement('div', {
                className: APPOINTMENT_TIME + (this.parent.isAdaptive ? ' ' + DISABLE_CLASS : ''),
                innerHTML: this.parent.getTimeString(eventObj[this.fields.endTime])
            });
            addClass([subjectEle], 'e-text-center');
            if (record[this.fields.isAllDay]) {
                templateElement = [subjectEle];
            }
            else if (!eventObj.isLeft && !eventObj.isRight) {
                templateElement = [startTimeEle, subjectEle, endTimeEle];
            }
            else {
                if (!eventObj.isLeft) {
                    templateElement.push(startTimeEle);
                }
                templateElement.push(subjectEle);
                if (!eventObj.isRight) {
                    templateElement.push(endTimeEle);
                }
            }
        }
        const appointmentDetails = createElement('div', { className: APPOINTMENT_DETAILS });
        append(templateElement, appointmentDetails);
        eventWrapper.appendChild(appointmentDetails);
        this.parent.eventBase.renderSpannedIcon(eventWrapper, record.isSpanned);
        this.renderResizeHandler(eventWrapper, record.data, record[this.fields.isReadonly]);
        this.applyResourceColor(eventWrapper, eventObj, 'backgroundColor', this.groupOrder);
        return eventWrapper;
    }
    isSpannedEvent(eventObj, monthDate) {
        const monthStart = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1);
        const monthEnd = addDays(new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0), 1);
        const eventData = extend({}, eventObj, null, true);
        const eventStart = eventData[this.fields.startTime];
        const eventEnd = eventData[this.fields.endTime];
        const isSpanned = { isLeft: false, isRight: false, count: 1 };
        const yearStart = new Date(this.parent.selectedDate.getFullYear(), this.parent.firstMonthOfYear, 1);
        const yearEnd = addMonths(yearStart, this.parent.monthsCount);
        if (this.isResource) {
            this.updateSpannedEvents(eventObj, monthStart, monthEnd);
        }
        if (this.parent.activeViewOptions.orientation === 'Vertical' && this.parent.activeViewOptions.group.resources.length > 0) {
            this.updateSpannedEventDetails(eventStart, eventEnd, yearStart, yearEnd, eventData, isSpanned);
            const originalStartTime = eventData[this.fields.startTime];
            const originalEndTime = new Date(eventData[this.fields.endTime] - 1);
            isSpanned.count = (originalEndTime.getMonth() - originalStartTime.getMonth()) +
                (this.parent.monthsCount * (originalEndTime.getFullYear() - originalStartTime.getFullYear())) + 1;
        }
        else {
            this.updateSpannedEventDetails(eventStart, eventEnd, monthStart, monthEnd, eventData, isSpanned);
            if (this.parent.activeViewOptions.group.resources.length === 0 || this.parent.uiStateValues.isGroupAdaptive) {
                let end = resetTime(eventData[this.fields.endTime]).getTime();
                const start = resetTime(eventData[this.fields.startTime]).getTime();
                if (eventObj[this.fields.isAllDay] && end === eventObj[this.fields.endTime].getTime() || isSpanned.isRight) {
                    end = addDays(new Date(end), -1).getTime();
                }
                isSpanned.count = Math.ceil((end - start) / MS_PER_DAY) + 1;
            }
        }
        eventData.isSpanned = isSpanned;
        if (resetTime(eventStart).getTime() < resetTime(this.parent.minDate).getTime()) {
            eventData[this.fields.startTime] = this.parent.minDate;
        }
        if (resetTime(eventEnd).getTime() > resetTime(this.parent.maxDate).getTime()) {
            eventData[this.fields.endTime] = this.parent.maxDate;
        }
        return eventData;
    }
    updateSpannedEventDetails(eventStart, eventEnd, viewStart, viewEnd, eventObj, isSpanned) {
        if (eventStart.getTime() < viewStart.getTime()) {
            eventObj[this.fields.startTime] = viewStart;
            isSpanned.isLeft = true;
        }
        if (eventEnd.getTime() > viewEnd.getTime()) {
            eventObj[this.fields.endTime] = viewEnd;
            isSpanned.isRight = true;
        }
    }
    getOverlapEvents(date, appointments) {
        const appointmentsList = [];
        let dateStart;
        let dateEnd;
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            const monthStart = this.parent.calendarUtil.getMonthStartDate(new Date(date.getTime()));
            const monthEnd = addDays(this.parent.calendarUtil.getMonthEndDate(new Date(date.getTime())), -1);
            dateStart = resetTime(new Date(monthStart.getTime())).getTime();
            dateEnd = resetTime(new Date(monthEnd.getTime())).getTime();
        }
        else {
            if (this.parent.rowAutoHeight) {
                dateStart = resetTime(new Date(date.getTime())).getTime();
                dateEnd = addDays(resetTime(new Date(date.getTime())), 1).getTime();
            }
            else {
                dateStart = dateEnd = resetTime(new Date(date.getTime())).getTime();
            }
        }
        for (const app of appointments) {
            const appStart = new Date(app[this.fields.startTime].getTime());
            const appEnd = new Date(app[this.fields.endTime].getTime());
            const timeCondition = app[this.fields.isAllDay] ? resetTime(appEnd).getTime() > dateStart :
                resetTime(appEnd).getTime() >= dateStart;
            if (((resetTime(appStart).getTime() <= dateStart) && (timeCondition)) ||
                (resetTime(appStart).getTime() >= dateStart) && (resetTime(appEnd).getTime() <= dateEnd)) {
                appointmentsList.push(app);
            }
        }
        return appointmentsList;
    }
    getMonths() {
        // eslint-disable-next-line prefer-spread
        return Array.apply(null, { length: this.parent.monthsCount }).map((value, index) => this.parent.firstMonthOfYear + index);
    }
    removeCellHeight() {
        const elementSelector = `.${MONTH_HEADER_WRAPPER} tbody tr,.${RESOURCE_COLUMN_TABLE_CLASS} tbody tr,.${CONTENT_TABLE_CLASS} tbody tr`;
        const rows = [].slice.call(this.element.querySelectorAll(elementSelector));
        for (const row of rows) {
            row.firstElementChild.style.height = '';
        }
    }
    destroy() {
        super.destroy();
        this.parent = null;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
const MINUTES_PER_DAY = 1440;
/**
 * Schedule events drag actions
 */
class DragAndDrop extends ActionBase {
    constructor() {
        super(...arguments);
        this.widthUptoCursorPoint = 0;
        this.heightUptoCursorPoint = 0;
        this.cursorPointIndex = 0;
        this.isHeaderRows = false;
        this.isTimelineDayProcess = false;
        this.widthPerMinute = 0;
        this.heightPerMinute = 0;
        this.minDiff = 0;
        this.isStepDragging = false;
        this.isMorePopupOpened = false;
        this.isAllDayDrag = false;
        this.isMultiSelect = false;
        this.multiData = [];
        this.updatedData = [];
        this.swagData = [];
        this.startTime = 0;
        this.isAllDayTarget = false;
        this.targetTd = null;
        this.isCursorAhead = false;
    }
    wireDragEvent(element) {
        new Draggable(element, {
            abort: '.' + EVENT_RESIZE_CLASS,
            clone: true,
            isDragScroll: true,
            enableTapHold: this.parent.isAdaptive,
            enableTailMode: (this.parent.eventDragArea) ? true : false,
            cursorAt: (this.parent.eventDragArea) ? { left: -20, top: -20 } : { left: 0, top: 0 },
            dragArea: this.dragArea,
            dragStart: this.dragStart.bind(this),
            drag: this.drag.bind(this),
            dragStop: this.dragStop.bind(this),
            enableAutoScroll: false,
            helper: this.dragHelper.bind(this),
            queryPositionInfo: this.dragPosition.bind(this)
        });
    }
    setDragArea() {
        const dragElement = document.querySelector(this.parent.eventDragArea);
        this.dragArea = this.parent.eventDragArea && dragElement ? dragElement :
            this.parent.element.querySelector('.' + CONTENT_TABLE_CLASS);
    }
    dragHelper(e) {
        this.setDragActionDefaultValues();
        this.actionObj.element = e.element;
        this.actionObj.action = 'drag';
        let elements = [];
        if (!this.parent.allowMultiDrag || isNullOrUndefined(this.parent.selectedElements) || this.parent.selectedElements.length === 0 ||
            (this.parent.selectedElements.length > 0 && this.parent.selectedElements.indexOf(this.actionObj.element) === -1)) {
            elements = [e.element];
        }
        else {
            elements = this.parent.selectedElements;
            this.isMultiSelect = true;
        }
        elements.forEach((ele) => {
            const cloneElement = this.createCloneElement(ele);
            if (ele.getAttribute('data-guid') === this.actionObj.element.getAttribute('data-guid')) {
                this.actionObj.clone = cloneElement;
                if (!this.parent.eventDragArea && this.parent.currentView !== 'Month' &&
                    this.parent.activeViewOptions.timeScale.enable && !this.parent.activeView.isTimelineView() &&
                    !this.actionObj.element.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {
                    setStyleAttribute(this.actionObj.clone, { cursor: 'move', left: '0%', right: '0%', width: '100%' });
                }
                this.actionObj.clone.style.top = formatUnit(this.actionObj.element.offsetTop);
            }
            this.actionObj.cloneElement.push(cloneElement);
            this.actionObj.originalElement.push(ele);
        });
        return this.actionObj.clone;
    }
    dragPosition(e) {
        if (this.parent.eventDragArea) {
            return { left: e.left, top: e.top };
        }
        const cellHeight = (this.actionObj.cellHeight / this.actionObj.slotInterval) * this.actionObj.interval;
        let leftValue = formatUnit(0);
        if (this.parent.currentView === 'Month') {
            leftValue = e.left;
        }
        let cloneRight;
        if (this.isStepDragging) {
            cloneRight = Math.ceil(this.actionObj.clone.getBoundingClientRect().right) + this.actionObj.interval;
        }
        else {
            cloneRight = this.actionObj.clone.getBoundingClientRect().right;
        }
        const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        const contentWrapRight = dragArea.getBoundingClientRect().right;
        if (this.parent.activeView.isTimelineView() && this.parent.currentView !== 'TimelineYear' && !this.parent.enableRtl &&
            this.actionObj.pageX > cloneRight && !this.isMorePopupOpened && !(this.actionObj.pageX > contentWrapRight)) {
            this.isCursorAhead = true;
        }
        if (this.parent.activeView.isTimelineView()) {
            leftValue = formatUnit(this.actionObj.clone.offsetLeft);
        }
        let topValue;
        if ((this.parent.activeView.isTimelineView() || !this.parent.timeScale.enable ||
            (!isNullOrUndefined(this.actionObj.clone.offsetParent) &&
                this.actionObj.clone.offsetParent.classList.contains(MORE_EVENT_POPUP_CLASS)))) {
            topValue = formatUnit(this.actionObj.clone.offsetTop);
        }
        else if (this.parent.currentView === 'Month') {
            topValue = formatUnit(0);
        }
        else if (this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {
            topValue = formatUnit(this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS).offsetTop);
            setStyleAttribute(this.actionObj.clone, {
                width: formatUnit(Math.ceil(this.actionObj.clone.offsetWidth / this.actionObj.cellWidth) * this.actionObj.cellWidth),
                right: this.parent.enableRtl && formatUnit(0)
            });
        }
        else {
            if (this.actionObj.element.classList.contains(ALLDAY_APPOINTMENT_CLASS) &&
                !this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {
                setStyleAttribute(this.actionObj.clone, {
                    height: formatUnit(this.actionObj.cellHeight),
                    width: formatUnit(this.actionObj.cellWidth - 1),
                    pointerEvents: 'none'
                });
            }
            let top = parseInt(e.top, 10);
            top = top < 0 ? 0 : top;
            topValue = formatUnit(Math.ceil(top / cellHeight) * cellHeight);
            const scrollHeight = this.parent.element.querySelector('.e-content-wrap').scrollHeight;
            const cloneBottom = parseInt(topValue, 10) + this.actionObj.clone.offsetHeight;
            if (cloneBottom > scrollHeight) {
                topValue = (parseInt(topValue, 10) - (cloneBottom - scrollHeight)) + 'px';
            }
        }
        return { left: leftValue, top: topValue };
    }
    setDragActionDefaultValues() {
        this.actionObj.action = 'drag';
        this.actionObj.isAllDay = null;
        this.actionObj.slotInterval = this.parent.activeViewOptions.timeScale.interval / this.parent.activeViewOptions.timeScale.slotCount;
        this.actionObj.interval = this.actionObj.slotInterval;
        const workCell = this.parent.element.querySelector('.' + WORK_CELLS_CLASS);
        this.actionObj.cellWidth = workCell.offsetWidth;
        this.actionObj.cellHeight = workCell.offsetHeight;
    }
    dragStart(e) {
        const eventGuid = this.actionObj.element.getAttribute('data-guid');
        this.actionObj.event = this.parent.eventBase.getEventByGuid(eventGuid);
        const eventObj = extend({}, this.actionObj.event, null, true);
        if (!isNullOrUndefined(eventObj)) {
            this.startTime = eventObj[this.parent.eventFields.startTime].getTime();
        }
        const dragArgs = {
            cancel: false,
            data: eventObj,
            selectedData: this.getSelectedData(),
            event: e,
            excludeSelectors: null,
            element: this.actionObj.element,
            interval: this.actionObj.interval,
            navigation: { enable: false, timeDelay: 2000 },
            scroll: { enable: true, scrollBy: 30, timeDelay: 100 }
        };
        this.parent.trigger(dragStart, dragArgs, (dragEventArgs) => {
            if (dragEventArgs.cancel || (!isNullOrUndefined(this.actionObj.element) &&
                isNullOrUndefined(this.actionObj.element.parentElement))) {
                const dragObj = this.actionObj.element.ej2_instances[0];
                if (!isNullOrUndefined(dragObj)) {
                    dragObj.intDestroy(e.event);
                }
                this.actionObj.action = '';
                this.removeCloneElementClasses();
                this.removeCloneElement();
                return;
            }
            this.actionClass('addClass');
            this.parent.uiStateValues.action = true;
            this.actionObj.start = eventObj[this.parent.eventFields.startTime];
            this.actionObj.end = eventObj[this.parent.eventFields.endTime];
            this.actionObj.groupIndex = parseInt(this.actionObj.element.getAttribute('data-group-index') || '0', 10);
            this.actionObj.interval = dragEventArgs.interval;
            this.actionObj.navigation = dragEventArgs.navigation;
            this.actionObj.scroll = dragEventArgs.scroll;
            this.actionObj.excludeSelectors = dragEventArgs.excludeSelectors;
            const viewElement = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
            this.scrollArgs = { element: viewElement, width: viewElement.scrollWidth, height: viewElement.scrollHeight };
            this.widthPerMinute = (this.actionObj.cellWidth / this.actionObj.slotInterval) * this.actionObj.interval;
            this.heightPerMinute = (this.actionObj.cellHeight / this.actionObj.slotInterval) * this.actionObj.interval;
            this.widthUptoCursorPoint = 0;
            this.heightUptoCursorPoint = 0;
            this.cursorPointIndex = -1;
            this.isHeaderRows = false;
            this.isTimelineDayProcess = false;
            this.minDiff = 0;
            this.isMorePopupOpened = false;
            this.daysVariation = -1;
            this.isAllDayTarget = this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS);
            if ((this.parent.activeView.isTimelineView() || !this.parent.timeScale.enable) && this.parent.currentView !== 'TimelineYear') {
                if (!isNullOrUndefined(this.actionObj.clone.offsetParent) &&
                    this.actionObj.clone.offsetParent.classList.contains(MORE_EVENT_POPUP_CLASS)) {
                    this.isMorePopupOpened = true;
                }
                this.actionObj.pageX = e.event.pageX;
                const rows = this.parent.activeViewOptions.headerRows;
                this.isHeaderRows = rows.length > 0 && rows[rows.length - 1].option !== 'Hour' &&
                    rows[rows.length - 1].option !== 'Date';
                this.isTimelineDayProcess = !this.parent.activeViewOptions.timeScale.enable || this.isHeaderRows ||
                    this.parent.currentView === 'TimelineMonth' || (rows.length > 0 && rows[rows.length - 1].option === 'Date');
                this.isStepDragging = !this.isTimelineDayProcess && (this.actionObj.slotInterval !== this.actionObj.interval);
                if (this.isTimelineDayProcess) {
                    this.timelineEventModule = new TimelineEvent(this.parent, 'day');
                }
                else {
                    this.timelineEventModule = new TimelineEvent(this.parent, 'hour');
                }
            }
            if (this.parent.currentView === 'TimelineYear') {
                this.yearEvent = new YearEvent(this.parent);
            }
            if (this.parent.currentView === 'Month') {
                this.startTime = resetTime(new Date(this.startTime)).getTime();
                this.updateOriginalElement(this.actionObj.clone);
                this.monthEvent = new MonthEvent(this.parent);
            }
            if (this.parent.currentView === 'Day' || this.parent.currentView === 'Week' || this.parent.currentView === 'WorkWeek') {
                this.verticalEvent = new VerticalEvent(this.parent);
                this.verticalEvent.initializeValues();
                const splitEvents = this.splitEvent(this.actionObj.event);
                splitEvents.forEach((event) => {
                    let query = `.e-day-wrapper[data-date="${resetTime(event[this.parent.eventFields.startTime]).getTime()}"]`;
                    if (this.parent.activeViewOptions.group.resources.length > 0) {
                        query = query.concat('[data-group-index = "' + this.actionObj.groupIndex + '"]');
                    }
                    const appWrap = this.parent.element.querySelector(query);
                    if (appWrap) {
                        const appEle = appWrap.querySelector('[data-id="' + this.actionObj.clone.getAttribute('data-id') + '"]');
                        if (appEle) {
                            addClass([appEle], EVENT_ACTION_CLASS);
                        }
                    }
                });
            }
        });
    }
    getSelectedData() {
        if (this.isMultiSelect && this.multiData.length === 0 && this.parent.selectedElements.length > 0) {
            for (const element of this.parent.selectedElements) {
                const eventGuid = element.getAttribute('data-guid');
                const data = this.parent.eventBase.getEventByGuid(eventGuid);
                this.multiData.push(extend({}, data, null, true));
            }
        }
        return this.multiData;
    }
    drag(e) {
        if (this.parent.quickPopup) {
            this.parent.quickPopup.quickPopupHide(true);
        }
        if ((!isNullOrUndefined(e.target)) && e.target.classList.contains(DISABLE_DATES)) {
            return;
        }
        const eventObj = extend({}, this.actionObj.event, null, true);
        const eventArgs = this.parent.eventBase.getPageCoordinates(e);
        this.actionObj.Y = this.actionObj.pageY = eventArgs.pageY;
        this.actionObj.X = this.actionObj.pageX = eventArgs.pageX;
        this.actionObj.target = e.target;
        this.widthUptoCursorPoint = (this.widthUptoCursorPoint === 0) ?
            Math.ceil((Math.abs(this.actionObj.clone.getBoundingClientRect().left - this.actionObj.X) / this.widthPerMinute)) *
                this.widthPerMinute : this.widthUptoCursorPoint;
        this.widthUptoCursorPoint = this.isMorePopupOpened ? this.actionObj.cellWidth : this.widthUptoCursorPoint;
        this.heightUptoCursorPoint = (this.heightUptoCursorPoint === 0) ?
            Math.ceil((Math.abs(this.actionObj.clone.getBoundingClientRect().top - this.actionObj.Y) / this.heightPerMinute)) *
                this.heightPerMinute : this.heightUptoCursorPoint;
        this.isAllDayDrag = (this.parent.activeViewOptions.timeScale.enable) ?
            this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS) :
            this.actionObj.event[this.parent.eventFields.isAllDay];
        if (this.isStepDragging && this.minDiff === 0) {
            this.calculateMinutesDiff(eventObj);
        }
        if ((this.parent.currentView === 'Month' || this.isAllDayDrag) && this.daysVariation < 0) {
            const date = this.parent.getDateFromElement(this.actionObj.target);
            if (!isNullOrUndefined(date)) {
                const currentDate = resetTime(date);
                const startDate = resetTime(new Date(eventObj[this.parent.eventFields.startTime].getTime()));
                this.daysVariation = (currentDate.getTime() - startDate.getTime()) / MS_PER_DAY;
            }
            else {
                this.daysVariation = 0;
            }
        }
        else {
            this.daysVariation = 0;
        }
        if (this.parent.eventDragArea) {
            const targetElement = eventArgs.target;
            this.actionObj.clone.style.top = formatUnit(targetElement.offsetTop);
            this.actionObj.clone.style.left = formatUnit(targetElement.offsetLeft);
            const currentTarget = closest(targetElement, '.' + ROOT);
            if (!currentTarget) {
                this.actionObj.clone.style.height = '';
                this.actionObj.clone.style.width = '';
            }
            else {
                if (!(this.parent.currentView === 'Week' || this.parent.currentView === 'WorkWeek' || this.parent.currentView === 'Day')) {
                    this.actionObj.clone.style.width = formatUnit(this.actionObj.element.offsetWidth);
                }
            }
        }
        this.updateScrollPosition(e);
        this.updateNavigatingPosition(e);
        this.updateDraggingDateTime(e);
        const dragArgs = {
            data: eventObj, event: e, element: this.actionObj.element, startTime: this.actionObj.start,
            endTime: this.actionObj.end, selectedData: this.updatedData
        };
        if (this.parent.group.resources.length > 0) {
            dragArgs.groupIndex = this.actionObj.groupIndex;
        }
        this.parent.trigger(drag, dragArgs);
    }
    calculateMinutesDiff(eventObj) {
        if (this.parent.enableRtl) {
            this.minDiff =
                ((this.actionObj.clone.offsetWidth - this.widthUptoCursorPoint) / this.widthPerMinute) * this.actionObj.interval;
        }
        else {
            this.minDiff = (this.widthUptoCursorPoint / this.widthPerMinute) * this.actionObj.interval;
        }
        const startDate = eventObj[this.parent.eventFields.startTime];
        const startTime = this.parent.activeView.renderDates[0];
        const startEndHours = getStartEndHours(startTime, this.parent.activeView.getStartHour(), this.parent.activeView.getEndHour());
        if (startEndHours.startHour.getTime() > startDate.getTime()) {
            this.minDiff = this.minDiff + ((startEndHours.startHour.getTime() - startDate.getTime()) / MS_PER_MINUTE);
        }
    }
    dragStop(e) {
        this.isCursorAhead = false;
        this.removeCloneElementClasses();
        this.removeCloneElement();
        clearInterval(this.actionObj.navigationInterval);
        this.actionObj.navigationInterval = null;
        clearInterval(this.actionObj.scrollInterval);
        this.actionObj.scrollInterval = null;
        this.actionClass('removeClass');
        this.parent.uiStateValues.action = false;
        if (this.isAllowDrop(e)) {
            return;
        }
        const target = ((!e.target.classList.contains('e-work-cells') && this.parent.cellTemplate) ?
            closest(e.target, '.e-work-cells') : e.target);
        const dragArgs = {
            cancel: false, data: this.getChangedData(this.updatedData), selectedData: this.updatedData,
            event: e, element: this.actionObj.element, target: target
        };
        this.actionObj.action = null;
        this.parent.trigger(dragStop, dragArgs, (dragEventArgs) => {
            if (dragEventArgs.cancel) {
                return;
            }
            if (this.parent.isSpecificResourceEvents()) {
                this.parent.crudModule.crudObj.isCrudAction = true;
                this.parent.crudModule.crudObj.sourceEvent =
                    [this.parent.resourceBase.lastResourceLevel[parseInt(dragArgs.element.getAttribute('data-group-index'), 10)]];
                const currentGroupIndex = parseInt(dragArgs.target.getAttribute('data-group-index'), 10) || this.actionObj.groupIndex;
                this.parent.crudModule.crudObj.targetEvent =
                    [this.parent.resourceBase.lastResourceLevel[parseInt(currentGroupIndex.toString(), 10)]];
            }
            this.saveChangedData(dragEventArgs, this.isMultiSelect);
        });
        this.updatedData = [];
        this.multiData = [];
        this.isMultiSelect = false;
        this.parent.selectedElements = [];
    }
    updateNavigatingPosition(e) {
        if (this.actionObj.navigation.enable) {
            let currentDate = this.parent.getCurrentTime();
            if (isNullOrUndefined(this.actionObj.navigationInterval)) {
                this.actionObj.navigationInterval = window.setInterval(() => {
                    if (currentDate) {
                        const crtDate = this.parent.getCurrentTime();
                        const end = crtDate.getSeconds();
                        let start = currentDate.getSeconds() + (this.actionObj.navigation.timeDelay / 1000);
                        start = (start >= 60) ? start - 60 : start;
                        if (start === end) {
                            currentDate = this.parent.getCurrentTime();
                            this.viewNavigation(e);
                            this.updateDraggingDateTime(e);
                        }
                    }
                }, this.actionObj.navigation.timeDelay);
            }
        }
    }
    updateDraggingDateTime(e) {
        if (!isNullOrUndefined(this.actionObj.clone.offsetParent) &&
            this.actionObj.clone.offsetParent.classList.contains(MORE_EVENT_POPUP_CLASS)) {
            this.morePopupEventDragging(e);
        }
        else if (this.parent.activeView.isTimelineView() && this.parent.currentView !== 'TimelineYear') {
            this.timelineEventModule.dateRender = this.parent.activeView.renderDates;
            this.timelineEventModule.cellWidth = this.actionObj.cellWidth;
            this.timelineEventModule.getSlotDates();
            this.actionObj.cellWidth = this.isHeaderRows ? this.timelineEventModule.cellWidth :
                this.parent.element.querySelector('.' + WORK_CELLS_CLASS).getBoundingClientRect().width;
            this.calculateTimelineTime(e);
        }
        else {
            if (this.parent.currentView === 'Month' || this.parent.currentView === 'TimelineYear') {
                this.calculateVerticalDate(e);
            }
            else {
                this.calculateVerticalTime(e);
            }
        }
    }
    navigationWrapper() {
        if (!this.parent.activeView.isTimelineView()) {
            if (this.parent.currentView === 'Month' || !this.parent.timeScale.enable) {
                const outerWrapperCls = [].slice.call(this.parent.element.querySelectorAll('.' + WORK_CELLS_CLASS));
                this.actionObj.index = (this.parent.activeView.renderDates.length < this.actionObj.index) ?
                    this.parent.activeView.renderDates.length - 1 : this.actionObj.index;
                let targetWrapper = outerWrapperCls[this.actionObj.index].querySelector('.' + APPOINTMENT_WRAPPER_CLASS);
                if (!targetWrapper) {
                    targetWrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
                    outerWrapperCls[this.actionObj.index].appendChild(targetWrapper);
                }
                targetWrapper.appendChild(this.actionObj.clone);
            }
            else {
                const wrapperClass = this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS) ?
                    '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS : '.' + APPOINTMENT_WRAPPER_CLASS;
                this.parent.element.querySelectorAll(wrapperClass)
                    .item(this.actionObj.index).appendChild(this.actionObj.clone);
                if (wrapperClass === '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS) {
                    const elementHeight = this.getAllDayEventHeight();
                    const event = [].slice.call(this.parent.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS + ':first-child'));
                    if (event[0].offsetHeight < elementHeight) {
                        for (const e of event) {
                            e.style.height = ((elementHeight + 2) / 12) + 'em';
                        }
                    }
                    this.actionObj.clone.style.height = formatUnit(elementHeight);
                }
                this.actionObj.height = parseInt(this.actionObj.clone.style.height, 10);
            }
        }
        else {
            let outWrapper;
            if (this.parent.activeViewOptions.group.resources.length > 0) {
                outWrapper = this.parent.element.querySelectorAll('.e-appointment-container:not(.e-hidden)').item(this.actionObj.index);
            }
            else {
                outWrapper = this.parent.element.querySelector('.' + APPOINTMENT_CONTAINER_CLASS);
            }
            if (!isNullOrUndefined(outWrapper)) {
                let tarWrapper = outWrapper.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);
                if (!tarWrapper) {
                    tarWrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
                    outWrapper.appendChild(tarWrapper);
                }
                this.actionObj.cloneElement.forEach((ele) => {
                    tarWrapper.appendChild(ele);
                });
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    viewNavigation(e) {
        let navigationType;
        const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        if (dragArea && ((!this.scrollEdges.top && !this.scrollEdges.bottom) ||
            closest(this.actionObj.clone, '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS))) {
            if ((dragArea.scrollLeft === 0) &&
                (Math.round(this.actionObj.X) <=
                    Math.round(dragArea.getBoundingClientRect().left + this.actionObj.cellWidth + window.pageXOffset))) {
                navigationType = this.parent.enableRtl ? 'next' : 'previous';
            }
            else if ((Math.round(dragArea.scrollLeft) + dragArea.clientWidth === dragArea.scrollWidth) &&
                (Math.round(this.actionObj.X) >=
                    Math.round(dragArea.getBoundingClientRect().right - this.actionObj.cellWidth + window.pageXOffset))) {
                navigationType = this.parent.enableRtl ? 'previous' : 'next';
            }
            if (navigationType) {
                this.parent.changeDate(this.parent.activeView.getNextPreviousDate(navigationType));
            }
        }
    }
    morePopupEventDragging(e) {
        if (isNullOrUndefined(e.target) || (e.target && isNullOrUndefined(closest(e.target, 'td')))) {
            return;
        }
        const eventObj = extend({}, this.actionObj.event, null, true);
        const eventDuration = eventObj[this.parent.eventFields.endTime].getTime() -
            eventObj[this.parent.eventFields.startTime].getTime();
        const td = closest(e.target, 'td');
        if (this.parent.currentView === 'TimelineYear' && (!td.classList.contains(WORK_CELLS_CLASS) || td.classList.contains(OTHERMONTH_CLASS))) {
            return;
        }
        const dragStart$$1 = this.parent.getDateFromElement(td);
        const dragEnd = new Date(dragStart$$1.getTime());
        dragEnd.setMilliseconds(eventDuration);
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            this.actionObj.groupIndex = parseInt(td.getAttribute('data-group-index'), 10);
        }
        this.actionObj.start = new Date(dragStart$$1.getTime());
        this.actionObj.end = new Date(dragEnd.getTime());
        this.actionObj.clone.style.top = formatUnit(td.offsetParent.offsetTop);
        this.actionObj.clone.style.left = formatUnit(td.offsetLeft);
        this.actionObj.clone.style.width = formatUnit(td.offsetWidth);
        let eventContainer = td;
        let eventWrapper;
        if (this.parent.activeView.isTimelineView()) {
            const rowIndex = closest(td, 'tr').rowIndex;
            eventContainer = this.parent.element.querySelectorAll('.e-appointment-container').item(rowIndex);
        }
        eventWrapper = eventContainer.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);
        if (!eventWrapper) {
            eventWrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
            eventContainer.appendChild(eventWrapper);
        }
        this.appendCloneElement(eventWrapper);
    }
    calculateVerticalTime(e) {
        if (isNullOrUndefined(this.actionObj.target) ||
            (this.actionObj.target && isNullOrUndefined(closest(this.actionObj.target, 'tr'))) ||
            (!(closest(this.actionObj.target, 'td').classList.contains(WORK_CELLS_CLASS)) &&
                !(closest(this.actionObj.target, 'td').classList.contains(ALLDAY_CELLS_CLASS)))) {
            return;
        }
        if (this.parent.activeViewOptions.timeScale.enable) {
            this.swapDragging(e);
        }
        const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        const eventObj = extend({}, this.actionObj.event, null, true);
        const eventStart = eventObj[this.parent.eventFields.startTime];
        const eventEnd = eventObj[this.parent.eventFields.endTime];
        const eventDuration = getUniversalTime(eventEnd) - getUniversalTime(eventStart);
        let offsetTop = Math.floor(parseInt(this.actionObj.clone.style.top, 10) / this.actionObj.cellHeight)
            * this.actionObj.cellHeight;
        offsetTop = offsetTop < 0 ? 0 : offsetTop;
        if (this.scrollEdges.top || this.scrollEdges.bottom) {
            offsetTop = this.scrollEdges.top ? dragArea.scrollTop - this.heightUptoCursorPoint +
                this.actionObj.cellHeight + window.pageYOffset :
                (dragArea.scrollTop + dragArea.offsetHeight - this.actionObj.clone.offsetHeight + window.pageYOffset) +
                    (this.actionObj.clone.offsetHeight - this.heightUptoCursorPoint);
            offsetTop = Math.round(offsetTop / this.actionObj.cellHeight) * this.actionObj.cellHeight;
            this.actionObj.clone.style.top = formatUnit(offsetTop);
        }
        const rowIndex = (this.parent.activeViewOptions.timeScale.enable) ? (offsetTop / this.actionObj.cellHeight) : 0;
        const heightPerMinute = this.actionObj.cellHeight / this.actionObj.slotInterval;
        const diffInMinutes = parseInt(this.actionObj.clone.style.top, 10) - offsetTop;
        let tr;
        if (this.isAllDayDrag) {
            tr = this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS);
        }
        else {
            const trCollections = [].slice.call(this.parent.getContentTable().querySelectorAll('tr'));
            tr = trCollections[parseInt(rowIndex.toString(), 10)];
        }
        let index;
        if (closest(this.actionObj.target, 'td').classList.contains(WORK_CELLS_CLASS) ||
            closest(this.actionObj.target, 'td').classList.contains(ALLDAY_CELLS_CLASS)) {
            index = closest(this.actionObj.target, 'td').cellIndex;
        }
        const colIndex = isNullOrUndefined(index) ? closest(this.actionObj.clone, 'td').cellIndex : index;
        this.actionObj.index = colIndex;
        if (isNullOrUndefined(tr)) {
            return;
        }
        const td = tr.children[parseInt(colIndex.toString(), 10)];
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            this.actionObj.groupIndex = parseInt(td.getAttribute('data-group-index'), 10);
        }
        let dragStart$$1;
        let dragEnd;
        if (this.parent.activeViewOptions.timeScale.enable && !this.isAllDayDrag) {
            this.appendCloneElement(this.getEventWrapper(colIndex));
            dragStart$$1 = this.parent.getDateFromElement(td);
            dragStart$$1.setMinutes(dragStart$$1.getMinutes() + (diffInMinutes / heightPerMinute));
            dragEnd = new Date(dragStart$$1.getTime());
            if (this.actionObj.element.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {
                dragEnd.setMinutes(dragEnd.getMinutes() + this.actionObj.slotInterval);
            }
            else {
                dragEnd.setMilliseconds(eventDuration);
            }
        }
        else {
            dragStart$$1 = this.parent.getDateFromElement(td);
            dragStart$$1.setDate(dragStart$$1.getDate() - this.daysVariation);
            dragStart$$1.setHours(eventStart.getHours(), eventStart.getMinutes(), eventStart.getSeconds());
            dragEnd = new Date(dragStart$$1.getTime());
            dragEnd.setMilliseconds(eventDuration);
            if (!this.actionObj.element.classList.contains(ALLDAY_APPOINTMENT_CLASS) &&
                this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS)) {
                dragEnd = addDays(resetTime(dragEnd), 1);
            }
            const index = this.parent.activeViewOptions.group.byDate || (this.parent.virtualScrollModule &&
                !this.parent.activeViewOptions.timeScale.enable) ? colIndex : undefined;
            this.updateAllDayEvents(dragStart$$1, dragEnd, index);
        }
        this.actionObj.start = new Date(+dragStart$$1);
        this.actionObj.end = new Date(+dragEnd);
        const event = this.getUpdatedEvent(this.actionObj.start, this.actionObj.end, this.actionObj.event);
        const dynamicWrappers = [].slice.call(this.parent.element.querySelectorAll('.e-dynamic-clone'));
        for (const wrapper of dynamicWrappers) {
            remove(wrapper);
        }
        if (this.multiData.length > 0) {
            if (this.isAllDayTarget && this.isAllDayDrag && !isNullOrUndefined(this.actionObj.isAllDay) && !this.actionObj.isAllDay) {
                const targetCellTime = parseInt((closest(this.actionObj.target, 'td')).getAttribute('data-date'), 10);
                this.multiData.forEach((data) => {
                    this.swagData.push(extend({}, data, null, true));
                    if (data[this.parent.eventFields.isAllDay]) {
                        data[this.parent.eventFields.startTime] =
                            new Date(data[this.parent.eventFields.startTime].getTime() + (targetCellTime - this.startTime));
                        const startTime = new Date(data[this.parent.eventFields.startTime]);
                        const endTime = new Date(startTime.setMinutes(startTime.getMinutes() + this.actionObj.slotInterval));
                        data[this.parent.eventFields.endTime] = endTime;
                        data[this.parent.eventFields.isAllDay] = false;
                    }
                });
                this.startTime = targetCellTime;
            }
            if (this.isAllDayTarget && this.isAllDayDrag &&
                !isNullOrUndefined(this.actionObj.isAllDay) && this.actionObj.isAllDay && this.swagData.length > 0) {
                this.multiData = this.swagData;
                this.swagData = [];
                const eventObj = extend({}, this.actionObj.event, null, true);
                this.startTime = eventObj[this.parent.eventFields.startTime].getTime();
            }
            const startTimeDiff = event[this.parent.eventFields.startTime].getTime() - this.startTime;
            for (let index = 0; index < this.multiData.length; index++) {
                this.updatedData[parseInt(index.toString(), 10)] =
                    this.updateMultipleData(this.multiData[parseInt(index.toString(), 10)], startTimeDiff);
                const dayIndex = this.getDayIndex(this.updatedData[parseInt(index.toString(), 10)]);
                if (dayIndex >= 0) {
                    const wrapper = this.getEventWrapper(dayIndex, this.updatedData[parseInt(index.toString(), 10)][this.parent.eventFields.isAllDay]);
                    this.appendCloneElement(wrapper, this.actionObj.cloneElement[parseInt(index.toString(), 10)]);
                    this.updateEventHeight(this.updatedData[parseInt(index.toString(), 10)], index, dayIndex);
                }
                else {
                    if (!isNullOrUndefined(this.actionObj.cloneElement[parseInt(index.toString(), 10)].parentNode)) {
                        remove(this.actionObj.cloneElement[parseInt(index.toString(), 10)]);
                    }
                }
            }
        }
        else {
            this.updateEventHeight(event);
        }
        this.updateTimePosition(this.actionObj.start, this.updatedData);
    }
    splitEvent(event) {
        const eventFields = this.parent.eventFields;
        const eventData = [];
        const startTime = event[eventFields.startTime];
        const endTime = event[eventFields.endTime];
        if (resetTime(new Date(startTime.getTime())) < resetTime(new Date(endTime.getTime()))) {
            let startReferenceDate = resetTime(new Date(startTime.getTime()));
            let endReferenceDate = new Date(startReferenceDate.getTime());
            for (let i = 0; startReferenceDate < new Date(endTime.getTime()); i++) {
                endReferenceDate = new Date(endReferenceDate.setDate(startReferenceDate.getDate() + 1));
                const eventObj = extend({}, event, null, true);
                eventObj[eventFields.startTime] = new Date(startReferenceDate);
                eventObj[eventFields.endTime] = new Date(endReferenceDate);
                startReferenceDate = new Date(startReferenceDate.setDate(startReferenceDate.getDate() + 1));
                eventData.push(eventObj);
            }
            const index = eventData.length - 1;
            eventData[0][eventFields.startTime] = startTime;
            eventData[parseInt(index.toString(), 10)][eventFields.endTime] = endTime;
        }
        else {
            eventData.push(event);
        }
        return eventData;
    }
    updateMultipleData(data, timeDifference) {
        const eventObj = extend({}, data, null, true);
        if (!isNullOrUndefined(this.actionObj.isAllDay) && this.parent.activeViewOptions.timeScale.enable &&
            ((this.isAllDayTarget && eventObj[this.parent.eventFields.isAllDay]) ||
                (!this.isAllDayTarget && !eventObj[this.parent.eventFields.isAllDay]))) {
            eventObj[this.parent.eventFields.isAllDay] = this.actionObj.isAllDay;
        }
        const endTimeDiff = eventObj[this.parent.eventFields.endTime].getTime() -
            eventObj[this.parent.eventFields.startTime].getTime();
        if (eventObj[this.parent.eventFields.isAllDay]) {
            const differInDays = Math.ceil(timeDifference / (1000 * 3600 * 24));
            const day = Math.ceil(endTimeDiff / (1000 * 3600 * 24));
            const startTime = new Date(eventObj[this.parent.eventFields.startTime]);
            eventObj[this.parent.eventFields.startTime] = resetTime(new Date(startTime.setDate(startTime.getDate() + differInDays)));
            eventObj[this.parent.eventFields.endTime] = addDays(eventObj[this.parent.eventFields.startTime], day);
        }
        else {
            eventObj[this.parent.eventFields.startTime] =
                new Date(eventObj[this.parent.eventFields.startTime].getTime() + timeDifference);
            eventObj[this.parent.eventFields.endTime] =
                new Date(eventObj[this.parent.eventFields.startTime].getTime() + endTimeDiff);
        }
        return eventObj;
    }
    getDayIndex(event) {
        const eventObj = extend({}, event, null, true);
        const startDate = resetTime(eventObj[this.parent.eventFields.startTime]);
        if (this.parent.activeViewOptions.timeScale.enable && !eventObj[this.parent.eventFields.isAllDay]) {
            const startHour = this.parent.activeView.getStartHour();
            startDate.setMilliseconds(startHour.getTime() - resetTime(startHour).getTime());
        }
        const startTime = startDate.getTime();
        let query = '';
        let wrapper = DAY_WRAPPER_CLASS;
        if (this.parent.activeViewOptions.timeScale.enable && (eventObj[this.parent.eventFields.isAllDay])) {
            wrapper = ALLDAY_APPOINTMENT_WRAPPER_CLASS;
        }
        else {
            wrapper = WORK_CELLS_CLASS;
        }
        query = '.' + wrapper + '[data-date="' + startTime + '"]';
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            query = query + '[data-group-index="' + this.actionObj.groupIndex + '"]';
        }
        this.targetTd = this.parent.element.querySelector(query);
        if (isNullOrUndefined(this.targetTd)) {
            return -1;
        }
        return this.targetTd.cellIndex;
    }
    updateEventHeight(event, index, colIndex) {
        this.verticalEvent.initializeValues();
        let datesCount = this.verticalEvent.getStartCount();
        if (!this.parent.uiStateValues.isGroupAdaptive) {
            for (let i = 0; i < this.actionObj.groupIndex; i++) {
                if (this.verticalEvent.dateRender[parseInt(i.toString(), 10)]) {
                    datesCount = datesCount + this.verticalEvent.dateRender[parseInt(i.toString(), 10)].length;
                }
            }
        }
        const indexGroup = this.parent.uiStateValues.isGroupAdaptive ? datesCount : this.actionObj.groupIndex;
        const target = (this.parent.activeViewOptions.group.byDate &&
            !isNullOrUndefined(this.parent.getDateFromElement(this.actionObj.target))) ? true : false;
        if (target || !this.parent.activeViewOptions.group.byDate) {
            let dynamicIndex = -1;
            let dayIndex = !this.parent.activeViewOptions.group.byDate ?
                isNullOrUndefined(index) ? this.actionObj.index - datesCount : colIndex - datesCount
                : this.parent.getIndexOfDate(this.verticalEvent.dateRender[parseInt(indexGroup.toString(), 10)], resetTime(
                // eslint-disable-next-line max-len
                this.parent.getDateFromElement(isNullOrUndefined(index) ? this.actionObj.target : this.targetTd)));
            const splitEvents = this.splitEvent(event);
            const events = this.parent.eventBase.isAllDayAppointment(event) || splitEvents.length > 2 ||
                this.parent.eventSettings.spannedEventPlacement !== 'TimeSlot' ? [event] : splitEvents;
            for (let i = 0; i < events.length; i++) {
                if (i > 0) {
                    let filterQuery = `.e-day-wrapper[data-date="${resetTime(events[parseInt(i.toString(), 10)][this.parent.eventFields.startTime]).getTime()}"]`;
                    if (this.parent.activeViewOptions.group.resources.length > 0) {
                        filterQuery = filterQuery.concat('[data-group-index = "' + this.actionObj.groupIndex + '"]');
                    }
                    const appWrap = this.parent.element.querySelector(filterQuery);
                    if (appWrap) {
                        dayIndex = dayIndex + 1;
                        dynamicIndex = appWrap.cellIndex;
                    }
                    else {
                        dayIndex = -1;
                    }
                }
                if (dayIndex >= 0) {
                    const record = this.verticalEvent.isSpannedEvent(events[parseInt(i.toString(), 10)], dayIndex, indexGroup);
                    const eStart = record[this.verticalEvent.fields.startTime];
                    const eEnd = record[this.verticalEvent.fields.endTime];
                    let appHeight = this.parent.activeViewOptions.timeScale.enable ? this.verticalEvent.getHeight(eStart, eEnd) :
                        this.actionObj.element.offsetHeight;
                    let topValue = this.parent.activeViewOptions.timeScale.enable ?
                        this.verticalEvent.getTopValue(eStart, dayIndex, indexGroup) : this.actionObj.element.offsetTop;
                    if (isNullOrUndefined(index)) {
                        if (i === 0) {
                            this.actionObj.clone.style.top = formatUnit(topValue);
                            this.actionObj.clone.style.height = formatUnit(appHeight);
                        }
                        else {
                            this.renderSpannedEvents(record, dynamicIndex, topValue, appHeight);
                        }
                    }
                    else {
                        let appWidth = this.actionObj.cellWidth;
                        if (event[this.parent.eventFields.isAllDay]) {
                            topValue = this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS).offsetTop;
                            appHeight = this.getAllDayEventHeight();
                            const timeDiff = event[this.parent.eventFields.endTime].getTime() -
                                event[this.parent.eventFields.startTime].getTime();
                            const allDayDifference = Math.ceil(timeDiff / (1000 * 3600 * 24));
                            if (allDayDifference >= 0) {
                                appWidth = (allDayDifference * this.actionObj.cellWidth);
                            }
                        }
                        if (this.actionObj.cloneElement[parseInt(index.toString(), 10)]) {
                            if (i === 0) {
                                this.actionObj.cloneElement[parseInt(index.toString(), 10)].style.top = formatUnit(topValue);
                                this.actionObj.cloneElement[parseInt(index.toString(), 10)].style.height = formatUnit(appHeight);
                                this.actionObj.cloneElement[parseInt(index.toString(), 10)].style.width = formatUnit(appWidth);
                                this.actionObj.cloneElement[parseInt(index.toString(), 10)].style.left = formatUnit(0);
                            }
                            else {
                                this.renderSpannedEvents(record, dynamicIndex, topValue, appHeight);
                            }
                        }
                    }
                }
            }
        }
    }
    renderSpannedEvents(record, index, top, height) {
        const startTime = record[this.parent.eventFields.startTime].getTime();
        const endTime = record[this.parent.eventFields.endTime].getTime();
        if (startTime !== endTime) {
            const appointmentElement = this.verticalEvent.
                createAppointmentElement(record, false, record.isSpanned, this.actionObj.groupIndex);
            addClass([appointmentElement], [CLONE_ELEMENT_CLASS, 'e-dynamic-clone']);
            setStyleAttribute(appointmentElement, {
                'width': '100%',
                'height': height + 'px',
                'top': top + 'px',
                'border': '0px'
            });
            const appointmentWrap = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_WRAPPER_CLASS));
            appointmentWrap[parseInt(index.toString(), 10)].appendChild(appointmentElement);
        }
    }
    getRenderedDates() {
        let renderDates = this.parent.activeView.renderDates;
        this.parent.eventBase.slots.push(...this.parent.activeView.renderDates.map((date) => +date));
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            this.parent.eventBase.slots = [];
            const resources = this.parent.resourceBase.lastResourceLevel.
                filter((res) => res.groupIndex === this.actionObj.groupIndex);
            renderDates = resources[0].renderDates;
            this.parent.eventBase.slots.push(...renderDates.map((date) => +date));
        }
        return renderDates;
    }
    updateAllDayEvents(startDate, endDate, colIndex) {
        this.parent.eventBase.slots = [];
        const event = this.getUpdatedEvent(startDate, endDate, this.actionObj.event);
        const renderDates = this.getRenderedDates();
        const events = this.parent.eventBase.splitEvent(event, renderDates);
        let query = `.e-all-day-cells[data-date="${events[0][this.parent.eventFields.startTime].getTime()}"]`;
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            query = query.concat('[data-group-index = "' + this.actionObj.groupIndex + '"]');
        }
        const cell = [].slice.call(this.parent.element.querySelectorAll(query));
        if (cell.length > 0 || !isNullOrUndefined(colIndex)) {
            const cellIndex = !isNullOrUndefined(colIndex) ? colIndex : cell[0].cellIndex;
            this.appendCloneElement(this.getEventWrapper(cellIndex));
            // eslint-disable-next-line max-len
            this.actionObj.clone.style.width = formatUnit(events[0].data.count * this.actionObj.cellWidth);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    swapDragging(e) {
        const colIndex = closest(this.actionObj.target, 'td').cellIndex;
        if (closest(this.actionObj.target, '.' + DATE_HEADER_WRAP_CLASS) &&
            !closest(this.actionObj.clone, '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS)) {
            addClass([this.actionObj.clone], ALLDAY_APPOINTMENT_CLASS);
            this.appendCloneElement(this.getEventWrapper(colIndex));
            this.actionObj.isAllDay = true;
            const eventHeight = this.getAllDayEventHeight();
            const allDayElement = [].slice.call(this.parent.element.querySelectorAll('.' + ALLDAY_CELLS_CLASS + ':first-child'));
            if (allDayElement[0].offsetHeight < eventHeight) {
                for (const element of allDayElement) {
                    element.style.height = ((eventHeight + 2) / 12) + 'em';
                }
            }
            setStyleAttribute(this.actionObj.clone, {
                width: formatUnit(this.actionObj.cellWidth),
                height: formatUnit(eventHeight),
                top: formatUnit(this.parent.element.querySelector('.' + ALLDAY_ROW_CLASS).offsetTop)
            });
        }
        if (closest(this.actionObj.target, '.' + WORK_CELLS_CLASS) &&
            !closest(this.actionObj.clone, '.' + DAY_WRAPPER_CLASS)) {
            removeClass([this.actionObj.clone], ALLDAY_APPOINTMENT_CLASS);
            this.appendCloneElement(this.getEventWrapper(colIndex));
            this.actionObj.isAllDay = false;
            // eslint-disable-next-line max-len
            const height = (this.actionObj.element.offsetHeight === 0) ? this.actionObj.height : this.actionObj.element.offsetHeight;
            setStyleAttribute(this.actionObj.clone, {
                left: formatUnit(0),
                height: formatUnit(height),
                width: formatUnit(this.actionObj.cellWidth)
            });
        }
    }
    calculateVerticalDate(e) {
        if (isNullOrUndefined(e.target) || (e.target && isNullOrUndefined(closest(e.target, 'tr'))) ||
            (e.target && e.target.tagName === 'DIV')) {
            return;
        }
        const eventObj = extend({}, this.actionObj.event, null, true);
        if (isNullOrUndefined(this.parent.eventDragArea)) {
            this.removeCloneElement();
        }
        const eventDuration = getUniversalTime(eventObj[this.parent.eventFields.endTime]) -
            getUniversalTime(eventObj[this.parent.eventFields.startTime]);
        let td = closest(this.actionObj.target, 'td');
        if (!isNullOrUndefined(td)) {
            const tr = td.parentElement;
            this.actionObj.index = (tr.rowIndex * tr.children.length) + td.cellIndex;
            const workCells = [].slice.call(this.parent.element.querySelectorAll('.' + WORK_CELLS_CLASS));
            td = workCells[this.actionObj.index];
            const currentDate = this.parent.getDateFromElement(td);
            if (!isNullOrUndefined(currentDate)) {
                if (this.parent.activeViewOptions.group.resources.length > 0) {
                    this.actionObj.groupIndex = parseInt(td.getAttribute('data-group-index'), 10);
                }
                const timeString = new Date(currentDate.setDate(currentDate.getDate() - this.daysVariation));
                const dragStart$$1 = new Date(timeString.getTime());
                const startTimeDiff = getUniversalTime(eventObj[this.parent.eventFields.startTime]) -
                    getUniversalTime(resetTime(new Date(+eventObj[this.parent.eventFields.startTime])));
                dragStart$$1.setMilliseconds(startTimeDiff);
                const dragEnd = new Date(dragStart$$1.getTime());
                dragEnd.setMilliseconds(eventDuration);
                this.actionObj.start = new Date(dragStart$$1.getTime());
                this.actionObj.end = new Date(dragEnd.getTime());
            }
        }
        const event = this.getUpdatedEvent(this.actionObj.start, this.actionObj.end, this.actionObj.event);
        const eventWrappers = [].slice.call(this.parent.element.querySelectorAll('.' + CLONE_ELEMENT_CLASS));
        for (const wrapper of eventWrappers) {
            remove(wrapper);
        }
        if (this.multiData && this.multiData.length > 0) {
            const startTime = resetTime(new Date(event[this.parent.eventFields.startTime]));
            let startTimeDiff = startTime.getTime() - this.startTime;
            if (this.parent.currentView === 'TimelineYear' && this.parent.group.resources.length > 0) {
                startTimeDiff = (startTime.getFullYear() - new Date(this.startTime).getFullYear()) * 12;
                startTimeDiff -= new Date(this.startTime).getMonth();
                startTimeDiff += startTime.getMonth();
            }
            for (let index = 0; index < this.multiData.length; index++) {
                this.updatedData[parseInt(index.toString(), 10)] =
                    this.updateMultipleVerticalDate(this.multiData[parseInt(index.toString(), 10)], startTimeDiff);
                if (this.parent.currentView === 'TimelineYear') {
                    this.dynamicYearlyEventsRendering(this.updatedData[parseInt(index.toString(), 10)]);
                }
                else {
                    this.dynamicEventsRendering(this.updatedData[parseInt(index.toString(), 10)]);
                }
            }
        }
        else {
            if (this.parent.currentView === 'TimelineYear') {
                this.dynamicYearlyEventsRendering(event);
            }
            else {
                this.dynamicEventsRendering(event);
            }
        }
    }
    updateMultipleVerticalDate(data, timeDifference) {
        const eventObj = extend({}, data, null, true);
        const eventDuration = eventObj[this.parent.eventFields.endTime].getTime() -
            eventObj[this.parent.eventFields.startTime].getTime();
        const startDate = new Date(eventObj[this.parent.eventFields.startTime]);
        if (this.parent.currentView === 'TimelineYear' && this.parent.group.resources.length > 0) {
            eventObj[this.parent.eventFields.startTime] = new Date(startDate.setMonth(startDate.getMonth() + timeDifference));
        }
        else {
            const differInDays = Math.ceil(timeDifference / MS_PER_DAY);
            eventObj[this.parent.eventFields.startTime] = new Date(startDate.setDate(startDate.getDate() + differInDays));
        }
        eventObj[this.parent.eventFields.endTime] =
            new Date(eventObj[this.parent.eventFields.startTime].getTime() + eventDuration);
        return eventObj;
    }
    calculateTimelineTime(e) {
        const eventObj = extend({}, this.actionObj.event, null, true);
        const eventDuration = getUniversalTime(eventObj[this.parent.eventFields.endTime]) -
            getUniversalTime(eventObj[this.parent.eventFields.startTime]);
        let offsetLeft = this.parent.enableRtl ? Math.abs(this.actionObj.clone.offsetLeft) - this.actionObj.clone.offsetWidth :
            parseInt(this.actionObj.clone.style.left, 10);
        offsetLeft = Math.floor(offsetLeft / Math.trunc(this.actionObj.cellWidth)) * this.actionObj.cellWidth;
        let rightOffset;
        if (this.parent.enableRtl) {
            rightOffset = Math.abs(parseInt(this.actionObj.clone.style.right, 10));
            this.actionObj.clone.style.right = formatUnit(rightOffset);
        }
        offsetLeft = this.getOffsetValue(offsetLeft, rightOffset);
        const colIndex = this.getColumnIndex(offsetLeft);
        const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        const contentWrapRight = dragArea.getBoundingClientRect().right;
        const cursorDrag = this.parent.activeView.isTimelineView() && !this.parent.enableRtl &&
            this.actionObj.pageX > this.actionObj.clone.getBoundingClientRect().right &&
            !this.isMorePopupOpened && !(this.actionObj.pageX > contentWrapRight);
        const leftVal = (this.parent.eventDragArea) ? dragArea.scrollLeft - dragArea.offsetLeft : 0;
        if ((this.isCursorAhead || cursorDrag) && !this.isStepDragging) {
            this.isCursorAhead = true;
        }
        let cloneIndex = Math.floor((this.actionObj.pageX - this.actionObj.clone.getBoundingClientRect().left + leftVal) / this.actionObj.cellWidth);
        if (this.parent.enableRtl) {
            cloneIndex = Math.abs(Math.floor((this.actionObj.pageX - this.actionObj.clone.getBoundingClientRect().right) /
                this.actionObj.cellWidth)) - 1;
        }
        if (this.cursorPointIndex < 0) {
            this.cursorIndex(e, eventObj, offsetLeft, cloneIndex);
        }
        const tr = this.parent.getContentTable().querySelector('tr');
        let index = this.getCursorCurrentIndex(colIndex, cloneIndex, tr);
        index = index < 0 ? 0 : index;
        let eventStart = this.isHeaderRows ? new Date(this.timelineEventModule.dateRender[parseInt(index.toString(), 10)].getTime()) :
            this.parent.getDateFromElement(tr.children[parseInt(index.toString(), 10)]);
        if (this.isStepDragging) {
            const widthDiff = this.getWidthDiff(tr, index);
            if (widthDiff !== 0) {
                const timeDiff = Math.round(widthDiff / this.widthPerMinute);
                eventStart.setMinutes(eventStart.getMinutes() + (timeDiff * this.actionObj.interval));
                if (this.isCursorAhead || cursorDrag) {
                    eventStart.setMilliseconds(-(eventDuration));
                }
                else {
                    eventStart.setMinutes(eventStart.getMinutes() - this.minDiff);
                }
            }
            else {
                eventStart = this.actionObj.start;
            }
        }
        else {
            if (this.isCursorAhead || cursorDrag) {
                eventStart.setMinutes(eventStart.getMinutes() +
                    (this.isTimelineDayProcess ? MINUTES_PER_DAY : this.actionObj.slotInterval));
                eventStart.setMilliseconds(-(eventDuration));
            }
            else {
                eventStart.setMinutes(eventStart.getMinutes() -
                    (this.cursorPointIndex * (this.isTimelineDayProcess ? MINUTES_PER_DAY : this.actionObj.slotInterval)));
            }
        }
        eventStart = this.calculateIntervalTime(eventStart);
        if (this.isTimelineDayProcess) {
            const eventSrt = eventObj[this.parent.eventFields.startTime];
            eventStart.setHours(eventSrt.getHours(), eventSrt.getMinutes(), eventSrt.getSeconds());
        }
        if (this.parent.eventDragArea) {
            const targetDate = this.parent.getDateFromElement(e.target);
            if (!isNullOrUndefined(targetDate)) {
                if (!this.parent.activeViewOptions.timeScale.enable || (this.parent.currentView === 'TimelineMonth')) {
                    const eventSrt = eventObj[this.parent.eventFields.startTime];
                    eventStart = new Date(targetDate.setHours(eventSrt.getHours(), eventSrt.getMinutes(), eventSrt.getSeconds()));
                }
                else {
                    eventStart = targetDate;
                }
            }
        }
        const eventEnd = new Date(eventStart.getTime());
        eventEnd.setMilliseconds(eventDuration);
        let eventsData = [this.getUpdatedEvent(eventStart, eventEnd, this.actionObj.event)];
        if (this.multiData.length > 0) {
            const startTimeDiff = eventsData[0][this.parent.eventFields.startTime].getTime() - this.startTime;
            for (let i = 0; i < this.multiData.length; i++) {
                this.updatedData[parseInt(i.toString(), 10)] =
                    this.updateMultipleData(this.multiData[parseInt(i.toString(), 10)], startTimeDiff);
            }
            eventsData = this.updatedData;
        }
        for (let dataIndex = 0; dataIndex < eventsData.length; dataIndex++) {
            const cloneElement = this.multiData.length > 0 ? this.actionObj.cloneElement[parseInt(dataIndex.toString(), 10)] : this.actionObj.clone;
            if (isNullOrUndefined(this.parent.eventDragArea)) {
                const events = this.timelineEventModule.splitEvent(eventsData[parseInt(dataIndex.toString(), 10)], this.timelineEventModule.dateRender);
                const eventData = events[0].data;
                const startTime = this.timelineEventModule.getStartTime(events[0], eventData);
                const endTime = this.timelineEventModule.getEndTime(events[0], eventData);
                // eslint-disable-next-line max-len
                const width = this.timelineEventModule.getEventWidth(startTime, endTime, eventObj[this.parent.eventFields.isAllDay], eventData.count);
                // eslint-disable-next-line max-len
                let day = this.parent.getIndexOfDate(this.timelineEventModule.dateRender, resetTime(new Date(startTime.getTime())));
                day = day < 0 ? 0 : day;
                const left = this.timelineEventModule.getPosition(startTime, endTime, eventObj[this.parent.eventFields.isAllDay], day);
                if (this.parent.enableRtl) {
                    cloneElement.style.right = formatUnit(left);
                }
                else {
                    cloneElement.style.left = formatUnit(left);
                }
                if (!this.isMorePopupOpened) {
                    cloneElement.style.width = formatUnit(width);
                }
            }
            if (this.parent.activeViewOptions.group.resources.length > 0) {
                this.calculateResourceGroupingPosition(e, cloneElement);
            }
            this.actionObj.start = new Date(eventStart.getTime());
            this.actionObj.end = new Date(eventEnd.getTime());
            this.updateTimePosition(this.actionObj.start, this.updatedData);
        }
    }
    getOffsetValue(offsetLeft, rightOffset) {
        if (this.scrollEdges.left || this.scrollEdges.right) {
            const viewEle = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
            if (this.parent.enableRtl) {
                rightOffset = viewEle.offsetWidth - viewEle.scrollLeft;
                if (this.scrollEdges.right) {
                    rightOffset = (rightOffset - viewEle.offsetWidth + this.actionObj.clone.offsetWidth) -
                        (this.actionObj.clone.offsetWidth - this.widthUptoCursorPoint);
                }
                else {
                    rightOffset = rightOffset + this.widthUptoCursorPoint;
                    if (rightOffset - this.widthUptoCursorPoint >= viewEle.scrollWidth) {
                        this.actionObj.clone.style.width =
                            formatUnit(this.actionObj.clone.offsetWidth - this.widthUptoCursorPoint + this.actionObj.cellWidth);
                        rightOffset = (viewEle.scrollLeft - viewEle.scrollWidth);
                    }
                }
                if (isNullOrUndefined(this.parent.eventDragArea)) {
                    this.actionObj.clone.style.left = formatUnit(rightOffset);
                }
            }
            else {
                if (this.scrollEdges.left) {
                    offsetLeft = viewEle.scrollLeft - this.widthUptoCursorPoint + this.actionObj.cellWidth;
                    if (viewEle.scrollLeft + viewEle.offsetWidth >= viewEle.offsetWidth) {
                        viewEle.scrollLeft = viewEle.scrollLeft - 1;
                    }
                    else if (this.actionObj.clone.offsetLeft === 0) {
                        offsetLeft = viewEle.scrollLeft;
                    }
                }
                else {
                    offsetLeft = (viewEle.scrollLeft + viewEle.offsetWidth -
                        this.actionObj.clone.offsetWidth) + (this.actionObj.clone.offsetWidth - this.widthUptoCursorPoint);
                }
                offsetLeft = offsetLeft < 0 ? 0 : offsetLeft;
                if (isNullOrUndefined(this.parent.eventDragArea)) {
                    this.actionObj.clone.style.left = formatUnit(offsetLeft);
                }
            }
        }
        return offsetLeft;
    }
    getWidthDiff(tr, index) {
        const pages = this.scrollArgs.element.getBoundingClientRect();
        if (pages.left <= this.actionObj.pageX && pages.right >= this.actionObj.pageX) {
            const targetLeft = tr.children[parseInt(index.toString(), 10)].offsetLeft;
            const pageX = this.actionObj.pageX - pages.left;
            if (this.parent.enableRtl) {
                return (targetLeft + this.actionObj.cellWidth) - (this.scrollArgs.element.scrollLeft + pageX);
            }
            else {
                return (this.scrollArgs.element.scrollLeft + pageX) - targetLeft;
            }
        }
        return 0;
    }
    getColumnIndex(offsetLeft) {
        const index = Math.floor(offsetLeft / Math.trunc(this.actionObj.cellWidth));
        if (this.isHeaderRows) {
            return index;
        }
        return this.getIndex(index);
    }
    getCursorCurrentIndex(colIndex, cloneIndex, tr) {
        const index = colIndex + cloneIndex;
        if (this.isHeaderRows) {
            const dateLength = Math.floor(tr.offsetWidth / this.actionObj.cellWidth);
            return (index > dateLength - 1) ? dateLength - 1 : index;
        }
        return (index > tr.children.length - 1) ? tr.children.length - 1 : index;
    }
    cursorIndex(e, event, left, index) {
        const td = closest(e.target, '.e-work-cells');
        if (!isNullOrUndefined(td) && !this.isMorePopupOpened) {
            let targetDate = this.parent.getDateFromElement(td);
            if (this.isHeaderRows) {
                const currentIndex = Math.floor(left / this.actionObj.cellWidth);
                targetDate = new Date(this.timelineEventModule.dateRender[currentIndex + index].getTime());
            }
            const timeDiff = targetDate.getTime() - event[this.parent.eventFields.startTime].getTime();
            if (this.isTimelineDayProcess) {
                this.cursorPointIndex = Math.abs(Math.ceil(timeDiff / (MS_PER_DAY)));
            }
            else {
                const widthDiff = Math.floor((timeDiff / MS_PER_MINUTE) / (this.actionObj.slotInterval / this.actionObj.cellWidth));
                this.cursorPointIndex = Math.floor(widthDiff / this.actionObj.cellWidth);
                this.cursorPointIndex = this.cursorPointIndex < 0 ? 0 : this.cursorPointIndex;
            }
        }
        else {
            this.cursorPointIndex = 0;
        }
    }
    calculateResourceGroupingPosition(e, cloneElement) {
        const dragArea = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS);
        const trCollection = [].slice.call(this.parent.element.querySelectorAll('.e-content-wrap .e-content-table tr:not(.e-hidden)'));
        let translateY = getTranslateY(dragArea.querySelector('table'));
        translateY = (isNullOrUndefined(translateY)) ? 0 : translateY;
        const rowHeight = (this.parent.rowAutoHeight) ?
            ~~(dragArea.querySelector('table').offsetHeight / trCollection.length) : this.actionObj.cellHeight;
        let rowIndex = Math.floor(Math.floor((this.actionObj.Y +
            (dragArea.scrollTop - translateY - (window.scrollY || window.pageYOffset))) -
            dragArea.getBoundingClientRect().top) / rowHeight);
        rowIndex = (rowIndex < 0) ? 0 : (rowIndex > trCollection.length - 1) ? trCollection.length - 1 : rowIndex;
        this.actionObj.index = rowIndex;
        const eventContainer = this.parent.element.querySelectorAll('.e-appointment-container:not(.e-hidden)').item(rowIndex);
        let eventWrapper = eventContainer.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);
        if (!eventWrapper) {
            eventWrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
            eventContainer.appendChild(eventWrapper);
        }
        this.appendCloneElement(eventWrapper, cloneElement);
        const td = closest(this.actionObj.target, 'td');
        this.actionObj.groupIndex = (td && !isNaN(parseInt(td.getAttribute('data-group-index'), 10)))
            ? parseInt(td.getAttribute('data-group-index'), 10) : this.actionObj.groupIndex;
        if (!isNullOrUndefined(this.parent.eventDragArea)) {
            return;
        }
        let top = trCollection[parseInt(rowIndex.toString(), 10)].getBoundingClientRect().height * rowIndex;
        if (this.parent.rowAutoHeight) {
            const cursorElement = this.getCursorElement(e);
            if (cursorElement) {
                top = cursorElement.classList.contains(WORK_CELLS_CLASS) ? cursorElement.offsetTop :
                    (cursorElement.offsetParent && cursorElement.offsetParent.classList.contains(APPOINTMENT_CLASS)) ?
                        cursorElement.offsetParent.offsetTop : top;
            }
        }
        cloneElement.style.top = formatUnit(top);
    }
    appendCloneElement(element, cloneElement = null) {
        cloneElement = isNullOrUndefined(cloneElement) ? this.actionObj.clone : cloneElement;
        const dragElement = document.querySelector(this.parent.eventDragArea);
        if (this.parent.eventDragArea && dragElement) {
            dragElement.appendChild(cloneElement);
        }
        else {
            element.appendChild(cloneElement);
        }
    }
    getEventWrapper(index, isAllDayDrag) {
        let eventWrapper;
        if (isNullOrUndefined(isAllDayDrag)) {
            isAllDayDrag = this.actionObj.clone.classList.contains(ALLDAY_APPOINTMENT_CLASS);
        }
        if (this.parent.activeViewOptions.timeScale.enable) {
            const wrapperClass = isAllDayDrag ? '.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS : '.' + APPOINTMENT_WRAPPER_CLASS;
            eventWrapper = this.parent.element.querySelectorAll(wrapperClass).item(index);
        }
        else {
            const targetWrapper = this.parent.element.querySelectorAll('.' + WORK_CELLS_CLASS).item(index);
            eventWrapper = targetWrapper.querySelector('.' + APPOINTMENT_WRAPPER_CLASS);
            if (!eventWrapper) {
                eventWrapper = createElement('div', { className: APPOINTMENT_WRAPPER_CLASS });
                targetWrapper.appendChild(eventWrapper);
            }
        }
        return eventWrapper;
    }
    getAllDayEventHeight() {
        const eventWrapper = createElement('div', { className: APPOINTMENT_CLASS });
        this.parent.element.querySelector('.' + ALLDAY_APPOINTMENT_WRAPPER_CLASS).appendChild(eventWrapper);
        const eventHeight = eventWrapper.offsetHeight;
        remove(eventWrapper);
        return eventHeight;
    }
    isAllowDrop(e) {
        if (!this.actionObj.excludeSelectors) {
            return false;
        }
        const dropSelectors = this.actionObj.excludeSelectors.split(',');
        let isAllowDrop = false;
        for (const selector of dropSelectors) {
            if (e.target.classList.contains(selector)) {
                isAllowDrop = true;
                break;
            }
        }
        return isAllowDrop;
    }
    /**
     * Get module name.
     *
     * @returns {string} Returns the module name
     */
    getModuleName() {
        return 'dragAndDrop';
    }
}

/**
 * view base
 */
class ViewBase {
    /**
     * Constructor
     *
     * @param {Schedule} parent Accepts the schedule instance
     */
    constructor(parent) {
        this.previousNextAction = 'next';
        this.parent = parent;
    }
    isTimelineView() {
        return this.parent.currentView.indexOf('Timeline') !== -1;
    }
    getContentRows() {
        return [];
    }
    refreshHeader() {
        // Method to refresh the date header
    }
    refreshResourceHeader() {
        remove(this.element.querySelector('tbody').lastElementChild.firstElementChild);
        const resTd = createElement('td');
        resTd.appendChild(this.parent.resourceBase.createResourceColumn());
        prepend([resTd], this.element.querySelector('tbody').lastElementChild);
        this.parent.notify(contentReady, {});
    }
    getDayName(date) {
        return this.parent.getDayNames('abbreviated')[date.getDay()];
    }
    getDate(date) {
        return this.parent.globalize.formatDate(date, { format: 'd', calendar: this.parent.getCalendarMode() });
    }
    getTime(date) {
        if (this.parent.isAdaptive) {
            if (this.parent.activeViewOptions.timeFormat === 'HH:mm' || this.parent.activeViewOptions.timeFormat === 'HH.mm') {
                return this.parent.globalize.formatDate(date, { format: 'H', calendar: this.parent.getCalendarMode() });
            }
            return this.parent.globalize.formatDate(date, { skeleton: 'h', calendar: this.parent.getCalendarMode() });
        }
        return this.parent.getTimeString(date);
    }
    getTimelineDate(date) {
        const text = this.parent.globalize.formatDate(date, { skeleton: 'MMMd', calendar: this.parent.getCalendarMode() }) + ', ' +
            this.parent.getDayNames('wide')[date.getDay()];
        return capitalizeFirstWord(text, 'multiple');
    }
    createEventTable(trCount) {
        const eventTable = createElement('div', { className: EVENT_TABLE_CLASS });
        append(this.getEventRows(trCount), eventTable);
        return eventTable;
    }
    getEventRows(trCount) {
        const eventRows = [];
        let eventContainer;
        for (let row = 0; row < trCount; row++) {
            eventContainer = createElement('div', { className: APPOINTMENT_CONTAINER_CLASS });
            if (this.parent.resourceBase && !this.parent.uiStateValues.isGroupAdaptive && this.parent.resourceBase.renderedResources) {
                eventContainer.setAttribute('data-group-index', this.parent.resourceBase.renderedResources[parseInt(row.toString(), 10)].groupIndex.toString());
            }
            eventRows.push(eventContainer);
        }
        return eventRows;
    }
    collapseRows(wrap) {
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            this.parent.resourceBase.hideResourceRows(wrap.querySelector('tbody'));
            this.parent.resourceBase.hideResourceRows(wrap.querySelector('.' + EVENT_TABLE_CLASS));
        }
    }
    createTableLayout(className) {
        const clsName = className || '';
        const table = createElement('table', { className: SCHEDULE_TABLE_CLASS + ' ' + clsName });
        const tbody = createElement('tbody');
        table.appendChild(tbody);
        return table;
    }
    setAriaAttributes(table) {
        table.setAttribute('role', 'grid');
        table.setAttribute('aria-label', this.getLabelText(this.parent.currentView));
    }
    createColGroup(table, lastRow) {
        let length = lastRow.length;
        if (lastRow[0] && lastRow[0].colSpan) {
            length = lastRow.map((value) => value.colSpan).reduce((prev, next) => prev + next);
        }
        const colGroupEle = createElement('colgroup');
        for (let i = 0; i < length; i++) {
            colGroupEle.appendChild(createElement('col'));
        }
        prepend([colGroupEle], table);
    }
    getScrollXIndent(content) {
        return content.offsetHeight - content.clientHeight > 0 ? getScrollBarWidth() : 0;
    }
    scrollTopPanel(target) {
        this.getDatesHeaderElement().firstElementChild.scrollLeft = target.scrollLeft;
    }
    scrollHeaderLabels(target) {
        const headerTable = this.element.querySelector('.e-date-header-wrap table');
        const colWidth = headerTable.offsetWidth / headerTable.querySelectorAll('colgroup col').length;
        const applyLeft = (headerCells, isRtl) => {
            let currentCell;
            let tdLeft = 0;
            let colSpan = 0;
            const hiddenLeft = isRtl ? -(target.scrollLeft) : target.scrollLeft;
            for (const cell of headerCells) {
                colSpan += parseInt(cell.getAttribute('colSpan'), 10);
                if (colSpan > Math.floor(hiddenLeft / colWidth)) {
                    currentCell = cell;
                    break;
                }
                tdLeft += cell.offsetWidth;
            }
            if (!isNullOrUndefined(currentCell)) {
                currentCell.children[0].style[isRtl ? 'right' : 'left'] = (hiddenLeft - tdLeft) + 'px';
            }
        };
        const classNames = ['.e-header-year-cell', '.e-header-month-cell', '.e-header-week-cell', '.e-header-cells'];
        for (const className of classNames) {
            const headerCells = [].slice.call(this.element.querySelectorAll(className));
            if (headerCells.length > 0) {
                for (const element of headerCells) {
                    element.children[0].style[this.parent.enableRtl ? 'right' : 'left'] = '';
                }
                applyLeft(headerCells, this.parent.enableRtl);
            }
        }
    }
    addAttributes(td, element) {
        if (td.template) {
            append(td.template, element);
        }
        if (td.colSpan) {
            element.setAttribute('colspan', td.colSpan.toString());
        }
        if (td.className) {
            addClass([element], td.className);
        }
    }
    getHeaderBarHeight() {
        let headerBarHeight = 2;
        if (this.parent.headerModule) {
            headerBarHeight += getOuterHeight(this.parent.headerModule.getHeaderElement());
        }
        if (this.parent.uiStateValues.isGroupAdaptive) {
            const resHeader = this.parent.element.querySelector('.' + RESOURCE_HEADER_TOOLBAR);
            if (resHeader) {
                headerBarHeight += resHeader.offsetHeight;
            }
        }
        return headerBarHeight;
    }
    renderPanel(type) {
        if (type === PREVIOUS_PANEL_CLASS) {
            prepend([this.element], this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS));
        }
        else {
            this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS).appendChild(this.element);
        }
    }
    setPanel(panel) {
        this.element = panel;
    }
    getPanel() {
        return this.element;
    }
    getDatesHeaderElement() {
        return this.element.querySelector('.' + DATE_HEADER_CONTAINER_CLASS);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getDateSlots(renderDates, workDays) {
        return []; // Here getDateSlots only need in vertical and month views
    }
    generateColumnLevels() {
        return []; // Here generateColumnLevels only need in vertical and month views
    }
    getColumnLevels() {
        return this.colLevels;
    }
    highlightCurrentTime() {
        // Here showTimeIndicator functionalities
    }
    getStartDate() {
        return this.renderDates[0];
    }
    getEndDate() {
        return this.renderDates[this.renderDates.length - 1];
    }
    startDate() {
        return this.renderDates[0];
    }
    endDate() {
        return addDays(this.renderDates[this.renderDates.length - 1], 1);
    }
    getStartHour() {
        let startHour = this.parent.getStartEndTime(this.parent.activeViewOptions.startHour);
        if (isNullOrUndefined(startHour)) {
            startHour = new Date(2000, 0, 0, 0);
        }
        return startHour;
    }
    getEndHour() {
        let endHour = this.parent.getStartEndTime(this.parent.activeViewOptions.endHour);
        if (isNullOrUndefined(endHour)) {
            endHour = new Date(2000, 0, 0, 0);
        }
        return endHour;
    }
    isCurrentDate(date) {
        return date.setHours(0, 0, 0, 0) === new Date(this.parent.currentTimezoneDate).setHours(0, 0, 0, 0);
    }
    isCurrentMonth(date) {
        if (this.parent.activeViewOptions.displayDate || this.parent.activeViewOptions.numberOfWeeks > 0) {
            return this.parent.activeView.getStartDate().getTime() <= this.parent.getCurrentTime().getTime() &&
                this.parent.activeView.getEndDate().getTime() >= this.parent.getCurrentTime().getTime();
        }
        return date.getFullYear() ===
            this.parent.getCurrentTime().getFullYear() && date.getMonth() === this.parent.getCurrentTime().getMonth();
    }
    isWorkDay(date, workDays = this.parent.activeViewOptions.workDays) {
        if (workDays.indexOf(date.getDay()) >= 0) {
            return true;
        }
        return false;
    }
    isWorkHour(date, startHour, endHour, workDays) {
        if (isNullOrUndefined(startHour) || isNullOrUndefined(endHour)) {
            return false;
        }
        startHour.setMilliseconds(0);
        endHour.setMilliseconds(0);
        return !(getDateInMs(date) < getDateInMs(startHour) || getDateInMs(date) >= getDateInMs(endHour) ||
            !this.isWorkDay(date, workDays));
    }
    getRenderDates(workDays) {
        const renderDates = [];
        // Due to same code for vertical and time line, week & work week views, if condition has used
        if (this.parent.currentView === 'Week' || this.parent.currentView === 'TimelineWeek') {
            const selectedDate = resetTime(this.parent.selectedDate);
            let start = getWeekFirstDate(selectedDate, this.parent.activeViewOptions.firstDayOfWeek);
            for (let i = 0, length = WEEK_LENGTH * this.parent.activeViewOptions.interval; i < length; i++) {
                if (this.parent.activeViewOptions.showWeekend) {
                    renderDates.push(start);
                }
                else {
                    if (this.isWorkDay(start, workDays)) {
                        renderDates.push(start);
                    }
                }
                start = addDays(start, 1);
            }
        }
        else if (this.parent.currentView === 'WorkWeek' || this.parent.currentView === 'TimelineWorkWeek') {
            let start = getWeekFirstDate(resetTime(this.parent.selectedDate), this.parent.activeViewOptions.firstDayOfWeek);
            for (let i = 0, length = WEEK_LENGTH * this.parent.activeViewOptions.interval; i < length; i++) {
                if (this.isWorkDay(start, workDays)) {
                    renderDates.push(start);
                }
                start = addDays(start, 1);
            }
        }
        else {
            const dayCount = this.parent.currentView === 'Agenda' ? this.parent.agendaDaysCount :
                this.parent.activeViewOptions.interval;
            let start = resetTime(this.parent.selectedDate);
            do {
                if (this.parent.activeViewOptions.showWeekend) {
                    renderDates.push(start);
                }
                else {
                    if (this.isWorkDay(start, workDays)) {
                        renderDates.push(start);
                    }
                }
                start = addDays(start, 1);
            } while (dayCount !== renderDates.length);
        }
        if (!workDays) {
            this.renderDates = renderDates;
        }
        if (this.parent.headerModule) {
            this.parent.headerModule.previousNextIconHandler();
        }
        return renderDates;
    }
    getNextPreviousDate(type) {
        this.previousNextAction = type;
        if (this.parent.currentView === 'Day' || this.parent.currentView === 'TimelineDay') {
            if (this.parent.activeViewOptions.showWeekend) {
                const daysCount = this.parent.activeViewOptions.interval;
                return addDays(this.parent.selectedDate, type === 'next' ? daysCount : -daysCount);
            }
            else {
                let date;
                if (type === 'next') {
                    date = addDays(this.renderDates.slice(-1)[0], 1);
                    while (!this.isWorkDay(date)) {
                        date = addDays(date, 1);
                    }
                }
                else {
                    date = addDays(this.renderDates[0], -1);
                    let count = 0;
                    do {
                        if (this.isWorkDay(date)) {
                            count += 1;
                        }
                        if (this.parent.activeViewOptions.interval !== count) {
                            date = addDays(date, -1);
                        }
                    } while (this.parent.activeViewOptions.interval !== count);
                }
                return date;
            }
        }
        const weekLength = type === 'next' ? WEEK_LENGTH : -WEEK_LENGTH;
        return addDays(this.parent.selectedDate, weekLength * this.parent.activeViewOptions.interval);
    }
    getLabelText(view) {
        const viewStr = view.charAt(0).toLowerCase() + view.substring(1);
        return this.parent.localeObj.getConstant(viewStr) + ' of ' + capitalizeFirstWord(this.parent.globalize.formatDate(this.parent.selectedDate, { skeleton: 'long', calendar: this.parent.getCalendarMode() }), 'single');
    }
    getDateRangeText() {
        if (this.parent.isAdaptive) {
            const formatDate = (this.parent.activeViewOptions.dateFormat) ? this.parent.activeViewOptions.dateFormat : 'MMMM y';
            return capitalizeFirstWord(this.parent.globalize.formatDate(this.parent.selectedDate, { format: formatDate, calendar: this.parent.getCalendarMode() }), 'single');
        }
        return this.formatDateRange(this.renderDates[0], this.renderDates[this.renderDates.length - 1]);
    }
    formatDateRange(startDate, endDate) {
        const globalize = this.parent.globalize;
        const mode = this.parent.getCalendarMode();
        if (startDate === endDate) {
            endDate = null;
        }
        if (!isNullOrUndefined(this.parent.activeViewOptions.dateFormat)) {
            let text = '';
            if (!endDate) {
                text = globalize.formatDate(startDate, { format: this.parent.activeViewOptions.dateFormat, calendar: mode });
                return capitalizeFirstWord(text, 'multiple');
            }
            text = (globalize.formatDate(startDate, { format: this.parent.activeViewOptions.dateFormat, calendar: mode }) +
                ' - ' + globalize.formatDate(endDate, { format: this.parent.activeViewOptions.dateFormat, calendar: mode }));
            return capitalizeFirstWord(text, 'multiple');
        }
        let formattedStr;
        let longDateFormat;
        if (this.parent.locale === 'en' || this.parent.locale === 'en-US') {
            longDateFormat = getValue('dateFormats.long', getDefaultDateObject(mode));
        }
        else {
            longDateFormat = getValue('main.' + '' + this.parent.locale + '.dates.calendars.' + mode + '.dateFormats.long', cldrData);
        }
        if (!endDate) {
            return capitalizeFirstWord(globalize.formatDate(startDate, { format: longDateFormat, calendar: mode }), 'single');
        }
        const dateFormat = longDateFormat.trim().toLocaleLowerCase();
        if (dateFormat.substr(0, 1) === 'd') {
            if (startDate.getFullYear() === endDate.getFullYear()) {
                if (startDate.getMonth() === endDate.getMonth()) {
                    formattedStr = globalize.formatDate(startDate, { format: 'dd', calendar: mode }) + ' - ' +
                        globalize.formatDate(endDate, { format: 'dd MMMM yyyy', calendar: mode });
                }
                else {
                    formattedStr = globalize.formatDate(startDate, { format: 'dd MMM', calendar: mode }) + ' - ' +
                        globalize.formatDate(endDate, { format: 'dd MMM yyyy', calendar: mode });
                }
            }
            else {
                formattedStr = globalize.formatDate(startDate, { format: 'dd MMM yyyy', calendar: mode }) + ' - ' +
                    globalize.formatDate(endDate, { format: 'dd MMM yyyy', calendar: mode });
            }
        }
        else if (dateFormat.substr(0, 1) === 'm') {
            if (startDate.getFullYear() === endDate.getFullYear()) {
                if (startDate.getMonth() === endDate.getMonth()) {
                    formattedStr = globalize.formatDate(startDate, { format: 'MMMM dd', calendar: mode }) + ' - ' +
                        globalize.formatDate(endDate, { format: 'dd, yyyy', calendar: mode });
                }
                else {
                    formattedStr = globalize.formatDate(startDate, { format: 'MMM dd', calendar: mode }) + ' - ' +
                        globalize.formatDate(endDate, { format: 'MMM dd, yyyy', calendar: mode });
                }
            }
            else {
                formattedStr = globalize.
                    formatDate(startDate, { format: 'MMM dd, yyyy', calendar: mode }) + ' - ' +
                    globalize.formatDate(endDate, { format: 'MMM dd, yyyy', calendar: mode });
            }
        }
        else {
            formattedStr = globalize.formatDate(startDate, { format: longDateFormat, calendar: mode }) + ' - ' +
                globalize.formatDate(endDate, { format: longDateFormat, calendar: mode });
        }
        return capitalizeFirstWord(formattedStr, 'multiple');
    }
    getMobileDateElement(date, className) {
        const wrap = createElement('div', {
            className: className,
            innerHTML: '<div class="e-m-date">' + this.parent.globalize.formatDate(date, { format: 'd', calendar: this.parent.getCalendarMode() }) + '</div>' + '<div class="e-m-day">' +
                capitalizeFirstWord(this.parent.globalize.formatDate(date, { format: 'E', calendar: this.parent.getCalendarMode() }), 'single') + '</div>'
        });
        return wrap;
    }
    setResourceHeaderContent(tdElement, tdData, className = TEXT_ELLIPSIS) {
        if (this.parent.activeViewOptions.resourceHeaderTemplate) {
            const data = { resource: tdData.resource, resourceData: tdData.resourceData };
            const scheduleId = this.parent.element.id + '_';
            const viewName = this.parent.activeViewOptions.resourceHeaderTemplateName;
            const templateId = scheduleId + viewName + 'resourceHeaderTemplate';
            const quickTemplate = [].slice.call(this.parent.getResourceHeaderTemplate()(data, this.parent, 'resourceHeaderTemplate', templateId, false));
            append(quickTemplate, tdElement);
        }
        else {
            const resourceText = createElement('div', { className: className });
            this.parent.sanitize(tdData.resourceData[tdData.resource.textField], resourceText);
            tdElement.appendChild(resourceText);
        }
    }
    renderResourceMobileLayout() {
        if (this.parent.resourceBase.lastResourceLevel && this.parent.resourceBase.lastResourceLevel.length <= 0) {
            return;
        }
        this.parent.resourceBase.renderResourceHeader();
        this.parent.resourceBase.renderResourceTree();
    }
    addAutoHeightClass(element) {
        if (!this.parent.uiStateValues.isGroupAdaptive && this.parent.rowAutoHeight && this.isTimelineView()
            && this.parent.activeViewOptions.group.resources.length > 0) {
            addClass([element], AUTO_HEIGHT);
        }
    }
    getColElements() {
        return [].slice.call(this.element.querySelectorAll('.' + CONTENT_WRAP_CLASS + ' col, .' + DATE_HEADER_WRAP_CLASS + ' col'));
    }
    setColWidth(content) {
        if (this.isTimelineView()) {
            const colElements = this.getColElements();
            const contentBody = this.element.querySelector('.' + CONTENT_TABLE_CLASS + ' tbody');
            const colWidth = (contentBody.getBoundingClientRect().width / (colElements.length / 2));
            if (content.offsetHeight !== content.clientHeight) {
                const resourceColumn = this.parent.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);
                if (!isNullOrUndefined(resourceColumn)) {
                    setStyleAttribute(resourceColumn, { 'height': formatUnit(content.clientHeight) });
                }
            }
            const cssClass = `.${HEADER_CELLS_CLASS},.${TIME_SLOT_CLASS},.${HEADER_WEEK_CELLS_CLASS},.${HEADER_MONTH_CELLS_CLASS},.${HEADER_YEAR_CELLS_CLASS}`;
            const headerCellElements = [].slice.call(this.element.querySelectorAll(cssClass));
            headerCellElements.forEach((ele) => {
                const colSpan = isNullOrUndefined(ele.getAttribute('colspan')) ? '1' : ele.getAttribute('colspan');
                const headerCellColSpan = parseInt(colSpan, 10);
                setStyleAttribute(ele, { 'width': formatUnit(colWidth * headerCellColSpan) });
            });
        }
    }
    resetColWidth() {
        const colElements = this.getColElements();
        for (const col of colElements) {
            col.style.width = '';
        }
    }
    getContentAreaElement() {
        return this.element.querySelector('.' + CONTENT_WRAP_CLASS);
    }
    wireExpandCollapseIconEvents() {
        if (this.parent.resourceBase && this.parent.resourceBase.resourceCollection.length > 1) {
            const treeIcons = [].slice.call(this.element.querySelectorAll('.' + RESOURCE_TREE_ICON_CLASS));
            for (const icon of treeIcons) {
                EventHandler.clearEvents(icon);
                EventHandler.add(icon, 'click', this.parent.resourceBase.onTreeIconClick, this.parent.resourceBase);
            }
        }
    }
    scrollToDate(scrollDate) {
        if (['Month', 'TimelineMonth'].indexOf(this.parent.currentView) === -1 || isNullOrUndefined(scrollDate)) {
            return;
        }
        const scrollWrap = this.getContentAreaElement();
        const tdDate = new Date(resetTime(new Date(+scrollDate)).getTime()).getTime();
        const dateElement = scrollWrap.querySelector(`.${WORK_CELLS_CLASS}[data-date="${tdDate}"]`);
        if (this.parent.currentView === 'Month' && dateElement) {
            if (scrollWrap.scrollWidth > scrollWrap.clientWidth) {
                if (!this.parent.enableRtl) {
                    scrollWrap.scrollLeft = dateElement.offsetLeft;
                }
                else {
                    scrollWrap.scrollLeft = -(this.parent.getContentTable().offsetWidth - dateElement.offsetLeft - dateElement.offsetWidth);
                }
            }
            scrollWrap.scrollTop = dateElement.offsetTop;
        }
        if (this.parent.currentView === 'TimelineMonth' && dateElement) {
            if (!this.parent.enableRtl) {
                scrollWrap.scrollLeft = dateElement.offsetLeft;
            }
            else {
                scrollWrap.scrollLeft = -(this.parent.getContentTable().offsetWidth - dateElement.offsetLeft - dateElement.offsetWidth);
            }
        }
    }
    setPersistence() {
        if (this.parent.enablePersistence) {
            const contentWrap = this.element.querySelector('.e-content-wrap');
            if (!isNullOrUndefined(contentWrap)) {
                this.parent.scrollLeft = contentWrap.scrollLeft;
                this.parent.scrollTop = contentWrap.scrollTop;
            }
        }
    }
    retainScrollPosition() {
        if (this.parent.enablePersistence) {
            const conWrap = this.parent.element.querySelector('.e-content-wrap');
            if (!isNullOrUndefined(conWrap) && !isNullOrUndefined(this.parent.scrollLeft) && !isNullOrUndefined(this.parent.scrollTop)) {
                conWrap.scrollTop = this.parent.scrollTop;
                conWrap.scrollLeft = this.parent.scrollLeft;
            }
        }
    }
    getViewStartDate() {
        let startDate = this.renderDates[0];
        if (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.resourceBase.lastResourceLevel.length > 0) {
            startDate = this.parent.resourceBase.getResourceRenderDates()[0];
        }
        return startDate;
    }
    getViewEndDate() {
        let endDate = addDays(this.renderDates[this.renderDates.length - 1], 1);
        if (this.parent.activeViewOptions.group.resources.length > 0 && this.parent.resourceBase.lastResourceLevel.length > 0) {
            endDate = addDays(this.parent.resourceBase.getResourceRenderDates().slice(-1)[0], 1);
        }
        return endDate;
    }
    getAdjustedDate(startTime) {
        if (!this.parent.activeViewOptions.timeScale.enable || this.parent.currentView === 'Month' ||
            (this.parent.currentView === 'TimelineYear' && this.parent.activeViewOptions.group.resources.length === 0)) {
            return new Date(startTime.setHours(0, 0, 0, 0));
        }
        else if (this.parent.currentView === 'TimelineYear' && this.parent.activeViewOptions.group.resources.length > 0) {
            startTime.setHours(0, 0, 0, 0);
            return new Date(startTime.setDate(1));
        }
        return null;
    }
    resetColLevels() {
        this.parent.resourceBase.expandedResources = [];
        const renderedCount = this.parent.virtualScrollModule.getRenderedCount();
        const lastLevel = this.parent.activeViewOptions.group.byDate ? this.colLevels[0] :
            this.parent.resourceBase.renderedResources;
        let index = 0;
        for (let i = 0; i < lastLevel.length; i++) {
            if (index >= renderedCount) {
                break;
            }
            index += lastLevel[parseInt(i.toString(), 10)].colSpan;
            this.parent.resourceBase.expandedResources.push(lastLevel[parseInt(i.toString(), 10)]);
        }
        if (this.parent.activeViewOptions.group.byDate) {
            this.colLevels[0] = this.parent.resourceBase.expandedResources;
            this.parent.virtualScrollModule.setRenderedDates(this.parent.resourceBase.expandedResources);
        }
        else {
            this.colLevels[this.colLevels.length - 2] = this.parent.resourceBase.expandedResources;
            this.parent.resourceBase.renderedResources = this.parent.resourceBase.expandedResources;
        }
        if (this.parent.currentView !== 'Month') {
            this.colLevels[this.colLevels.length - 1] = this.colLevels[this.colLevels.length - 1].slice(0, index);
            this.parent.resourceBase.expandedResources = this.colLevels[this.colLevels.length - 1];
        }
    }
    destroy() {
        if (this.element && this.element.parentNode) {
            remove(this.element);
        }
        this.element = null;
        this.renderDates = null;
        this.colLevels = null;
    }
}

/**
 * vertical view
 */
class VerticalView extends ViewBase {
    constructor(parent) {
        super(parent);
        this.viewClass = 'e-day-view';
        this.isInverseTableSelect = true;
        this.baseCssClass = 'e-vertical-view';
        this.appointment = null;
    }
    getModuleName() {
        return 'verticalView';
    }
    addEventListener() {
        this.parent.on(scrollUiUpdate, this.scrollUiUpdate, this);
        this.parent.on(dataReady, this.renderEvents, this);
    }
    removeEventListener() {
        if (this.parent) {
            this.parent.off(scrollUiUpdate, this.scrollUiUpdate);
            this.parent.off(dataReady, this.renderEvents);
        }
    }
    renderEvents() {
        this.appointment = this.parent.activeViewOptions.timeScale.enable ?
            new VerticalEvent(this.parent) : new MonthEvent(this.parent);
        this.appointment.renderAppointments();
        this.parent.notify(eventsLoaded, {});
    }
    onContentScroll(e) {
        this.parent.removeNewEventElement();
        const target = e.target;
        this.parent.notify(virtualScroll, e);
        this.scrollLeftPanel(target);
        this.scrollTopPanel(target);
        if (!this.parent.isAdaptive) {
            this.parent.uiStateValues.top = target.scrollTop;
        }
        this.parent.uiStateValues.left = target.scrollLeft;
        if (!isNullOrUndefined(this.parent.quickPopup)) {
            this.parent.quickPopup.quickPopupHide();
        }
        this.setPersistence();
    }
    onAdaptiveMove(e) {
        if (this.parent.uiStateValues.action) {
            e.preventDefault();
        }
    }
    onAdaptiveScroll(e) {
        if (this.parent && !this.parent.isDestroyed) {
            this.parent.removeNewEventElement();
            this.parent.uiStateValues.top = e.target.scrollTop;
        }
    }
    scrollLeftPanel(target) {
        const leftPanel = this.getLeftPanelElement();
        if (!isNullOrUndefined(leftPanel)) {
            leftPanel.scrollTop = target.scrollTop;
        }
    }
    scrollUiUpdate(args) {
        if (!this.parent) {
            return;
        }
        const dateHeader = this.parent.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);
        const headerBarHeight = this.getHeaderBarHeight();
        const timeCells = this.getLeftPanelElement();
        const content = this.getScrollableElement();
        const header = this.getDatesHeaderElement();
        const scrollerHeight = this.parent.element.offsetHeight - headerBarHeight - header.offsetHeight;
        this.setContentHeight(content, timeCells, scrollerHeight);
        this.setColWidth(content);
        const scrollBarWidth = getScrollBarWidth();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        header.firstElementChild.style[args.cssProperties.rtlBorder] = '';
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        header.style[args.cssProperties.rtlPadding] = '';
        const isDateHeaderScroll = this.parent.enableAllDayScroll ? !((content.offsetWidth - content.clientWidth) <=
            (dateHeader.offsetWidth - dateHeader.clientWidth) && dateHeader.classList.contains('e-all-day-scroll')) : true;
        if (content.offsetWidth - content.clientWidth > 0 && isDateHeaderScroll) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            header.firstElementChild.style[args.cssProperties.border] = scrollBarWidth > 0 ? '1px' : '0px';
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            header.style[args.cssProperties.padding] = scrollBarWidth > 0 ? scrollBarWidth - 1 + 'px' : '0px';
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            header.firstElementChild.style[args.cssProperties.border] = '';
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            header.style[args.cssProperties.padding] = '';
        }
        if (!args.isPreventScrollUpdate) {
            if (this.parent.uiStateValues.isInitial) {
                if (this.parent.currentView.indexOf('Timeline') > -1) {
                    content.scrollTop = this.parent.uiStateValues.top;
                }
                this.scrollToWorkHour();
                this.parent.uiStateValues.isInitial = false;
            }
            else {
                if (timeCells) {
                    timeCells.scrollTop = this.parent.uiStateValues.top;
                }
                content.scrollTop = this.parent.uiStateValues.top;
                content.scrollLeft = this.parent.uiStateValues.left;
            }
        }
        if (this.parent.activeViewOptions.timeScale.enable) {
            this.highlightCurrentTime();
        }
        this.retainScrollPosition();
    }
    setContentHeight(element, leftPanelElement, height) {
        if (this.parent.isAdaptive && !this.isTimelineView()) {
            element.style.height = (this.parent.height === 'auto') ? 'auto' : formatUnit(height);
        }
        else {
            if (!isNullOrUndefined(leftPanelElement)) {
                leftPanelElement.style.height = (this.parent.height === 'auto') ? 'auto'
                    : formatUnit(height - this.getScrollXIndent(element));
            }
            element.style.height = (this.parent.height === 'auto') ? 'auto' : formatUnit(height);
        }
    }
    scrollToWorkHour() {
        if (this.parent.workHours.highlight) {
            const firstWorkHourCell = this.element.querySelector('.' + WORK_HOURS_CLASS);
            if (firstWorkHourCell) {
                this.getScrollableElement().scrollTop = firstWorkHourCell.offsetTop;
                this.parent.uiStateValues.top = firstWorkHourCell.offsetTop;
                this.parent.uiStateValues.left = 0;
            }
        }
    }
    scrollToHour(hour, scrollDate) {
        const date = this.parent.getStartEndTime(hour);
        if (!isNullOrUndefined(scrollDate)) {
            const headerElement = this.element.querySelector('.' + HEADER_CELLS_CLASS + '[data-date="' + new Date(resetTime(scrollDate)).getTime() + '"]');
            if (headerElement) {
                if (this.parent.enableRtl) {
                    const conWrap = this.element.querySelector('.' + CONTENT_TABLE_CLASS);
                    this.getScrollableElement().scrollLeft = -(conWrap.offsetWidth - headerElement.offsetLeft - headerElement.offsetWidth);
                }
                else {
                    this.getScrollableElement().scrollLeft = headerElement.offsetLeft;
                }
            }
        }
        if (isNullOrUndefined(date)) {
            return;
        }
        this.getScrollableElement().scrollTop = this.getTopFromDateTime(date);
    }
    scrollToDate(scrollDate) {
        this.scrollToHour(null, scrollDate);
    }
    generateColumnLevels() {
        let level = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);
        let columnLevels = [];
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            columnLevels = this.parent.resourceBase.generateResourceLevels(level);
            if (this.parent.activeViewOptions.group.hideNonWorkingDays) {
                while (columnLevels[0].length === 0) {
                    this.parent.setProperties({ selectedDate: this.parent.activeView.getNextPreviousDate(this.previousNextAction) }, true);
                    this.parent.activeView.getRenderDates();
                    if (this.parent.headerModule) {
                        this.parent.headerModule.setCalendarDate(this.parent.selectedDate);
                        this.parent.headerModule.updateDateRange();
                    }
                    level = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);
                    columnLevels = this.parent.resourceBase.generateResourceLevels(level);
                }
            }
            if (this.parent.uiStateValues.isGroupAdaptive && this.parent.resourceBase.lastResourceLevel.length > 0) {
                const resourceLevel = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];
                const resStartHour = resourceLevel.resourceData[resourceLevel.resource.startHourField];
                const resEndHour = resourceLevel.resourceData[resourceLevel.resource.endHourField];
                const dateSlots = this.getDateSlots(resourceLevel.renderDates, resourceLevel.workDays, resStartHour, resEndHour);
                columnLevels = [dateSlots];
            }
        }
        else {
            columnLevels.push(level);
        }
        this.colLevels = columnLevels;
        return columnLevels;
    }
    // eslint-disable-next-line max-len
    getDateSlots(renderDates, workDays, workStartHour = this.parent.workHours.start, workEndHour = this.parent.workHours.end) {
        const dateCol = [];
        const start = this.parent.getStartEndTime(workStartHour);
        const end = this.parent.getStartEndTime(workEndHour);
        for (const col of renderDates) {
            const classList$$1 = [HEADER_CELLS_CLASS];
            if (this.isCurrentDate(col)) {
                classList$$1.push(CURRENT_DAY_CLASS);
            }
            dateCol.push({
                date: col, type: 'dateHeader', className: classList$$1, colSpan: 1,
                workDays: workDays, startHour: new Date(+start), endHour: new Date(+end)
            });
        }
        return dateCol;
    }
    isWorkHourRange(date) {
        return (this.getStartHour().getTime() <= date.getTime()) && (this.getEndHour().getTime() >= date.getTime());
    }
    highlightCurrentTime() {
        if (this.parent.activeViewOptions.headerRows.length > 0 &&
            this.parent.activeViewOptions.headerRows.slice(-1)[0].option !== 'Hour') {
            return;
        }
        const currentDate = this.parent.getCurrentTime();
        if (this.parent.showTimeIndicator && this.isWorkHourRange(currentDate)) {
            const currentDateIndex = this.getCurrentTimeIndicatorIndex();
            if (currentDateIndex.length > 0) {
                const workCells = [].slice.call(this.element.querySelectorAll('.' + WORK_CELLS_CLASS));
                if (workCells.length > 0) {
                    this.changeCurrentTimePosition();
                }
                if (isNullOrUndefined(this.currentTimeIndicatorTimer)) {
                    const interval = MS_PER_MINUTE - ((currentDate.getSeconds() * 1000) + currentDate.getMilliseconds());
                    if (interval <= (MS_PER_MINUTE - 1000)) {
                        window.setTimeout(() => {
                            if (!isNullOrUndefined(this.currentTimeIndicatorTimer)) {
                                this.clearCurrentTimeIndicatorTimer();
                                this.changeCurrentTimePosition();
                                this.updateCurrentTimeIndicatorTimer();
                            }
                        }, interval);
                    }
                    this.updateCurrentTimeIndicatorTimer();
                }
            }
            else {
                this.clearCurrentTimeIndicatorTimer();
            }
        }
        else {
            this.clearCurrentTimeIndicatorTimer();
        }
    }
    getCurrentTimeIndicatorIndex() {
        const currentDateIndex = [];
        if (!isNullOrUndefined(this.parent.resourceBase) && (this.parent.activeViewOptions.group.resources.length > 0) &&
            !this.parent.uiStateValues.isGroupAdaptive) {
            let count = 0;
            const currentDate = resetTime(this.parent.getCurrentTime());
            if (this.parent.virtualScrollModule && this.parent.activeViewOptions.allowVirtualScrolling &&
                this.parent.activeViewOptions.group.byDate) {
                for (const resource of this.parent.resourceBase.expandedResources) {
                    if (resetTime(resource.date).getTime() === currentDate.getTime()) {
                        currentDateIndex.push(count);
                    }
                    count += 1;
                }
            }
            else {
                for (const resource of this.parent.resourceBase.renderedResources) {
                    const index = this.parent.getIndexOfDate(resource.renderDates, currentDate);
                    if (index >= 0) {
                        const resIndex = this.parent.activeViewOptions.group.byDate ?
                            (this.parent.resourceBase.lastResourceLevel.length * index) + count : count + index;
                        currentDateIndex.push(resIndex);
                    }
                    count += this.parent.activeViewOptions.group.byDate ? 1 : resource.renderDates.length;
                }
            }
        }
        else {
            const renderDates = (this.parent.uiStateValues.isGroupAdaptive && this.parent.resourceBase.lastResourceLevel.length > 0)
                ? this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex].renderDates : this.renderDates;
            const index = this.parent.getIndexOfDate(renderDates, resetTime(this.parent.getCurrentTime()));
            if (index >= 0) {
                currentDateIndex.push(index);
            }
        }
        return currentDateIndex;
    }
    clearCurrentTimeIndicatorTimer() {
        if (!isNullOrUndefined(this.currentTimeIndicatorTimer)) {
            window.clearInterval(this.currentTimeIndicatorTimer);
            this.currentTimeIndicatorTimer = null;
            this.removeCurrentTimeIndicatorElements();
        }
    }
    updateCurrentTimeIndicatorTimer() {
        this.currentTimeIndicatorTimer = window.setInterval(() => { this.changeCurrentTimePosition(); }, MS_PER_MINUTE);
    }
    removeCurrentTimeIndicatorElements() {
        const queryString = '.' + PREVIOUS_TIMELINE_CLASS + ',.' + CURRENT_TIMELINE_CLASS + ',.' + CURRENT_TIME_CLASS;
        const timeIndicator = [].slice.call(this.element.querySelectorAll(queryString));
        for (const indicator of timeIndicator) {
            remove(indicator);
        }
    }
    changeCurrentTimePosition() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.removeCurrentTimeIndicatorElements();
        const currentDateIndex = this.getCurrentTimeIndicatorIndex();
        const firstRow = this.parent.getContentTable().rows[0];
        const top = this.getTopFromDateTime(this.parent.getCurrentTime());
        const topInPx = formatUnit(top);
        const rowIndex = Math.floor(top / firstRow.cells[0].offsetHeight);
        const timeCellsWrap = this.getLeftPanelElement();
        const timeTrs = [].slice.call(timeCellsWrap.querySelectorAll('tr'));
        if (isNullOrUndefined(rowIndex) || isNaN(rowIndex) || rowIndex === timeTrs.length) {
            return;
        }
        const curTimeWrap = [].slice.call(this.element.querySelectorAll('.' + TIMELINE_WRAPPER_CLASS));
        for (let i = 0, length = currentDateIndex[0]; i < length; i++) {
            curTimeWrap[parseInt(i.toString(), 10)].appendChild(createElement('div', { className: PREVIOUS_TIMELINE_CLASS, styles: 'top:' + topInPx }));
        }
        for (const day of currentDateIndex) {
            curTimeWrap[parseInt(day.toString(), 10)].appendChild(createElement('div', { className: CURRENT_TIMELINE_CLASS, styles: 'top:' + topInPx }));
        }
        const currentTimeEle = createElement('div', {
            innerHTML: this.parent.getTimeString(this.parent.getCurrentTime()),
            className: CURRENT_TIME_CLASS,
            styles: 'top:' + topInPx
        });
        if (rowIndex <= timeTrs.length) {
            removeClass(timeCellsWrap.querySelectorAll('.' + HIDE_CHILDS_CLASS), HIDE_CHILDS_CLASS);
            if (timeTrs[parseInt(rowIndex.toString(), 10)]) {
                addClass([timeTrs[parseInt(rowIndex.toString(), 10)].lastElementChild], HIDE_CHILDS_CLASS);
            }
            prepend([currentTimeEle], timeCellsWrap);
            currentTimeEle.style.top = formatUnit(currentTimeEle.offsetTop - (currentTimeEle.offsetHeight / 2));
        }
    }
    getTopFromDateTime(date) {
        const startHour = this.getStartHour();
        const diffInMinutes = ((date.getHours() - startHour.getHours()) * 60) + (date.getMinutes() - startHour.getMinutes());
        return (diffInMinutes * this.getWorkCellHeight() * this.parent.activeViewOptions.timeScale.slotCount) /
            this.parent.activeViewOptions.timeScale.interval;
    }
    getWorkCellHeight() {
        return parseFloat(this.element.querySelector('.' + WORK_CELLS_CLASS).getBoundingClientRect().height.toFixed(2));
    }
    getTdContent(date, type, groupIndex) {
        let cntEle;
        const wrapper = createElement('div');
        let templateName = '';
        const templateId = this.parent.element.id + '_';
        switch (type) {
            case 'dateHeader':
                if (this.parent.activeViewOptions.dateHeaderTemplate) {
                    templateName = 'dateHeaderTemplate';
                    const args = { date: date, type: type };
                    const viewName = this.parent.activeViewOptions.dateHeaderTemplateName;
                    cntEle = [].slice.call(this.parent.getDateHeaderTemplate()(args, this.parent, templateName, templateId + viewName + templateName, false));
                }
                else {
                    wrapper.innerHTML = this.parent.activeView.isTimelineView() ?
                        `<span class="e-header-date e-navigate">${this.getTimelineDate(date)}</span>` :
                        `<div class="e-header-day">${capitalizeFirstWord(this.getDayName(date), 'single')}</div>` +
                            `<div class="e-header-date e-navigate" role="link">${this.getDate(date)}</div>`;
                    cntEle = [].slice.call(wrapper.childNodes);
                }
                break;
            case 'majorSlot':
                if (this.parent.activeViewOptions.timeScale.majorSlotTemplate) {
                    templateName = 'majorSlotTemplate';
                    const args = { date: date, type: type };
                    cntEle = [].slice.call(this.parent.getMajorSlotTemplate()(args, this.parent, templateName, templateId + templateName, false));
                }
                else {
                    wrapper.innerHTML = `<span>${this.getTime(date)}</span>`;
                    cntEle = [].slice.call(wrapper.childNodes);
                }
                break;
            case 'minorSlot':
                if (this.parent.activeViewOptions.timeScale.minorSlotTemplate) {
                    templateName = 'minorSlotTemplate';
                    const args = { date: date, type: type };
                    cntEle = [].slice.call(this.parent.getMinorSlotTemplate()(args, this.parent, templateName, templateId + templateName, false));
                }
                else {
                    cntEle = [].slice.call(wrapper.childNodes);
                }
                break;
            case 'alldayCells':
                if (this.parent.activeViewOptions.cellTemplate) {
                    const viewName = this.parent.activeViewOptions.cellTemplateName;
                    templateName = 'cellTemplate';
                    const args = { date: date, type: type, groupIndex: groupIndex };
                    cntEle = [].slice.call(this.parent.getCellTemplate()(args, this.parent, templateName, templateId + viewName + templateName, false));
                }
                break;
        }
        return cntEle;
    }
    refreshHeader() {
        remove(this.element.querySelector('tbody tr'));
        this.renderHeader();
        this.parent.notify(contentReady, {});
    }
    renderLayout(type) {
        this.setPanel(createElement('div', { className: TABLE_WRAP_CLASS }));
        const clsList = [this.baseCssClass, this.viewClass];
        clsList.push(type);
        if (this.parent.activeViewOptions.group.byDate) {
            clsList.push('e-by-date');
        }
        if (!this.parent.activeViewOptions.timeScale.enable) {
            addClass([this.element], [TIMESCALE_DISABLE, this.viewClass]);
        }
        if (this.parent.activeViewOptions.allowVirtualScrolling && !this.parent.uiStateValues.isGroupAdaptive) {
            clsList.push(VIRTUAL_SCROLL_CLASS);
        }
        if (this.parent.rowAutoHeight && this.parent.eventSettings.ignoreWhitespace) {
            clsList.push(IGNORE_WHITESPACE);
        }
        this.renderPanel(type);
        addClass([this.element], clsList);
        this.element.appendChild(this.createTableLayout(OUTER_TABLE_CLASS));
        this.element.querySelector('table').setAttribute('role', 'presentation');
        this.colLevels = this.generateColumnLevels();
        this.renderHeader();
        this.renderContent();
        if (this.parent.uiStateValues.isGroupAdaptive && !this.parent.element.querySelector('.' + RESOURCE_TOOLBAR_CONTAINER)) {
            this.renderResourceMobileLayout();
        }
        this.parent.notify(contentReady, {});
    }
    renderHeader() {
        const tr = createElement('tr');
        const dateTd = createElement('td');
        dateTd.appendChild(this.renderDatesHeader());
        if (this.parent.activeViewOptions.timeScale.enable) {
            const indentTd = createElement('td', { className: LEFT_INDENT_CLASS });
            indentTd.appendChild(this.renderLeftIndent());
            tr.appendChild(indentTd);
        }
        tr.appendChild(dateTd);
        prepend([tr], this.element.querySelector('tbody'));
    }
    renderContent() {
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            this.parent.resourceBase.renderedResources = extend([], this.parent.resourceBase.lastResourceLevel, null, true);
        }
        const tr = createElement('tr');
        const workTd = createElement('td');
        if (this.parent.isAdaptive) {
            workTd.setAttribute('colspan', (this.parent.activeViewOptions.timeScale.enable ? '2' : '1'));
            const scrollContainer = createElement('div', { className: SCROLL_CONTAINER_CLASS });
            if (this.parent.activeViewOptions.timeScale.enable) {
                scrollContainer.appendChild(this.renderTimeCells());
            }
            scrollContainer.appendChild(this.renderContentArea());
            workTd.appendChild(scrollContainer);
            EventHandler.add(scrollContainer, 'scroll', this.onAdaptiveScroll, this);
            EventHandler.add(scrollContainer, Browser.touchMoveEvent, this.onAdaptiveMove, this);
            tr.appendChild(workTd);
        }
        else {
            const levels = this.colLevels.slice(0);
            if (this.parent.virtualScrollModule) {
                this.resetColLevels();
            }
            const wrap = this.renderContentArea();
            workTd.appendChild(wrap);
            if (this.parent.activeViewOptions.timeScale.enable) {
                const timesTd = createElement('td');
                timesTd.appendChild(this.renderTimeCells());
                tr.appendChild(timesTd);
            }
            tr.appendChild(workTd);
            if (this.parent.virtualScrollModule) {
                this.colLevels = levels;
                this.parent.virtualScrollModule.renderVirtualTrack(wrap);
            }
        }
        this.element.querySelector('tbody').appendChild(tr);
    }
    renderLeftIndent() {
        const wrap = createElement('div', { className: LEFT_INDENT_WRAP_CLASS });
        const tbl = this.createTableLayout();
        const trEle = createElement('tr');
        const rowCount = this.colLevels.length;
        let nth;
        for (let i = 0; i < rowCount; i++) {
            const ntr = trEle.cloneNode();
            const data = { className: [(this.colLevels[parseInt(i.toString(), 10)][0] && this.colLevels[parseInt(i.toString(), 10)][0].className[0])], type: 'emptyCells' };
            if (this.parent.activeViewOptions.showWeekNumber && data.className.indexOf(HEADER_CELLS_CLASS) !== -1) {
                data.className.push(WEEK_NUMBER_CLASS);
                const weekNo = this.parent.getWeekNumberContent(this.renderDates);
                data.template = [createElement('span', {
                        innerHTML: '' + weekNo,
                        attrs: { title: this.parent.localeObj.getConstant('week') + ' ' + weekNo }
                    })];
            }
            nth = this.createTd(data);
            this.parent.renderHeaderIndentTemplate(data, nth);
            ntr.appendChild(nth);
            tbl.querySelector('tbody').appendChild(ntr);
        }
        const ntr = trEle.cloneNode();
        const appointmentExpandCollapse = createElement('div', {
            attrs: {
                'tabindex': '0', 'role': 'list',
                title: this.parent.localeObj.getConstant('expandAllDaySection'), 'aria-disabled': 'false', 'aria-label': 'Expand section'
            },
            className: ALLDAY_APPOINTMENT_SECTION_CLASS + ' ' + APPOINTMENT_ROW_EXPAND_CLASS + ' ' +
                ICON + ' ' + DISABLE_CLASS
        });
        const data = { className: [ALLDAY_CELLS_CLASS], type: 'emptyCells' };
        nth = this.createTd(data);
        nth.appendChild(appointmentExpandCollapse);
        this.parent.renderHeaderIndentTemplate(data, nth);
        ntr.appendChild(nth);
        tbl.querySelector('tbody').appendChild(ntr);
        wrap.appendChild(tbl);
        return wrap;
    }
    renderDatesHeader() {
        const container = createElement('div', { className: DATE_HEADER_CONTAINER_CLASS });
        const wrap = createElement('div', { className: DATE_HEADER_WRAP_CLASS });
        container.appendChild(wrap);
        const tbl = this.createTableLayout();
        const trEle = createElement('tr', { className: HEADER_ROW_CLASS });
        const rowCount = this.colLevels.length;
        const lastLevel = this.colLevels[rowCount - 1];
        for (let i = 0; i < rowCount; i++) {
            const ntr = trEle.cloneNode();
            const level = this.colLevels[parseInt(i.toString(), 10)];
            for (let j = 0; j < level.length; j++) {
                ntr.appendChild(this.createTd(level[parseInt(j.toString(), 10)]));
            }
            tbl.querySelector('tbody').appendChild(ntr);
        }
        this.createAllDayRow(tbl, lastLevel);
        this.createColGroup(tbl, lastLevel);
        wrap.appendChild(tbl);
        return container;
    }
    createAllDayRow(table, tdData) {
        const ntr = createElement('tr', { className: ALLDAY_ROW_CLASS });
        for (let j = 0; j < tdData.length; j++) {
            const td = extend({}, tdData[parseInt(j.toString(), 10)]);
            td.className = [ALLDAY_CELLS_CLASS];
            td.type = 'alldayCells';
            const ntd = this.createTd(td);
            ntd.setAttribute('data-date', td.date.getTime().toString());
            if (!isNullOrUndefined(td.groupIndex)) {
                ntd.setAttribute('data-group-index', '' + td.groupIndex);
            }
            else if (this.parent.uiStateValues.isGroupAdaptive) {
                ntd.setAttribute('data-group-index', '' + this.parent.uiStateValues.groupIndex);
            }
            this.wireCellEvents(ntd);
            ntr.appendChild(ntd);
        }
        table.querySelector('tbody').appendChild(ntr);
        const thead = createElement('thead');
        thead.appendChild(this.parent.eventBase.createEventWrapper('allDay'));
        prepend([thead], table);
    }
    createTd(td) {
        const tdEle = createElement('td');
        this.addAttributes(td, tdEle);
        if (td.date && td.type) {
            const ele = this.getTdContent(td.date, td.type, td.groupIndex);
            if (ele && ele.length) {
                append(ele, tdEle);
            }
        }
        if (!this.parent.isMinMaxDate(resetTime(new Date('' + td.date)))) {
            addClass([tdEle], DISABLE_DATES);
        }
        if (td.type === 'resourceHeader') {
            this.setResourceHeaderContent(tdEle, td);
        }
        if (td.type === 'dateHeader' && td.className.indexOf(HEADER_CELLS_CLASS) >= 0) {
            tdEle.setAttribute('data-date', td.date.getTime().toString());
            if (!isNullOrUndefined(td.groupIndex)) {
                tdEle.setAttribute('data-group-index', '' + td.groupIndex);
            }
            this.wireMouseEvents(tdEle);
        }
        const args = { elementType: td.type, element: tdEle, date: td.date, groupIndex: td.groupIndex };
        this.parent.trigger(renderCell, args);
        return tdEle;
    }
    wireCellEvents(element) {
        EventHandler.add(element, 'mousedown', this.parent.workCellAction.cellMouseDown, this.parent.workCellAction);
        this.wireMouseEvents(element);
    }
    wireMouseEvents(element) {
        EventHandler.add(element, 'click', this.parent.workCellAction.cellClick, this.parent.workCellAction);
        if (!this.parent.isAdaptive) {
            EventHandler.add(element, 'dblclick', this.parent.workCellAction.cellDblClick, this.parent.workCellAction);
        }
    }
    renderTimeCells() {
        const wrap = createElement('div', { className: TIME_CELLS_WRAP_CLASS });
        const tbl = this.createTableLayout();
        const trEle = createElement('tr');
        const handler = (r) => {
            r.type = r.first ? 'majorSlot' : 'minorSlot';
            r.className = r.last ? [TIME_CELLS_CLASS, TIME_SLOT_CLASS] : [TIME_SLOT_CLASS];
            const ntr = trEle.cloneNode();
            const data = { date: r.date, type: r.type, className: r.className };
            ntr.appendChild(this.createTd(data));
            tbl.querySelector('tbody').appendChild(ntr);
            return r;
        };
        this.getTimeSlotRows(handler);
        wrap.appendChild(tbl);
        return wrap;
    }
    renderContentArea() {
        const wrap = createElement('div', { className: CONTENT_WRAP_CLASS });
        const tbl = this.createTableLayout(CONTENT_TABLE_CLASS);
        this.setAriaAttributes(tbl);
        this.addAutoHeightClass(tbl);
        this.renderContentTable(tbl);
        this.createColGroup(tbl, this.colLevels.slice(-1)[0]);
        wrap.appendChild(tbl);
        this.wireCellEvents(tbl.querySelector('tbody'));
        EventHandler.add(wrap, 'scroll', this.onContentScroll, this);
        EventHandler.add(wrap, Browser.touchMoveEvent, this.onAdaptiveMove, this);
        return wrap;
    }
    renderContentTable(table) {
        const tBody = table.querySelector('tbody');
        append(this.getContentRows(), tBody);
        this.renderContentTableHeader(table);
    }
    getContentRows() {
        const rows = [];
        const tr = createElement('tr');
        const td = createElement('td', { attrs: { 'aria-selected': 'false' } });
        const handler = (r) => {
            const ntr = tr.cloneNode();
            for (const tdData of this.colLevels[this.colLevels.length - 1]) {
                const ntd = this.createContentTd(tdData, r, td);
                ntr.appendChild(ntd);
            }
            rows.push(ntr);
            return r;
        };
        this.getTimeSlotRows(handler);
        return rows;
    }
    createContentTd(tdData, r, td) {
        const ntd = td.cloneNode();
        if (tdData.colSpan) {
            ntd.setAttribute('colspan', tdData.colSpan.toString());
        }
        const clsName = this.getContentTdClass(r);
        const cellDate = resetTime(tdData.date);
        if (!this.parent.isMinMaxDate(cellDate)) {
            clsName.push(DISABLE_DATES);
        }
        setTime(cellDate, getDateInMs(r.date));
        let type = 'workCells';
        if (tdData.className.indexOf(RESOURCE_PARENT_CLASS) !== -1) {
            clsName.push(RESOURCE_GROUP_CELLS_CLASS);
            type = 'resourceGroupCells';
        }
        if (this.parent.workHours.highlight && ((this.parent.activeViewOptions.timeScale.enable &&
            this.isWorkHour(cellDate, tdData.startHour, tdData.endHour, tdData.workDays)) ||
            (!this.parent.activeViewOptions.timeScale.enable && this.isWorkDay(cellDate, tdData.workDays)))) {
            clsName.push(WORK_HOURS_CLASS);
        }
        addClass([ntd], clsName);
        if (this.parent.activeViewOptions.cellTemplate) {
            const args = { date: cellDate, type: type, groupIndex: tdData.groupIndex };
            const scheduleId = this.parent.element.id + '_';
            const viewName = this.parent.activeViewOptions.cellTemplateName;
            const templateId = scheduleId + viewName + 'cellTemplate';
            const tooltipTemplate = [].slice.call(this.parent.getCellTemplate()(args, this.parent, 'cellTemplate', templateId, false));
            append(tooltipTemplate, ntd);
        }
        ntd.setAttribute('data-date', cellDate.getTime().toString());
        if (!isNullOrUndefined(tdData.groupIndex) || this.parent.uiStateValues.isGroupAdaptive) {
            const groupIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex :
                tdData.groupIndex;
            ntd.setAttribute('data-group-index', '' + groupIndex);
        }
        const args = { elementType: type, element: ntd, date: cellDate, groupIndex: tdData.groupIndex };
        this.parent.trigger(renderCell, args);
        return ntd;
    }
    getContentTdClass(r) {
        return r.last ? [WORK_CELLS_CLASS] : [WORK_CELLS_CLASS, ALTERNATE_CELLS_CLASS];
    }
    renderContentTableHeader(table) {
        const thead = createElement('thead');
        thead.appendChild(this.parent.eventBase.createEventWrapper());
        if (this.parent.activeViewOptions.timeScale.enable) {
            thead.appendChild(this.parent.eventBase.createEventWrapper('timeIndicator'));
        }
        prepend([thead], table);
    }
    getScrollableElement() {
        if (this.parent.isAdaptive && !this.isTimelineView()) {
            return this.element.querySelector('.' + SCROLL_CONTAINER_CLASS);
        }
        else {
            return this.getContentAreaElement();
        }
    }
    getLeftPanelElement() {
        return this.element.querySelector('.' + TIME_CELLS_WRAP_CLASS);
    }
    getEndDateFromStartDate(start) {
        const msMajorInterval = this.parent.activeViewOptions.timeScale.interval * MS_PER_MINUTE;
        const msInterval = msMajorInterval / this.parent.activeViewOptions.timeScale.slotCount;
        const end = new Date(start.getTime());
        end.setMilliseconds(end.getMilliseconds() + msInterval);
        return end;
    }
    getTimeSlotRows(handler) {
        const rows = [];
        const startHour = this.getStartHour();
        const endHour = this.getEndHour();
        const msMajorInterval = this.parent.activeViewOptions.timeScale.interval * MS_PER_MINUTE;
        const msInterval = msMajorInterval / this.parent.activeViewOptions.timeScale.slotCount;
        let length = Math.round(MS_PER_DAY / msInterval);
        const msStartHour = startHour.getTime();
        const msEndHour = endHour.getTime();
        if (msStartHour !== msEndHour) {
            const duration = this.parent.activeViewOptions.timeScale.interval / this.parent.activeViewOptions.timeScale.slotCount;
            length = (Math.abs(msEndHour - msStartHour) / msInterval) - ((new Date(msEndHour).getTimezoneOffset()
                - new Date(msStartHour).getTimezoneOffset()) / duration);
        }
        if (!this.parent.activeViewOptions.timeScale.enable) {
            length = 1;
        }
        const start = this.parent.getStartEndTime(this.parent.workHours.start);
        const end = this.parent.getStartEndTime(this.parent.workHours.end);
        for (let i = 0; i < length; i++) {
            let dt = new Date(msStartHour + (msInterval * i));
            if (isDaylightSavingTime(dt) || new Date(msStartHour).getTimezoneOffset() !== dt.getTimezoneOffset()) {
                const timeOffset = new Date(msStartHour).getTimezoneOffset() - dt.getTimezoneOffset();
                dt = new Date(dt.getTime() - (1000 * 60 * timeOffset));
            }
            const majorTickDivider = i % (msMajorInterval / msInterval);
            const row = {
                date: new Date('' + dt),
                startHour: start,
                endHour: end,
                first: (majorTickDivider === 0),
                middle: (majorTickDivider < this.parent.activeViewOptions.timeScale.slotCount - 1),
                last: (majorTickDivider === this.parent.activeViewOptions.timeScale.slotCount - 1),
                type: ''
            };
            if (handler) {
                handler(row);
            }
            rows.push(row);
        }
        return rows;
    }
    getAdjustedDate(startTime) {
        if (!this.parent.activeViewOptions.timeScale.enable) {
            return new Date(startTime.setHours(0, 0, 0, 0));
        }
        else {
            const timeSlots = this.getTimeSlotRows();
            const startDate = new Date(new Date(timeSlots[0].date.getTime()).
                setHours(startTime.getHours(), startTime.getMinutes(), startTime.getMilliseconds()));
            for (let i = 0; i < timeSlots.length; i++) {
                if (timeSlots[parseInt(i.toString(), 10)].date.getTime() > startDate.getTime()) {
                    startTime.setHours(timeSlots[i - 1].date.getHours(), timeSlots[i - 1].date.getMinutes(), timeSlots[i - 1].date.getMilliseconds());
                    return new Date(startTime);
                }
            }
        }
        return null;
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.clearCurrentTimeIndicatorTimer();
        if (this.element) {
            if (this.appointment) {
                this.appointment.destroy();
                this.appointment = null;
            }
            const contentScrollableEle = this.getContentAreaElement();
            if (contentScrollableEle) {
                EventHandler.remove(contentScrollableEle, 'scroll', this.onContentScroll);
                EventHandler.remove(contentScrollableEle, Browser.touchMoveEvent, this.onAdaptiveMove);
            }
            if (this.parent.resourceBase) {
                this.parent.resourceBase.destroy();
            }
            if (this.parent.scheduleTouchModule) {
                this.parent.scheduleTouchModule.resetValues();
            }
            super.destroy();
        }
    }
}

/**
 * day view
 */
class Day extends VerticalView {
    /**
     * Constructor for day view
     *
     * @param {Schedule} parent Accepts the schedule instance
     */
    constructor(parent) {
        super(parent);
        this.viewClass = 'e-day-view';
    }
    /**
     * Get module name.
     *
     * @returns {string} Returns the module name.
     */
    getModuleName() {
        return 'day';
    }
}

/**
 * week view
 */
class Week extends VerticalView {
    /**
     * Constructor for week view
     *
     * @param {Schedule} parent Accepts the schedule instance
     */
    constructor(parent) {
        super(parent);
        this.viewClass = 'e-week-view';
    }
    startDate() {
        return this.getViewStartDate();
    }
    endDate() {
        return this.getViewEndDate();
    }
    /**
     * Get module name.
     *
     * @returns {string} Returns the module name.
     */
    getModuleName() {
        return 'week';
    }
}

/**
 * work week view
 */
class WorkWeek extends VerticalView {
    /**
     * Constructor for work week view
     *
     * @param {Schedule} parent Accepts the schedule instance
     */
    constructor(parent) {
        super(parent);
        this.viewClass = 'e-work-week-view';
    }
    startDate() {
        return this.getViewStartDate();
    }
    endDate() {
        return this.getViewEndDate();
    }
    /**
     * Get module name.
     *
     * @returns {string} Returns the module name.
     */
    getModuleName() {
        return 'workWeek';
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * month view
 */
class Month extends ViewBase {
    constructor(parent) {
        super(parent);
        this.dayNameFormat = 'wide';
        this.viewClass = 'e-month-view';
        this.isInverseTableSelect = false;
        this.monthEvent = null;
        this.monthDates = {};
    }
    addEventListener() {
        this.parent.on(scrollUiUpdate, this.onScrollUIUpdate, this);
        this.parent.on(dataReady, this.onDataReady, this);
        this.parent.on(cellClick, this.onCellClick, this);
    }
    removeEventListener() {
        if (this.parent) {
            this.parent.off(scrollUiUpdate, this.onScrollUIUpdate);
            this.parent.off(dataReady, this.onDataReady);
            this.parent.off(cellClick, this.onCellClick);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDataReady(args) {
        this.monthEvent = new MonthEvent(this.parent);
        this.monthEvent.renderAppointments();
        this.parent.notify(eventsLoaded, {});
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onCellClick(event) { }
    onContentScroll(e) {
        this.parent.removeNewEventElement();
        this.parent.notify(virtualScroll, e);
        this.scrollTopPanel(e.target);
        this.scrollLeftPanel(e.target);
        this.parent.uiStateValues.top = e.target.scrollTop;
        this.parent.uiStateValues.left = e.target.scrollLeft;
        this.setPersistence();
    }
    scrollLeftPanel(target) {
        const leftPanel = this.getLeftPanelElement();
        if (leftPanel) {
            leftPanel.scrollTop = target.scrollTop;
        }
    }
    getLeftPanelElement() {
        return this.element.querySelector('.' + WEEK_NUMBER_WRAPPER_CLASS);
    }
    onScrollUIUpdate(args) {
        const headerHeight = this.getHeaderBarHeight();
        const header = this.getDatesHeaderElement();
        const content = this.getContentAreaElement();
        const height = this.parent.element.offsetHeight - headerHeight - header.offsetHeight;
        const leftPanel = this.getLeftPanelElement();
        if (this.parent.height !== 'auto') {
            this.setContentHeight(content, leftPanel, height);
        }
        const scrollBarWidth = getScrollBarWidth();
        header.firstElementChild.style[args.cssProperties.rtlBorder] = '';
        header.style[args.cssProperties.rtlPadding] = '';
        if (content.offsetWidth - content.clientWidth > 0) {
            header.firstElementChild.style[args.cssProperties.border] = scrollBarWidth > 0 ? '1px' : '0px';
            header.style[args.cssProperties.padding] = scrollBarWidth > 0 ? scrollBarWidth - 1 + 'px' : '0px';
        }
        else {
            header.firstElementChild.style[args.cssProperties.border] = '';
            header.style[args.cssProperties.padding] = '';
        }
        this.setColWidth(content);
        if (args.scrollPosition || !args.isPreventScrollUpdate && this.parent.currentView === 'TimelineMonth') {
            const top = this.parent.currentView === 'TimelineMonth' ? this.parent.uiStateValues.top : args.scrollPosition.top;
            if (leftPanel) {
                leftPanel.scrollTop = top;
            }
            content.scrollTop = top;
            if (this.parent.uiStateValues.isInitial) {
                this.scrollToSelectedDate();
                this.parent.uiStateValues.isInitial = false;
            }
            else {
                content.scrollLeft = this.parent.currentView === 'TimelineMonth' ? this.parent.uiStateValues.left :
                    args.scrollPosition.left;
            }
        }
        else {
            this.scrollToSelectedDate();
        }
        this.retainScrollPosition();
    }
    scrollToSelectedDate() {
        const headerCell = this.element.querySelector('.' + HEADER_CELLS_CLASS + '[data-date="'
            + this.parent.selectedDate.getTime().toString() + '"]');
        const content = this.getContentAreaElement();
        if (!isNullOrUndefined(headerCell)) {
            content.scrollLeft = !this.parent.enableRtl ?
                headerCell.offsetLeft : -(this.parent.getContentTable().offsetWidth - headerCell.offsetLeft - headerCell.offsetWidth);
        }
        else {
            content.scrollLeft = 0;
        }
        if (content.scrollLeft === 0 && this.parent.uiStateValues.isInitial) {
            this.parent.uiStateValues.left = 0;
        }
    }
    setContentHeight(content, leftPanelElement, height) {
        content.style.height = 'auto';
        if (this.parent.currentView === 'Month') {
            content.style.height = formatUnit(height);
        }
        if (leftPanelElement) {
            if (this.parent.currentView === 'MonthAgenda') {
                height = (this.parent.activeViewOptions.interval > 1) ?
                    this.getContentAreaElement().firstElementChild.offsetHeight :
                    this.element.querySelector('.' + CONTENT_TABLE_CLASS).offsetHeight;
            }
            leftPanelElement.style.height = 'auto';
            leftPanelElement.style.height = formatUnit(height - this.getScrollXIndent(content));
        }
    }
    generateColumnLevels() {
        let colLevels = [];
        const level = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            colLevels = this.parent.resourceBase.generateResourceLevels(level);
            if (this.parent.currentView === 'MonthAgenda') {
                colLevels = [level];
            }
            if (this.parent.uiStateValues.isGroupAdaptive && this.parent.resourceBase.lastResourceLevel.length > 0) {
                const resourceLevel = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];
                let levels = this.getDateSlots(resourceLevel.renderDates, resourceLevel.workDays);
                if (this.parent.activeViewOptions.group.byDate && this.parent.activeViewOptions.group.hideNonWorkingDays) {
                    const index = levels.findIndex((x, index) => index !== 0 && x.date.getDay() === levels[0].date.getDay());
                    levels = index > -1 ? levels.slice(0, index) : levels;
                }
                colLevels = [levels];
            }
        }
        else {
            colLevels.push(level);
        }
        this.colLevels = colLevels;
        return colLevels;
    }
    getDateSlots(renderDates, workDays) {
        const count = this.parent.activeViewOptions.showWeekend ? WEEK_LENGTH : workDays.length;
        const dateSlots = [];
        const isCurrentMonth = this.isCurrentMonth(this.parent.selectedDate);
        for (let col = 0; col < count; col++) {
            const classList$$1 = [HEADER_CELLS_CLASS];
            const currentDateIndex = renderDates.slice(0, count).map((date) => date.getDay());
            if (isCurrentMonth && currentDateIndex.indexOf(this.parent.currentTimezoneDate.getDay()) === col) {
                classList$$1.push(CURRENT_DAY_CLASS);
            }
            dateSlots.push({ date: renderDates[parseInt(col.toString(), 10)], type: 'monthDay', className: classList$$1, colSpan: 1, workDays: workDays });
        }
        return dateSlots;
    }
    getDayNameFormat() {
        if (this.parent.isAdaptive || this.parent.activeViewOptions.group.resources.length > 0) {
            return 'abbreviated';
        }
        return 'wide';
    }
    renderLayout(type) {
        this.dayNameFormat = this.getDayNameFormat();
        this.setPanel(createElement('div', { className: TABLE_WRAP_CLASS }));
        const clsList = [this.viewClass];
        clsList.push(type);
        if (this.parent.activeViewOptions.group.byDate) {
            clsList.push('e-by-date');
            if (this.parent.currentView !== 'Month') {
                this.parent.activeViewOptions.group.hideNonWorkingDays = false;
            }
        }
        if (this.parent.activeViewOptions.allowVirtualScrolling && !this.parent.uiStateValues.isGroupAdaptive) {
            clsList.push(VIRTUAL_SCROLL_CLASS);
        }
        if (this.parent.rowAutoHeight && this.parent.eventSettings.ignoreWhitespace) {
            clsList.push(IGNORE_WHITESPACE);
        }
        addClass([this.element], clsList);
        this.renderPanel(type);
        this.element.appendChild(this.createTableLayout(OUTER_TABLE_CLASS));
        this.element.querySelector('table').setAttribute('role', 'presentation');
        this.colLevels = this.generateColumnLevels();
        this.renderHeader();
        this.renderContent();
        const target = (this.parent.currentView === 'MonthAgenda') ? this.parent.activeView.getPanel() : this.parent.element;
        if (this.parent.uiStateValues.isGroupAdaptive && !target.querySelector('.' + RESOURCE_TOOLBAR_CONTAINER)) {
            this.renderResourceMobileLayout();
        }
        this.parent.notify(contentReady, {});
        if (this.parent.uiStateValues.isCustomMonth) {
            this.parent.uiStateValues.isCustomMonth = false;
        }
    }
    refreshHeader() {
        remove(this.element.querySelector('tbody tr'));
        this.renderHeader();
        this.parent.notify(contentReady, {});
    }
    wireCellEvents(element) {
        EventHandler.add(element, 'mousedown', this.parent.workCellAction.cellMouseDown, this.parent.workCellAction);
        EventHandler.add(element, 'click', this.parent.workCellAction.cellClick, this.parent.workCellAction);
        if (!this.parent.isAdaptive) {
            EventHandler.add(element, 'dblclick', this.parent.workCellAction.cellDblClick, this.parent.workCellAction);
        }
    }
    renderHeader() {
        const tr = createElement('tr');
        this.renderLeftIndent(tr);
        const dateTd = createElement('td');
        dateTd.appendChild(this.renderDatesHeader());
        tr.appendChild(dateTd);
        prepend([tr], this.element.querySelector('tbody'));
    }
    renderLeftIndent(tr) {
        if (this.parent.activeViewOptions.showWeekNumber) {
            tr.appendChild(createElement('td', { className: 'e-left-indent' }));
        }
    }
    renderContent() {
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            this.parent.resourceBase.renderedResources = extend([], this.parent.resourceBase.lastResourceLevel, null, true);
        }
        const tr = createElement('tr');
        if (this.parent.activeViewOptions.showWeekNumber) {
            tr.appendChild(this.renderWeekNumberContent());
        }
        const workTd = createElement('td');
        const levels = this.colLevels.slice(0);
        if (this.parent.virtualScrollModule) {
            this.resetColLevels();
        }
        const wrap = createElement('div', { className: CONTENT_WRAP_CLASS });
        const contentArea = this.renderContentArea();
        if (this.parent.currentView === 'Month') {
            wrap.appendChild(contentArea);
        }
        else {
            const monthAgendaWrapper = createElement('div', { className: TABLE_CONTAINER_CLASS });
            monthAgendaWrapper.appendChild(contentArea);
            wrap.appendChild(monthAgendaWrapper);
        }
        EventHandler.add(wrap, 'scroll', this.onContentScroll, this);
        workTd.appendChild(wrap);
        tr.appendChild(workTd);
        if (this.parent.virtualScrollModule) {
            this.colLevels = levels;
            this.parent.virtualScrollModule.renderVirtualTrack(wrap);
        }
        this.element.querySelector('tbody').appendChild(tr);
        this.renderAppointmentContainer();
    }
    renderWeekNumberContent() {
        const dateCol = this.renderDates.map((date) => new Date(+date));
        const td = createElement('td');
        const contentWrapper = createElement('div', { className: WEEK_NUMBER_WRAPPER_CLASS });
        td.appendChild(contentWrapper);
        const contentWrapTable = this.createTableLayout();
        contentWrapper.appendChild(contentWrapTable);
        const noOfDays = this.parent.activeViewOptions.showWeekend ? WEEK_LENGTH :
            this.parent.activeViewOptions.workDays.length;
        for (let i = 0, length = (this.renderDates.length / noOfDays); i < length; i++) {
            const dates = dateCol.splice(0, noOfDays);
            const weekNumber = this.parent.getWeekNumberContent(dates);
            contentWrapTable.querySelector('tbody').appendChild(this.createWeekNumberElement(weekNumber));
        }
        return td;
    }
    renderAppointmentContainer() {
        //Here needs to render mobile view appointment details on selected date
    }
    renderDatesHeader() {
        const container = createElement('div', { className: DATE_HEADER_CONTAINER_CLASS });
        const wrap = createElement('div', { className: DATE_HEADER_WRAP_CLASS });
        container.appendChild(wrap);
        const table = this.createTableLayout();
        if (this.parent.currentView === 'Month') {
            const thead = createElement('thead');
            thead.appendChild(createElement('tr'));
            prepend([thead], table);
        }
        this.createColGroup(table, this.colLevels[this.colLevels.length - 1]);
        const trEle = createElement('tr');
        for (let i = 0; i < this.colLevels.length; i++) {
            const level = this.colLevels[parseInt(i.toString(), 10)];
            const ntr = trEle.cloneNode();
            for (let j = 0; j < level.length; j++) {
                const td = level[parseInt(j.toString(), 10)];
                ntr.appendChild(this.createHeaderCell(td));
            }
            table.querySelector('tbody').appendChild(ntr);
        }
        wrap.appendChild(table);
        return container;
    }
    createHeaderCell(td) {
        const tdEle = createElement('td');
        this.addAttributes(td, tdEle);
        if (td.type === 'monthDay') {
            const ele = createElement('span', { innerHTML: capitalizeFirstWord(this.parent.getDayNames(this.dayNameFormat)[td.date.getDay()], 'single') });
            tdEle.appendChild(ele);
        }
        if (td.type === 'resourceHeader') {
            this.setResourceHeaderContent(tdEle, td);
        }
        if (td.type === 'dateHeader') {
            addClass([tdEle], DATE_HEADER_CLASS);
            tdEle.setAttribute('data-date', td.date.getTime().toString());
            if (this.parent.activeViewOptions.dateHeaderTemplate) {
                const cellArgs = { date: td.date, type: td.type };
                const elementId = this.parent.element.id + '_';
                const viewName = this.parent.activeViewOptions.dateHeaderTemplateName;
                const templateId = elementId + viewName + 'dateHeaderTemplate';
                const dateTemplate = [].slice.call(this.parent.getDateHeaderTemplate()(cellArgs, this.parent, 'dateHeaderTemplate', templateId, false));
                if (dateTemplate && dateTemplate.length) {
                    append(dateTemplate, tdEle);
                }
            }
            else {
                const ele = createElement('span', { className: NAVIGATE_CLASS });
                const skeleton = 'full';
                const title = this.parent.globalize.formatDate(td.date, { skeleton: skeleton, calendar: this.parent.getCalendarMode() });
                ele.setAttribute('title', capitalizeFirstWord(title, 'multiple'));
                const innerText = (this.parent.calendarUtil.isMonthStart(td.date) && !this.isCurrentDate(td.date) && !this.parent.isAdaptive) ?
                    this.parent.globalize.formatDate(td.date, { format: 'MMM d', calendar: this.parent.getCalendarMode() }) :
                    this.parent.globalize.formatDate(td.date, { skeleton: 'd', calendar: this.parent.getCalendarMode() });
                ele.innerHTML = capitalizeFirstWord(innerText, 'single');
                tdEle.appendChild(ele);
            }
            this.wireCellEvents(tdEle);
        }
        const args = { elementType: td.type, element: tdEle, date: td.date, groupIndex: td.groupIndex };
        this.parent.trigger(renderCell, args);
        return tdEle;
    }
    getContentSlots() {
        if (!(this.colLevels[this.colLevels.length - 1] && this.colLevels[this.colLevels.length - 1][0])) {
            return [];
        }
        const slotDatas = [];
        const prepareSlots = (rowIndex, renderDate, resData, classList$$1) => {
            const data = {
                date: new Date(+renderDate), groupIndex: resData.groupIndex, workDays: resData.workDays,
                type: 'monthCells', className: classList$$1 || [WORK_CELLS_CLASS]
            };
            if (!slotDatas[parseInt(rowIndex.toString(), 10)]) {
                slotDatas[parseInt(rowIndex.toString(), 10)] = [];
            }
            slotDatas[parseInt(rowIndex.toString(), 10)].push(data);
        };
        const includeResource = this.parent.currentView !== 'MonthAgenda' &&
            this.parent.activeViewOptions.group.resources.length > 0;
        if (includeResource && !this.parent.uiStateValues.isGroupAdaptive && !this.parent.activeViewOptions.group.byDate) {
            for (const res of this.colLevels[this.colLevels.length - 2]) {
                const dates = res.renderDates.map((date) => new Date(+date));
                const count = this.parent.activeViewOptions.showWeekend ? WEEK_LENGTH : res.workDays.length;
                for (let i = 0; i < (res.renderDates.length / count); i++) {
                    const colDates = dates.splice(0, count);
                    for (const colDate of colDates) {
                        prepareSlots(i, colDate, res);
                    }
                }
            }
        }
        else {
            const dates = this.renderDates.map((date) => new Date(+date));
            const count = this.parent.activeViewOptions.showWeekend ? WEEK_LENGTH :
                this.parent.activeViewOptions.workDays.length;
            const level = this.colLevels.slice(0, 1)[0];
            const startIndex = this.renderDates.map(Number).indexOf(+level[0].date);
            for (let i = 0; i < (this.renderDates.length / count); i++) {
                const colDates = dates.splice(0, count);
                let k = startIndex;
                for (let j = startIndex; j < (this.colLevels[0].length + startIndex) && j < colDates.length; j++) {
                    const colDate = colDates[parseInt(k.toString(), 10)];
                    k++;
                    if (includeResource) {
                        const lastRow = this.colLevels[(this.colLevels.length - 1)];
                        const rowCount = lastRow.length / count;
                        let resourcesTd = lastRow.slice(0, rowCount);
                        if (this.parent.activeViewOptions.group.hideNonWorkingDays) {
                            resourcesTd = lastRow.filter((x) => x.date.getDay() === colDate.getDay());
                            if (resourcesTd.length === 0) {
                                j = j - 1;
                                continue;
                            }
                        }
                        for (let resIndex = 0; resIndex < resourcesTd.length; resIndex++) {
                            let clsList;
                            if (resIndex !== 0) {
                                clsList = [WORK_CELLS_CLASS, DISABLE_DATE];
                            }
                            prepareSlots(i, colDate, resourcesTd[parseInt(resIndex.toString(), 10)], clsList);
                        }
                    }
                    else {
                        prepareSlots(i, colDate, this.colLevels[this.colLevels.length - 1][0]);
                    }
                }
            }
        }
        return slotDatas;
    }
    updateClassList(data) {
        if (!this.isCustomMonth() && this.isOtherMonth(data.date)) {
            data.className.push(OTHERMONTH_CLASS);
        }
        if (!this.parent.isMinMaxDate(data.date)) {
            data.className.push(DISABLE_DATES);
        }
        this.updateSelectedCellClass(data);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateSelectedCellClass(data) {
        return;
    }
    isOtherMonth(date) {
        return date.getTime() < this.monthDates.start.getTime() || date.getTime() > this.monthDates.end.getTime();
    }
    renderContentArea() {
        const tbl = this.createTableLayout(CONTENT_TABLE_CLASS);
        this.setAriaAttributes(tbl);
        this.addAutoHeightClass(tbl);
        if (this.parent.currentView === 'TimelineMonth') {
            this.createColGroup(tbl, this.colLevels[this.colLevels.length - 1]);
        }
        const monthDate = new Date(this.parent.selectedDate.getTime());
        this.monthDates = {
            start: this.parent.calendarUtil.firstDateOfMonth(monthDate),
            end: this.parent.calendarUtil.lastDateOfMonth(addMonths(monthDate, this.parent.activeViewOptions.interval - 1))
        };
        const tBody = tbl.querySelector('tbody');
        append(this.getContentRows(), tBody);
        this.wireCellEvents(tBody);
        return tbl;
    }
    getContentRows() {
        const trows = [];
        const tr = createElement('tr');
        const td = createElement('td', { attrs: { 'aria-selected': 'false' } });
        const slotDatas = this.getContentSlots();
        for (let row = 0; row < slotDatas.length; row++) {
            const ntr = tr.cloneNode();
            for (let col = 0; col < slotDatas[parseInt(row.toString(), 10)].length; col++) {
                const ntd = this.createContentTd(slotDatas[parseInt(row.toString(), 10)][parseInt(col.toString(), 10)], td);
                ntr.appendChild(ntd);
            }
            trows.push(ntr);
        }
        return trows;
    }
    createContentTd(data, td) {
        const ntd = td.cloneNode();
        if (data.colSpan) {
            ntd.setAttribute('colspan', data.colSpan.toString());
        }
        this.updateClassList(data);
        let type = data.type;
        if (data.className.indexOf(RESOURCE_PARENT_CLASS) !== -1) {
            data.className.push(RESOURCE_GROUP_CELLS_CLASS);
            type = 'resourceGroupCells';
        }
        if (this.parent.workHours.highlight && this.isWorkDay(data.date, data.workDays)) {
            data.className.push(WORKDAY_CLASS);
        }
        if (this.isCurrentDate(data.date)) {
            data.className.push(CURRENTDATE_CLASS);
        }
        addClass([ntd], data.className);
        ntd.setAttribute('data-date', data.date.getTime().toString());
        if (!isNullOrUndefined(data.groupIndex) || this.parent.uiStateValues.isGroupAdaptive) {
            const groupIndex = this.parent.uiStateValues.isGroupAdaptive ? this.parent.uiStateValues.groupIndex :
                data.groupIndex;
            ntd.setAttribute('data-group-index', '' + groupIndex);
        }
        this.renderDateHeaderElement(data, ntd);
        if (this.parent.activeViewOptions.cellTemplate) {
            const args = { date: data.date, type: type, groupIndex: data.groupIndex };
            const scheduleId = this.parent.element.id + '_';
            const viewName = this.parent.activeViewOptions.cellTemplateName;
            const templateId = scheduleId + viewName + 'cellTemplate';
            const cellTemplate = [].slice.call(this.parent.getCellTemplate()(args, this.parent, 'cellTemplate', templateId, false));
            append(cellTemplate, ntd);
        }
        const args = { elementType: type, element: ntd, date: data.date, groupIndex: data.groupIndex };
        this.parent.trigger(renderCell, args);
        return ntd;
    }
    renderDateHeaderElement(data, ntd) {
        if (this.parent.currentView === 'TimelineMonth') {
            return;
        }
        const dateHeader = createElement('div', { className: DATE_HEADER_CLASS });
        if (this.parent.activeViewOptions.cellHeaderTemplate) {
            const args = { date: data.date, type: data.type, groupIndex: data.groupIndex };
            const scheduleId = this.parent.element.id + '_';
            const viewName = this.parent.activeViewOptions.cellHeaderTemplateName;
            const templateId = scheduleId + viewName + 'cellHeaderTemplate';
            const cellHeaderTemplate = [].slice.call(this.parent.getCellHeaderTemplate()(args, this.parent, 'cellHeaderTemplate', templateId, false));
            append(cellHeaderTemplate, dateHeader);
        }
        else {
            const innerText = (this.parent.calendarUtil.isMonthStart(data.date) && !this.isCurrentDate(data.date) && !this.parent.isAdaptive) ?
                this.parent.globalize.formatDate(data.date, { format: 'MMM d', calendar: this.parent.getCalendarMode() }) :
                this.parent.globalize.formatDate(data.date, { skeleton: 'd', calendar: this.parent.getCalendarMode() });
            dateHeader.innerHTML = capitalizeFirstWord(innerText, 'single');
        }
        ntd.appendChild(dateHeader);
        if (this.getModuleName() === 'month') {
            addClass([dateHeader], NAVIGATE_CLASS);
            const skeleton = 'full';
            const announcementText = this.parent.globalize.formatDate(data.date, { skeleton: skeleton, calendar: this.parent.getCalendarMode() });
            ntd.setAttribute('aria-label', announcementText);
        }
    }
    getMonthStart(currentDate) {
        const useDisplayDate = this.parent.currentView === 'Month' && !isNullOrUndefined(this.parent.activeViewOptions.displayDate) && (this.parent.uiStateValues.isCustomMonth || this.isCustomRange());
        const date = useDisplayDate ? this.parent.activeViewOptions.displayDate : !(this.parent.uiStateValues.isCustomMonth ||
            this.isCustomRange()) && this.isCustomMonth() ? currentDate : this.parent.calendarUtil.firstDateOfMonth(currentDate);
        const monthStart = getWeekFirstDate(date, this.parent.activeViewOptions.firstDayOfWeek);
        return new Date(monthStart.getFullYear(), monthStart.getMonth(), monthStart.getDate());
    }
    getMonthEnd(currentDate) {
        if (this.isCustomMonth()) {
            const start = this.getMonthStart(currentDate);
            const numberOfDays = WEEK_LENGTH * (this.parent.activeViewOptions.numberOfWeeks > 0 ?
                this.parent.activeViewOptions.numberOfWeeks : DEFAULT_WEEKS);
            return addDays(start, (numberOfDays - 1));
        }
        else {
            const endDate = addMonths(currentDate, this.parent.activeViewOptions.interval - 1);
            const lastWeekOfMonth = getWeekFirstDate(this.parent.calendarUtil.lastDateOfMonth(endDate), this.parent.activeViewOptions.firstDayOfWeek);
            return addDays(lastWeekOfMonth, WEEK_LENGTH - 1);
        }
    }
    isCustomRange() {
        const dates = this.parent.getCurrentViewDates();
        if (dates && dates.length > 0) {
            const selectedTime = resetTime(this.parent.selectedDate).getTime();
            const weekFirstDate = getWeekFirstDate(dates[dates.length - 1], this.parent.activeViewOptions.firstDayOfWeek);
            return !(selectedTime >= getWeekFirstDate(dates[0], this.parent.activeViewOptions.firstDayOfWeek).getTime() &&
                selectedTime <= addDays(weekFirstDate, 6).getTime());
        }
        return false;
    }
    getRenderDates(workDays) {
        const renderDates = [];
        const currentDate = resetTime(this.parent.selectedDate);
        let start = this.getMonthStart(currentDate);
        const monthEnd = this.getMonthEnd(currentDate);
        do {
            if (this.parent.activeViewOptions.showWeekend) {
                renderDates.push(start);
            }
            else {
                if (this.isWorkDay(start, workDays)) {
                    renderDates.push(start);
                }
            }
            start = addDays(start, 1);
            if (start.getHours() > 0) {
                start = resetTime(start);
            }
        } while (start.getTime() <= monthEnd.getTime());
        if (!workDays) {
            this.renderDates = renderDates;
        }
        if (this.parent.headerModule) {
            this.parent.headerModule.previousNextIconHandler();
        }
        return renderDates;
    }
    getNextPreviousDate(type) {
        if (this.isCustomMonth()) {
            const dates = this.parent.getCurrentViewDates();
            const date = getWeekFirstDate(type === 'next' ? dates[dates.length - 1]
                : dates[0], this.parent.activeViewOptions.firstDayOfWeek);
            return addDays(date, type === 'next' ? WEEK_LENGTH : -(this.parent.activeViewOptions.numberOfWeeks > 0 ?
                this.parent.activeViewOptions.numberOfWeeks : DEFAULT_WEEKS) * WEEK_LENGTH);
        }
        else {
            return addMonths(this.parent.selectedDate, ((type === 'next' ? 1 : -1) * this.parent.activeViewOptions.interval));
        }
    }
    getStartDate() {
        return this.getMonthStart(this.parent.selectedDate);
    }
    getEndDate() {
        return this.getMonthEnd(this.parent.selectedDate);
    }
    getEndDateFromStartDate(start) {
        return addDays(new Date(start.getTime()), 1);
    }
    getDateRangeText() {
        if (this.parent.isAdaptive || isNullOrUndefined(this.parent.activeViewOptions.dateFormat)) {
            let startDate = this.parent.selectedDate;
            let endDate;
            let updateCustomRange = false;
            if (this.isCustomMonth()) {
                const dates = this.parent.getCurrentViewDates();
                updateCustomRange = dates[0].getMonth() !== dates[dates.length - 1].getMonth() ||
                    dates[0].getFullYear() !== dates[dates.length - 1].getFullYear();
                if (updateCustomRange) {
                    startDate = dates[0];
                    endDate = dates[dates.length - 1];
                }
            }
            const isUpdateDateRange = (this.parent.currentView !== 'Month' || !this.isCustomMonth());
            if (this.parent.activeViewOptions.interval > 1 && isUpdateDateRange || updateCustomRange) {
                endDate = endDate ? endDate : addMonths(lastDateOfMonth(startDate), this.parent.activeViewOptions.interval - 1);
                if (startDate.getFullYear() === endDate.getFullYear()) {
                    const monthNames = (this.parent.globalize.formatDate(startDate, { format: 'MMMM', calendar: this.parent.getCalendarMode() })) + ' - ' +
                        (this.parent.globalize.formatDate(endDate, { format: 'MMMM ', calendar: this.parent.getCalendarMode() })) +
                        this.parent.globalize.formatDate(endDate, { skeleton: 'y', calendar: this.parent.getCalendarMode() });
                    return capitalizeFirstWord(monthNames, 'single');
                }
                const text = (this.parent.globalize.formatDate(startDate, { format: 'MMMM', calendar: this.parent.getCalendarMode() })) + ' ' +
                    startDate.getFullYear() + ' - ' +
                    this.parent.globalize.formatDate(endDate, { format: 'MMMM ', calendar: this.parent.getCalendarMode() }) +
                    this.parent.globalize.formatDate(endDate, { skeleton: 'y', calendar: this.parent.getCalendarMode() });
                return capitalizeFirstWord(text, 'single');
            }
            const format = (this.parent.activeViewOptions.dateFormat) ? this.parent.activeViewOptions.dateFormat : 'MMMM y';
            return capitalizeFirstWord(this.parent.globalize.formatDate(startDate, { format: format, calendar: this.parent.getCalendarMode() }), 'single');
        }
        return this.formatDateRange(this.parent.selectedDate);
    }
    getLabelText(view) {
        return this.parent.localeObj.getConstant(view) + ' of ' + capitalizeFirstWord(this.parent.globalize.formatDate(this.parent.selectedDate, { format: 'MMMM y', calendar: this.parent.getCalendarMode() }), 'single');
    }
    createWeekNumberElement(text) {
        const tr = createElement('tr');
        const td = createElement('td', {
            className: WEEK_NUMBER_CLASS,
            attrs: { 'title': (text ? this.parent.localeObj.getConstant('week') + ' ' + text : '') },
            innerHTML: (text || '')
        });
        tr.appendChild(td);
        const args = { elementType: 'weekNumberCell', element: td };
        this.parent.trigger(renderCell, args);
        return tr;
    }
    unWireEvents() {
        const contentScrollableEle = this.element.querySelector('.' + CONTENT_WRAP_CLASS);
        if (contentScrollableEle) {
            EventHandler.remove(contentScrollableEle, 'scroll', this.onContentScroll);
        }
    }
    isCustomMonth() {
        return this.parent.currentView === 'Month' &&
            (!isNullOrUndefined(this.parent.activeViewOptions.displayDate) || this.parent.activeViewOptions.numberOfWeeks > 0);
    }
    getModuleName() {
        return 'month';
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        if (this.element) {
            if (this.monthEvent) {
                this.monthEvent.destroy();
                this.monthEvent = null;
            }
            this.unWireEvents();
            if (this.parent.resourceBase) {
                this.parent.resourceBase.destroy();
            }
            if (this.parent.scheduleTouchModule) {
                this.parent.scheduleTouchModule.resetValues();
            }
            super.destroy();
        }
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * year view
 */
class Year extends ViewBase {
    constructor(parent) {
        super(parent);
        this.viewClass = 'e-year-view';
        this.isInverseTableSelect = false;
        this.yearEventModule = null;
    }
    getModuleName() {
        return 'year';
    }
    renderLayout(className) {
        if (this.parent.resourceBase) {
            this.parent.resourceBase.generateResourceLevels([{ renderDates: this.parent.activeView.renderDates }]);
        }
        this.setPanel(createElement('div', { className: TABLE_WRAP_CLASS }));
        const viewTypeClass = this.parent.activeViewOptions.orientation === 'Horizontal' ? 'e-horizontal' : 'e-vertical';
        addClass([this.element], [this.viewClass, viewTypeClass, className]);
        this.renderPanel(className);
        if (this.parent.activeViewOptions.allowVirtualScrolling) {
            addClass([this.element], [VIRTUAL_SCROLL_CLASS]);
        }
        const calendarTable = this.createTableLayout(OUTER_TABLE_CLASS);
        this.element.appendChild(calendarTable);
        this.element.querySelector('table').setAttribute('role', 'presentation');
        const calendarTBody = calendarTable.querySelector('tbody');
        this.rowCount = this.getRowColumnCount('row');
        this.columnCount = this.getRowColumnCount('column');
        this.renderHeader(calendarTBody);
        this.renderContent(calendarTBody);
        if (this.parent.currentView !== 'Year' && this.parent.uiStateValues.isGroupAdaptive) {
            this.generateColumnLevels();
            this.renderResourceMobileLayout();
        }
        EventHandler.add(this.element.querySelector('.' + CONTENT_WRAP_CLASS), 'scroll', this.onContentScroll, this);
        this.parent.notify(contentReady, {});
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    renderHeader(headerWrapper) { }
    renderContent(content) {
        const tr = createElement('tr');
        content.appendChild(tr);
        const td = createElement('td');
        tr.appendChild(td);
        this.element.querySelector('tbody').appendChild(tr);
        const contentWrapper = createElement('div', { className: CONTENT_WRAP_CLASS });
        td.appendChild(contentWrapper);
        const calendarTable = this.createTableLayout('e-calendar-table');
        contentWrapper.appendChild(calendarTable);
        const cTr = createElement('tr');
        calendarTable.querySelector('tbody').appendChild(cTr);
        const cTd = createElement('td');
        cTr.appendChild(cTd);
        const calendarWrapper = createElement('div', { className: 'e-calendar-wrapper' });
        cTd.appendChild(calendarWrapper);
        const months = this.getMonths();
        for (const month of months) {
            const currentMonth = new Date(this.parent.selectedDate.getFullYear(), month, 1);
            const calendarElement = createElement('div', {
                className: 'e-month-calendar e-calendar',
                attrs: { 'data-role': 'calendar' }
            });
            calendarElement.appendChild(this.renderCalendarHeader(currentMonth));
            calendarElement.appendChild(this.renderCalendarContent(currentMonth));
            calendarWrapper.appendChild(calendarElement);
        }
        this.renderDates.splice(0, 1);
    }
    renderCalendarHeader(currentDate) {
        const headerWrapper = createElement('div', { className: 'e-header e-month' });
        const headerContent = createElement('div', { className: 'e-day e-title' });
        if (this.parent.activeViewOptions.monthHeaderTemplate) {
            const args = { date: currentDate, type: 'monthHeader' };
            this.renderTemplates(this.parent.getMonthHeaderTemplate(), args, 'monthHeaderTemplate', this.parent.activeViewOptions.monthHeaderTemplateName, headerContent);
        }
        else {
            headerContent.innerHTML = this.getMonthName(currentDate);
        }
        headerWrapper.appendChild(headerContent);
        this.parent.trigger(renderCell, { elementType: 'headerCells', element: headerContent, date: currentDate });
        return headerWrapper;
    }
    renderCalendarContent(currentDate) {
        const dateCollection = this.getMonthDates(currentDate);
        const contentWrapper = createElement('div', { className: 'e-content e-month' });
        const contentTable = this.createTableLayout('e-calendar-table ' + CONTENT_TABLE_CLASS);
        contentWrapper.appendChild(contentTable);
        this.setAriaAttributes(contentTable);
        const thead = createElement('thead', { className: 'e-week-header' });
        const tr = createElement('tr');
        let currentWeek = getWeekFirstDate(firstDateOfMonth(currentDate), this.parent.firstDayOfWeek);
        if (this.parent.activeViewOptions.showWeekNumber) {
            tr.appendChild(createElement('th'));
        }
        for (let i = 0; i < WEEK_LENGTH; i++) {
            if (this.parent.activeViewOptions.dayHeaderTemplate) {
                const th = createElement('th');
                const args = { date: currentWeek, type: 'dayHeader' };
                this.renderTemplates(this.parent.getDayHeaderTemplate(), args, 'dayHeaderTemplate', this.parent.activeViewOptions.dayHeaderTemplateName, th);
                tr.appendChild(th);
            }
            else {
                tr.appendChild(createElement('th', { innerHTML: this.parent.getDayNames('narrow')[currentWeek.getDay()] }));
            }
            currentWeek = new Date(currentWeek.getTime() + MS_PER_DAY);
        }
        thead.appendChild(tr);
        prepend([thead], contentTable);
        const tbody = contentTable.querySelector('tbody');
        while (dateCollection.length > 0) {
            const weekDates = dateCollection.splice(0, WEEK_LENGTH);
            const tr = createElement('tr');
            if (this.parent.activeViewOptions.showWeekNumber) {
                const weekNumber = this.parent.getWeekNumberContent(weekDates);
                const td = createElement('td', {
                    className: 'e-week-number',
                    attrs: { 'title': this.parent.localeObj.getConstant('week') + ' ' + weekNumber },
                    innerHTML: weekNumber
                });
                tr.appendChild(td);
                this.parent.trigger(renderCell, { elementType: 'weekNumberCells', element: td });
            }
            for (const date of weekDates) {
                const td = createElement('td', {
                    className: 'e-cell ' + WORK_CELLS_CLASS,
                    attrs: { 'data-date': date.getTime().toString() }
                });
                if (this.parent.activeViewOptions.cellHeaderTemplate) {
                    const args = { date: date, type: 'monthCells' };
                    this.renderTemplates(this.parent.getCellHeaderTemplate(), args, 'cellHeaderTemplate', this.parent.activeViewOptions.cellHeaderTemplateName, td);
                }
                else {
                    const span = createElement('span', {
                        className: 'e-day', innerHTML: this.parent.globalize.formatDate(date, { skeleton: 'd', calendar: this.parent.getCalendarMode() }),
                        attrs: { title: this.parent.globalize.formatDate(date, { type: 'date', skeleton: 'full' }) }
                    });
                    td.appendChild(span);
                }
                if (this.parent.activeViewOptions.cellTemplate) {
                    const args = { date: date, type: 'monthCells' };
                    this.renderTemplates(this.parent.getCellTemplate(), args, 'cellTemplate', this.parent.activeViewOptions.cellTemplateName, td);
                }
                let classList$$1 = [];
                if (currentDate.getMonth() !== date.getMonth()) {
                    classList$$1.push(OTHERMONTH_CLASS);
                }
                if (this.isCurrentDate(date) && currentDate.getMonth() === date.getMonth()) {
                    classList$$1 = classList$$1.concat(['e-today', 'e-selected']);
                }
                if (classList$$1.length > 0) {
                    addClass([td], classList$$1);
                }
                tr.appendChild(td);
                if (currentDate.getMonth() === date.getMonth()) {
                    this.renderDates.push(new Date(date));
                }
                if (!this.parent.isMinMaxDate(date)) {
                    addClass([td], DISABLE_DATES);
                }
                else {
                    EventHandler.add(td, 'click', this.onCellClick, this);
                    if (!this.parent.isAdaptive) {
                        EventHandler.add(td, 'dblclick', this.parent.workCellAction.cellDblClick, this.parent.workCellAction);
                    }
                }
                this.parent.trigger(renderCell, { elementType: 'workCells', element: td, date: date });
            }
            tbody.appendChild(tr);
        }
        return contentWrapper;
    }
    createTableColGroup(count) {
        const colGroupEle = createElement('colgroup');
        for (let i = 0; i < count; i++) {
            colGroupEle.appendChild(createElement('col'));
        }
        return colGroupEle;
    }
    getMonthName(date) {
        const month = this.parent.globalize.formatDate(date, {
            format: this.parent.activeViewOptions.dateFormat || 'MMMM y',
            calendar: this.parent.getCalendarMode()
        });
        return capitalizeFirstWord(month, 'multiple');
    }
    generateColumnLevels() {
        let colLevels = [];
        const level = this.getDateSlots([this.parent.selectedDate], this.parent.activeViewOptions.workDays);
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            colLevels = this.parent.resourceBase.generateResourceLevels(level);
            if (this.parent.uiStateValues.isGroupAdaptive) {
                const resourceLevel = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];
                colLevels = [this.getDateSlots([this.parent.selectedDate], resourceLevel.workDays)];
            }
        }
        else {
            colLevels.push(level);
        }
        colLevels.pop();
        this.colLevels = colLevels;
        return colLevels;
    }
    // eslint-disable-next-line max-len
    getDateSlots(renderDates, workDays, startHour = this.parent.workHours.start, endHour = this.parent.workHours.end) {
        const dateCol = [{
                date: renderDates[0], type: 'dateHeader', className: [HEADER_CELLS_CLASS], colSpan: 1, workDays: workDays,
                startHour: new Date(+this.parent.globalize.parseDate(startHour, { skeleton: 'Hm' })),
                endHour: new Date(+this.parent.globalize.parseDate(endHour, { skeleton: 'Hm' }))
            }];
        return dateCol;
    }
    getMonthDates(date) {
        const startDate = getWeekFirstDate(firstDateOfMonth(date), this.parent.firstDayOfWeek);
        const endDate = addDays(new Date(+startDate), (6 * WEEK_LENGTH));
        const dateCollection = [];
        for (let start = startDate; start.getTime() < endDate.getTime(); start = addDays(start, 1)) {
            dateCollection.push(resetTime(new Date(start)));
        }
        return dateCollection;
    }
    getRowColumnCount(type) {
        const months = this.getMonths();
        const year = this.parent.selectedDate.getFullYear();
        const monthDaysCount = [];
        for (const month of months) {
            monthDaysCount.push(new Date(year, month, 1).getDay() + new Date(year, month + 1, 0).getDate());
        }
        const maxCount = Math.max(...monthDaysCount);
        let count;
        if (type === 'row') {
            count = this.parent.activeViewOptions.orientation === 'Horizontal' ? months.length : maxCount;
        }
        else {
            count = this.parent.activeViewOptions.orientation === 'Horizontal' ? maxCount : months.length;
        }
        return count;
    }
    isCurrentDate(date) {
        return resetTime(new Date()).getTime() === resetTime(new Date(date.getTime())).getTime();
    }
    getMonths() {
        // eslint-disable-next-line prefer-spread
        return Array.apply(null, { length: this.parent.activeViewOptions.monthsCount }).map((value, index) => this.parent.firstMonthOfYear + index);
    }
    renderTemplates(fn, args, tName, vName, ele) {
        const templateId = this.parent.element.id + '_' + vName + tName;
        const template = [].slice.call(fn(args, this.parent, tName, templateId, false));
        append(template, ele);
    }
    onCellClick(e) {
        let target = closest(e.target, '.' + WORK_CELLS_CLASS);
        const startDate = this.parent.getDateFromElement(target);
        this.parent.activeCellsData = this.parent.getCellDetails(target);
        const isPrevious = startDate.getTime() < this.getStartDate().getTime();
        if (isPrevious || startDate.getTime() > this.getEndDate().getTime()) {
            this.parent.changeDate(this.parent.activeView.getNextPreviousDate(isPrevious ? 'previous' : 'next'), e);
            const activeDate = this.parent.activeCellsData.startTime.getTime();
            const inRange = activeDate >= this.getStartDate().getTime() && activeDate <= this.getEndDate().getTime();
            const dateAttr = inRange ? activeDate : (isPrevious ? this.getEndDate() : this.getStartDate()).getTime();
            const selectedCell = this.parent.element.querySelector(':not(.' + OTHERMONTH_CLASS + ')[data-date="' + dateAttr + '"]');
            this.parent.selectCell(selectedCell);
            this.parent.activeCellsData = this.parent.getCellDetails(selectedCell);
        }
        else {
            const endDate = addDays(new Date(startDate.getTime()), 1);
            const filteredEvents = this.parent.eventBase.filterEvents(startDate, endDate);
            const moreEventArgs = { date: startDate, event: filteredEvents, element: e.target };
            if (target.classList.contains(OTHERMONTH_CLASS)) {
                target = this.parent.element.querySelector(':not(.' + OTHERMONTH_CLASS + ')[data-date="' + target.getAttribute('data-date') + '"]');
            }
            this.parent.activeCellsData = this.parent.getCellDetails(target);
            const args = extend(this.parent.activeCellsData, { cancel: false, event: e, name: 'cellClick' });
            this.parent.trigger(cellClick, args);
            this.parent.quickPopup.moreEventClick(moreEventArgs, endDate);
        }
    }
    onContentScroll(e) {
        const target = e.target;
        const headerWrapper = this.getDatesHeaderElement();
        this.parent.notify(virtualScroll, e);
        if (headerWrapper) {
            headerWrapper.firstElementChild.scrollLeft = target.scrollLeft;
        }
        const scrollTopSelector = `.${MONTH_HEADER_WRAPPER},.${RESOURCE_COLUMN_WRAP_CLASS}`;
        const scrollTopElement = this.element.querySelector(scrollTopSelector);
        if (scrollTopElement) {
            scrollTopElement.scrollTop = target.scrollTop;
        }
        if (!this.parent.isAdaptive) {
            this.parent.uiStateValues.top = e.target.scrollTop;
        }
        this.parent.uiStateValues.left = e.target.scrollLeft;
        this.setPersistence();
    }
    onScrollUiUpdate(args) {
        let height = this.parent.element.offsetHeight - this.getHeaderBarHeight();
        const headerWrapper = this.element.querySelector('.' + DATE_HEADER_CONTAINER_CLASS);
        if (headerWrapper) {
            height -= headerWrapper.offsetHeight;
        }
        const contentWrapper = this.element.querySelector('.' + CONTENT_WRAP_CLASS);
        if (contentWrapper) {
            contentWrapper.style.height = formatUnit(height);
        }
        if (!this.parent.isAdaptive && headerWrapper) {
            const scrollBarWidth = getScrollBarWidth();
            if (contentWrapper.offsetWidth - contentWrapper.clientWidth > 0) {
                headerWrapper.firstElementChild.style[args.cssProperties.border] = scrollBarWidth > 0 ? '1px' : '0px';
                headerWrapper.style[args.cssProperties.padding] = scrollBarWidth > 0 ? scrollBarWidth - 1 + 'px' : '0px';
            }
            else {
                headerWrapper.firstElementChild.style[args.cssProperties.border] = '';
                headerWrapper.style[args.cssProperties.padding] = '';
            }
        }
        this.setColWidth(this.getContentAreaElement());
        const leftPanelSelector = `.${MONTH_HEADER_WRAPPER},.${RESOURCE_COLUMN_WRAP_CLASS}`;
        const leftPanelElement = this.element.querySelector(leftPanelSelector);
        if (leftPanelElement) {
            const isYScroll = contentWrapper.scrollWidth > contentWrapper.clientWidth;
            leftPanelElement.style.height = formatUnit(height - (isYScroll ? 17 : 0));
        }
        if (!args.isPreventScrollUpdate) {
            if (this.parent.uiStateValues.isInitial) {
                this.parent.uiStateValues.isInitial = false;
                this.parent.uiStateValues.top = this.parent.uiStateValues.left = 0;
            }
            else {
                if (leftPanelElement) {
                    leftPanelElement.scrollTop = this.parent.uiStateValues.top;
                }
                contentWrapper.scrollTop = this.parent.uiStateValues.top;
                contentWrapper.scrollLeft = this.parent.uiStateValues.left;
            }
        }
        this.retainScrollPosition();
    }
    getStartDate() {
        return new Date(this.parent.selectedDate.getFullYear(), this.parent.firstMonthOfYear % 12, 1);
    }
    getEndDate() {
        return addDays(addMonths(this.getStartDate(), this.parent.monthsCount), -1);
    }
    startDate() {
        return this.parent.currentView === 'Year' ? getWeekFirstDate(this.getStartDate(), this.parent.firstDayOfWeek) : this.getStartDate();
    }
    endDate() {
        return this.parent.currentView === 'Year' ? addDays(getWeekLastDate(this.getEndDate(), this.parent.firstDayOfWeek), 1) :
            addDays(this.getEndDate(), 1);
    }
    getEndDateFromStartDate(start) {
        let date = new Date(start.getTime());
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            date = lastDateOfMonth(date);
        }
        return addDays(new Date(date.getTime()), 1);
    }
    getNextPreviousDate(type) {
        return addYears(this.parent.selectedDate, ((type === 'next') ? 1 : -1));
    }
    getDateRangeText() {
        const startDate = this.getStartDate();
        const endDate = this.getEndDate();
        if (startDate.getFullYear() !== endDate.getFullYear()) {
            return this.parent.globalize.formatDate(startDate, { skeleton: 'yMMM' }) + ' - ' + this.parent.globalize.formatDate(endDate, { skeleton: 'yMMM' });
        }
        else {
            return this.parent.globalize.formatDate(this.parent.selectedDate, { skeleton: 'y' });
        }
    }
    addEventListener() {
        this.parent.on(scrollUiUpdate, this.onScrollUiUpdate, this);
        this.parent.on(dataReady, this.onDataReady, this);
    }
    removeEventListener() {
        if (this.parent) {
            this.parent.off(scrollUiUpdate, this.onScrollUiUpdate);
            this.parent.off(dataReady, this.onDataReady);
        }
    }
    onDataReady(args) {
        this.yearEventModule = new YearEvent(this.parent);
        this.yearEventModule.renderAppointments();
        this.parent.notify(eventsLoaded, args);
    }
    scrollToDate(scrollDate) {
        const date = +new Date(resetTime(scrollDate));
        let element = this.element.querySelector('.' + WORK_CELLS_CLASS + ':not(.' + OTHERMONTH_CLASS + ')[data-date="' + date + '"]');
        if (element) {
            element = closest(element, '.e-month-calendar');
            this.getContentAreaElement().scrollTop = element.offsetTop;
        }
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        if (this.element) {
            const contentScroll = this.element.querySelector('.' + CONTENT_WRAP_CLASS);
            if (contentScroll) {
                EventHandler.remove(contentScroll, 'scroll', this.onContentScroll);
            }
            if (this.yearEventModule) {
                this.yearEventModule.destroy();
                this.yearEventModule = null;
            }
            if (this.parent.resourceBase) {
                this.parent.resourceBase.destroy();
            }
            super.destroy();
        }
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
class AgendaBase extends ViewBase {
    constructor(parent) {
        super(parent);
    }
    // eslint-disable-next-line max-len
    createAgendaContentElement(type, listData, aTd, groupOrder, groupIndex) {
        let listElement;
        const fieldMapping = this.parent.eventFields;
        if (type === 'noEvents') {
            const noEvents = [{ 'subject': this.parent.localeObj.getConstant('noEvents') }];
            listElement = ListBase.createList(this.parent.createElement, noEvents, {
                moduleName: 'agenda',
                listClass: this.parent.activeView.viewClass,
                itemClass: this.parent.activeView.viewClass,
                template: `<div class="${AGENDA_NO_EVENT_CLASS}">${this.parent.localeObj.getConstant('noEvents')}</div>`
            });
            if (listElement.querySelector('.e-agenda-item').children.length === 0) {
                listElement.firstElementChild.appendChild(createElement('div', { className: AGENDA_NO_EVENT_CLASS, innerHTML: this.parent.localeObj.getConstant('noEvents') }));
            }
        }
        else {
            listElement = ListBase.createList(this.parent.createElement, listData, {
                moduleName: 'agenda',
                listClass: this.parent.activeView.viewClass,
                itemClass: this.parent.activeView.viewClass
            });
            const listElements = [].slice.call(listElement.children);
            listElements.forEach((element, li) => {
                const appWrapper = createElement('div', {
                    className: APPOINTMENT_CLASS, attrs: {
                        'data-id': 'Appointment_' + listData[parseInt(li.toString(), 10)][`${this.parent.eventFields.id}`],
                        'data-guid': listData[parseInt(li.toString(), 10)].Guid,
                        'role': 'button',
                        'tabindex': '0',
                        'aria-disabled': this.parent.eventBase.getReadonlyAttribute(listData[parseInt(li.toString(), 10)]),
                        'aria-label': this.parent.getAnnouncementString(listData[parseInt(li.toString(), 10)])
                    }
                });
                if (!isNullOrUndefined(groupIndex)) {
                    appWrapper.setAttribute('data-group-index', groupIndex.toString());
                }
                this.parent.eventBase.applyResourceColor(appWrapper, listData[parseInt(li.toString(), 10)], 'borderColor', groupOrder);
                let templateEle;
                if (!isNullOrUndefined(this.parent.activeViewOptions.eventTemplate)) {
                    addClass([appWrapper], EVENT_TEMPLATE);
                    const scheduleId = this.parent.element.id + '_';
                    const viewName = this.parent.activeViewOptions.eventTemplateName;
                    const templateId = scheduleId + viewName + 'eventTemplate';
                    templateEle = this.parent.getAppointmentTemplate()(listData[parseInt(li.toString(), 10)], this.parent, 'eventTemplate', templateId, false);
                    if (!isNullOrUndefined(listData[parseInt(li.toString(), 10)][fieldMapping.recurrenceRule])) {
                        const iconClass = (listData[parseInt(li.toString(), 10)][fieldMapping.id] ===
                            listData[parseInt(li.toString(), 10)][fieldMapping.recurrenceID]) ?
                            EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;
                        appWrapper.appendChild(createElement('div', { className: ICON + ' ' + iconClass }));
                    }
                }
                else {
                    templateEle = this.createAppointment(listData[parseInt(li.toString(), 10)]);
                }
                append([].slice.call(templateEle), appWrapper);
                removeChildren(element);
                element.appendChild(appWrapper);
                const args = {
                    data: extend({}, listData[parseInt(li.toString(), 10)], null, true),
                    element: element, cancel: false
                };
                this.parent.trigger(eventRendered, args, (eventArgs) => {
                    if (eventArgs.cancel) {
                        remove(element);
                    }
                });
            });
        }
        aTd.appendChild(listElement);
        if ((this.parent.currentView === 'MonthAgenda' && this.parent.activeViewOptions.group.resources.length > 0)
            || this.parent.currentView === 'Agenda') {
            addClass([aTd], AGENDA_DAY_BORDER_CLASS);
        }
        this.parent.renderTemplates();
        return aTd;
    }
    createAppointment(event) {
        const fieldMapping = this.parent.eventFields;
        let eventSubject = (event[fieldMapping.subject] || this.parent.eventSettings.fields.subject.default
            || this.parent.localeObj.getConstant('addTitle'));
        const eventLocation = (event[fieldMapping.location] || this.parent.eventSettings.fields.location.default);
        const appSubjectWrap = createElement('div', { className: SUBJECT_WRAP });
        if (!isNullOrUndefined(eventLocation) && eventLocation !== '') {
            eventSubject += ',';
        }
        const appSubjectText = createElement('div', { className: SUBJECT_CLASS });
        this.parent.sanitize(eventSubject, appSubjectText);
        appSubjectWrap.appendChild(appSubjectText);
        if (!isNullOrUndefined(eventLocation) && eventLocation !== '') {
            const appLocation = createElement('div', { className: LOCATION_CLASS });
            this.parent.sanitize(eventLocation, appLocation);
            appSubjectWrap.appendChild(appLocation);
        }
        if (!isNullOrUndefined(event[fieldMapping.recurrenceRule])) {
            const iconClass = (event[fieldMapping.id] === event[fieldMapping.recurrenceID]) ?
                EVENT_RECURRENCE_ICON_CLASS : EVENT_RECURRENCE_EDIT_ICON_CLASS;
            appSubjectWrap.appendChild(createElement('div', { className: ICON + ' ' + iconClass }));
        }
        const strDate = event[fieldMapping.startTime];
        const endDate = event[fieldMapping.endTime];
        const isAllDay = event[fieldMapping.isAllDay];
        let allDayStr = this.parent.localeObj.getConstant('allDay');
        const timeStr = this.parent.getTimeString(strDate) + ' - ' + this.parent.getTimeString(endDate);
        if (!isNullOrUndefined(event.data)) {
            const milliSeconds = (endDate.getTimezoneOffset() !== strDate.getTimezoneOffset()) ?
                (endDate.getTime() - strDate.getTime() + 3600000) : (endDate.getTime() - strDate.getTime());
            const eventString = (milliSeconds / MS_PER_DAY) >= 1 ? allDayStr : timeStr;
            allDayStr = eventString + ' (' + this.parent.localeObj.getConstant('day') + ' '
                + event.data.index + '/' + event.data.count + ')';
        }
        const displayStr = (!isNullOrUndefined(event.data) || isAllDay) ? allDayStr : timeStr;
        const appDateTime = createElement('div', { className: DATE_TIME_CLASS, innerHTML: displayStr });
        return [appSubjectWrap, appDateTime];
    }
    processAgendaEvents(events) {
        let eventsProcessed = [];
        if (isNullOrUndefined(events)) {
            return eventsProcessed;
        }
        for (const event of events) {
            const spanned = this.parent.eventBase.splitEventByDay(event);
            eventsProcessed = eventsProcessed.concat(spanned.length > 1 ? spanned : event);
        }
        return eventsProcessed;
    }
    wireEventActions() {
        const eventElement = [].slice.call(this.parent.element.querySelectorAll('.' + APPOINTMENT_CLASS));
        for (const element of eventElement) {
            this.parent.eventBase.wireAppointmentEvents(element, this.parent.getEventDetails(element), true);
        }
        const dateHeaderElement = [].slice.call(this.parent.element.querySelectorAll('.e-m-date'));
        for (const element of dateHeaderElement) {
            EventHandler.add(element, 'click', this.parent.agendaModule.dayNavigationClick, this);
        }
    }
    calculateResourceTableElement(tBody, noOfDays, agendaDate) {
        if (isNullOrUndefined(this.parent.resourceBase.lastResourceLevel)) {
            const level = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);
            this.parent.resourceBase.generateResourceLevels(level);
        }
        const agendaLastDate = addDays(new Date(agendaDate.getTime()), noOfDays);
        const days = (this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda') ? noOfDays : 1;
        const resColl = this.parent.resourceBase.resourceCollection;
        const resData = this.parent.resourceBase.lastResourceLevel;
        const initialDate = agendaDate;
        for (let i = 0; i < days; i++) {
            const lastLevelInfo = [];
            const tempLastLevelInfo = [];
            let tempIndex = 0;
            let eventObj;
            let dateObj;
            const firstDate = addDays(initialDate, i);
            const finalDate = (this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda')
                ? addDays(firstDate, 1) : agendaLastDate;
            const agendaCollection = this.parent.eventBase.filterEvents(firstDate, finalDate);
            if (agendaCollection.length > 0 || !this.parent.hideEmptyAgendaDays || this.parent.currentView === 'MonthAgenda') {
                for (let res = 0; res < resData.length; res++) {
                    noOfDays = (!this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda') ? noOfDays : 1;
                    const data = [];
                    agendaDate = firstDate;
                    // eslint-disable-next-line max-len
                    const resDataCollection = this.parent.eventBase.filterEvents(agendaDate, agendaLastDate, agendaCollection, resData[parseInt(res.toString(), 10)]);
                    if (resDataCollection.length > 0 || !this.parent.hideEmptyAgendaDays || this.parent.currentView === 'MonthAgenda') {
                        for (let r = 0; r < noOfDays; r++) {
                            // eslint-disable-next-line max-len
                            const resDayCollection = this.parent.eventBase.filterEvents(agendaDate, addDays(agendaDate, 1), resDataCollection, undefined);
                            if (resDayCollection.length > 0 || !this.parent.hideEmptyAgendaDays ||
                                this.parent.currentView === 'MonthAgenda') {
                                data.push(resDayCollection[0]);
                                eventObj = {
                                    rowSpan: 1, type: 'eventColumn', resource: resColl[resColl.length - 1],
                                    groupIndex: resData[parseInt(res.toString(), 10)].groupIndex,
                                    groupOrder: resData[parseInt(res.toString(), 10)].groupOrder,
                                    resourceData: resData[parseInt(res.toString(), 10)].resourceData,
                                    eventData: resDayCollection, date: agendaDate
                                };
                                dateObj = {
                                    rowSpan: 1, type: 'dateColumn', resource: resColl[parseInt((resColl.length - 1).toString(), 10)],
                                    groupOrder: resData[parseInt(res.toString(), 10)].groupOrder,
                                    resourceData: resData[parseInt(res.toString(), 10)].resourceData,
                                    date: agendaDate
                                };
                                if (!lastLevelInfo[parseInt(tempIndex.toString(), 10)]) {
                                    lastLevelInfo[parseInt(tempIndex.toString(), 10)] = [];
                                }
                                lastLevelInfo[parseInt(tempIndex.toString(), 10)].push(eventObj);
                                lastLevelInfo[parseInt(tempIndex.toString(), 10)].push(dateObj);
                                tempIndex++;
                            }
                            agendaDate = addDays(agendaDate, 1);
                            if (agendaDate.getTime() >= agendaLastDate.getTime() || this.parent.activeViewOptions.group.byDate
                                || this.parent.currentView === 'MonthAgenda') {
                                lastLevelInfo[lastLevelInfo.length - 1][1].cssClass = AGENDA_DAY_BORDER_CLASS;
                                const tempObj = {
                                    rowSpan: data.length, type: 'resourceColumn', resource: resColl[parseInt((resColl.length - 1).toString(), 10)],
                                    groupOrder: resData[parseInt(res.toString(), 10)].groupOrder.slice(0, -1),
                                    resourceData: resData[parseInt(res.toString(), 10)].resourceData,
                                    groupIndex: (lastLevelInfo.length - data.length), className: [RESOURCE_NAME],
                                    date: agendaDate
                                };
                                lastLevelInfo[parseInt((lastLevelInfo.length - data.length).toString(), 10)].push(tempObj);
                                tempLastLevelInfo.push(extend({}, tempObj, null, true));
                                break;
                            }
                        }
                    }
                }
                const topResources = resColl.slice(0, -1);
                let tempGroupedData = [];
                let totalRowSpan = 0;
                for (let y = 0; y < topResources.length; y++) {
                    const data = topResources[topResources.length - (y + 1)].dataSource;
                    for (let x = 0; x < data.length; x++) {
                        let z = 0;
                        for (let u = 0; u < tempLastLevelInfo.length; u++) {
                            // eslint-disable-next-line max-len
                            if (tempLastLevelInfo[parseInt(u.toString(), 10)].groupOrder[topResources.length - (y + 1)] === data[parseInt(x.toString(), 10)][topResources[topResources.length - (y + 1)].idField]) {
                                totalRowSpan = totalRowSpan + tempLastLevelInfo[parseInt(u.toString(), 10)].rowSpan;
                                tempGroupedData.push(extend({}, tempLastLevelInfo[parseInt(u.toString(), 10)], null, true));
                            }
                            if (++z === tempLastLevelInfo.length && tempGroupedData.length > 0) {
                                tempGroupedData[0].rowSpan = totalRowSpan;
                                tempGroupedData[0].type = 'parentColumnLevel_' + (y + 1);
                                tempGroupedData[0].resource = topResources[topResources.length - (y + 1)];
                                tempGroupedData[0].resourceData = data[parseInt(x.toString(), 10)];
                                tempGroupedData[0].date = agendaDate;
                                lastLevelInfo[tempGroupedData[0].groupIndex].push(tempGroupedData[0]);
                                tempGroupedData = [];
                                totalRowSpan = 0;
                            }
                        }
                    }
                }
                this.createResourceTableRow(lastLevelInfo, tBody);
            }
        }
        const totalCollection = this.parent.eventBase.filterEvents(initialDate, agendaLastDate);
        if (totalCollection.length === 0 && !this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays) {
            this.renderEmptyContent(tBody, initialDate);
        }
    }
    createResourceTableRow(tContent, tBody) {
        const tr = createElement('tr');
        let ntr;
        const td = createElement('td', { attrs: { 'aria-selected': 'false' } });
        let tempData;
        let rowSpan = 0;
        let level;
        if (this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda') {
            let tContentCollection = [];
            const parentCollection = this.parent.resourceBase.resourceCollection.slice(0, -1);
            for (let w = 0; w < tContent.length; w++) {
                tContentCollection = tContentCollection.concat(tContent[parseInt(w.toString(), 10)]);
            }
            level = (parentCollection.length > 0) ? 'parentColumnLevel_' + parentCollection.length : 'resourceColumn';
            const rowSpanCollection = tContentCollection.filter((data) => data.type === level);
            for (let x = 0; x < rowSpanCollection.length; x++) {
                rowSpan = rowSpan + rowSpanCollection[parseInt(x.toString(), 10)].rowSpan;
            }
        }
        for (let row = 0; row < tContent.length; row++) {
            ntr = tr.cloneNode();
            for (let col = tContent[parseInt(row.toString(), 10)].length - 1; col >= 0; col--) {
                const data = tContent[parseInt(row.toString(), 10)][parseInt(col.toString(), 10)];
                let ntd = td.cloneNode();
                if (data.type === 'dateColumn') {
                    if (this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda') {
                        tempData = tContent[parseInt(row.toString(), 10)][parseInt(col.toString(), 10)];
                        continue;
                    }
                    ntd.setAttribute('data-date', data.date.getTime().toString());
                    ntd.appendChild(this.createDateHeaderElement(data.date));
                    const className = [AGENDA_CELLS_CLASS, AGENDA_DATE_CLASS];
                    if (data.cssClass) {
                        className.push(data.cssClass);
                    }
                    addClass([ntd], className);
                    ntr.appendChild(ntd);
                }
                else if (data.type === 'eventColumn') {
                    const elementType = (data.eventData.length === 0) ? 'noEvents' : 'data';
                    ntd = this.createAgendaContentElement(elementType, data.eventData, ntd, data.groupOrder, data.groupIndex);
                    ntd.setAttribute('data-date', data.date.getTime().toString());
                    if (this.parent.activeViewOptions.group.byDate || this.parent.currentView === 'MonthAgenda') {
                        addClass([ntd], [AGENDA_CELLS_CLASS, AGENDA_DAY_PADDING_CLASS]);
                    }
                    ntr.appendChild(ntd);
                }
                else {
                    ntd.setAttribute('rowspan', data.rowSpan.toString());
                    addClass([ntd], AGENDA_RESOURCE_CLASS);
                    this.setResourceHeaderContent(ntd, data, data.className[0]);
                    ntr.appendChild(ntd);
                }
            }
            if (this.parent.activeViewOptions.group.byDate && row === 0 && this.parent.currentView !== 'MonthAgenda') {
                const ntd = td.cloneNode();
                ntd.setAttribute('data-date', tempData.date.getTime().toString());
                ntd.setAttribute('rowspan', rowSpan.toString());
                ntd.appendChild(this.createDateHeaderElement(tempData.date));
                addClass([ntd], [AGENDA_CELLS_CLASS, AGENDA_DATE_CLASS, DATE_BORDER_CLASS]);
                const daysCount = getDaysCount(this.parent.selectedDate.getTime(), tempData.date.getTime());
                ntr.setAttribute('data-row-index', daysCount.toString());
                if (this.parent.element.querySelector(`.e-agenda-view tr[data-row-index="${daysCount}"]`)) {
                    break;
                }
                ntr.insertBefore(ntd, ntr.childNodes[0]);
            }
            tBody.appendChild(ntr);
        }
    }
    createDateHeaderElement(date) {
        let dateHeader;
        if (this.parent.activeViewOptions.dateHeaderTemplate) {
            dateHeader = createElement('div', { className: AGENDA_HEADER_CLASS });
            const args = { date: date, type: 'dateHeader' };
            const scheduleId = this.parent.element.id + '_';
            const viewName = this.parent.activeViewOptions.dateHeaderTemplateName;
            const templateId = scheduleId + viewName + 'dateHeaderTemplate';
            const dateTemplate = [].slice.call(this.parent.getDateHeaderTemplate()(args, this.parent, 'dateHeaderTemplate', templateId, false));
            append(dateTemplate, dateHeader);
        }
        else {
            dateHeader = this.getMobileDateElement(date, AGENDA_HEADER_CLASS);
        }
        return dateHeader;
    }
    renderEmptyContent(tBody, agendaDate) {
        const eTr = this.createTableRowElement(agendaDate, 'noEvents');
        const eTd = eTr.children[0];
        const noEvents = createElement('div', {
            className: AGENDA_EMPTY_EVENT_CLASS,
            innerHTML: this.parent.localeObj.getConstant('noEvents')
        });
        eTd.appendChild(noEvents);
        tBody.appendChild(eTr);
    }
    createTableRowElement(date, type) {
        const daysCount = getDaysCount(this.parent.selectedDate.getTime(), date.getTime());
        const tr = createElement('tr', { attrs: { 'data-row-index': daysCount.toString() } });
        const td = createElement('td', {
            attrs: {
                'class': (type === 'monthHeader') ? MONTH_HEADER_CLASS : AGENDA_CELLS_CLASS,
                'aria-selected': 'false',
                'data-column-index': daysCount.toString(),
                'data-date': date.getTime().toString()
            }
        });
        const dTd = td.cloneNode();
        const aTd = td.cloneNode();
        tr.appendChild(dTd);
        if (type !== 'noEvents') {
            tr.appendChild(aTd);
        }
        return tr;
    }
    destroy() {
        super.destroy();
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * agenda view
 */
class Agenda extends AgendaBase {
    constructor(parent) {
        super(parent);
        this.viewClass = 'e-agenda-view';
        this.isInverseTableSelect = false;
        this.agendaDates = {};
        this.virtualScrollTop = 1;
    }
    getModuleName() {
        return 'agenda';
    }
    renderLayout() {
        this.agendaDates = {};
        this.element = createElement('div', { className: TABLE_WRAP_CLASS });
        addClass([this.element], this.viewClass);
        this.element.appendChild(this.createTableLayout(OUTER_TABLE_CLASS));
        this.element.querySelector('table').setAttribute('role', 'presentation');
        this.parent.element.querySelector('.' + TABLE_CONTAINER_CLASS).appendChild(this.element);
        const eTr = createElement('tr');
        this.element.querySelector('tbody').appendChild(eTr);
        const workTd = createElement('td');
        eTr.appendChild(workTd);
        const wrap = createElement('div', { className: CONTENT_WRAP_CLASS });
        workTd.appendChild(wrap);
        const tbl = this.createTableLayout(CONTENT_TABLE_CLASS);
        this.setAriaAttributes(tbl);
        wrap.appendChild(tbl);
        const tBody = tbl.querySelector('tbody');
        const agendaDate = resetTime(this.parent.selectedDate);
        this.renderEmptyContent(tBody, agendaDate);
        this.wireEvents();
        if (this.parent.resourceBase) {
            this.parent.resourceBase.generateResourceLevels([{ renderDates: this.parent.activeView.renderDates }]);
        }
        if (this.parent.uiStateValues.isGroupAdaptive && !this.parent.element.querySelector('.' + RESOURCE_TOOLBAR_CONTAINER)) {
            this.renderResourceMobileLayout();
        }
        this.parent.notify(contentReady, {});
    }
    eventLoad(args) {
        this.dataSource = extend([], this.parent.eventsData, null, true);
        for (const event of this.parent.eventsData) {
            delete event.generatedDates;
        }
        let eventCollection = this.parent.activeViewOptions.allowVirtualScrolling ?
            args.processedData : this.parent.eventsProcessed;
        if (this.parent.uiStateValues.isGroupAdaptive) {
            const resource = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];
            this.dataSource = this.parent.eventBase.filterEventsByResource(resource, this.dataSource);
            eventCollection = this.parent.eventBase.filterEventsByResource(resource, eventCollection);
        }
        this.parent.eventsProcessed = this.processAgendaEvents(eventCollection);
        const agendaDate = resetTime(this.parent.selectedDate);
        const tBody = this.element.querySelector('.' + CONTENT_TABLE_CLASS + ' tbody');
        removeChildren(tBody);
        this.renderInitialContent(tBody, agendaDate);
        this.wireEventActions();
        const contentArea = closest(tBody, '.' + CONTENT_WRAP_CLASS);
        contentArea.scrollTop = 1;
        this.parent.notify(eventsLoaded, {});
        if (!this.parent.activeViewOptions.allowVirtualScrolling) {
            this.retainScrollPosition();
        }
    }
    refreshEvent(refreshDate) {
        let processedData = [];
        const fields = this.parent.eventFields;
        for (const data of this.dataSource) {
            if (isNullOrUndefined(data[fields.recurrenceID]) && !isNullOrUndefined(data[fields.recurrenceRule]) &&
                !isNullOrUndefined(data.generatedDates) && refreshDate >= data.generatedDates.end) {
                processedData = processedData.concat(this.parent.eventBase.generateOccurrence(data, refreshDate));
            }
        }
        this.parent.eventsProcessed = this.parent.eventsProcessed.concat(this.processAgendaEvents(processedData));
    }
    refreshHeader() {
        const tBody = this.element.querySelector('.' + CONTENT_TABLE_CLASS + ' tbody');
        if (this.parent.activeViewOptions.group.byDate) {
            removeChildren(tBody);
        }
        else {
            remove(tBody.firstElementChild);
        }
        const agendaDate = resetTime(this.parent.selectedDate);
        const emptyTBody = createElement('tbody');
        const firstDate = new Date(agendaDate.getTime());
        const lastDate = (this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays) ?
            this.getEndDateFromStartDate(firstDate) : addDays(firstDate, this.parent.agendaDaysCount);
        this.renderContent(emptyTBody, firstDate, lastDate);
        append([].slice.call(emptyTBody.childNodes), tBody);
    }
    renderInitialContent(tBody, agendaDate) {
        const emptyTBody = createElement('tbody');
        let firstDate = new Date(agendaDate.getTime());
        let lastDate = (this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays) ?
            this.getEndDateFromStartDate(firstDate) : addDays(firstDate, this.parent.agendaDaysCount);
        this.renderContent(emptyTBody, firstDate, lastDate);
        append([].slice.call(emptyTBody.childNodes), tBody);
        // Initial rendering, to load previous date events upto scroll bar enable
        if (this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays && this.parent.eventsData.length > 0) {
            const contentArea = this.getContentAreaElement();
            const contentChild = contentArea.querySelector('.e-content-table');
            while (contentArea.offsetWidth <= contentArea.clientWidth) {
                if (this.parent.isAdaptive && contentChild.offsetHeight >= contentArea.clientHeight) {
                    break;
                }
                const emptyTBody = createElement('tbody');
                lastDate = firstDate;
                firstDate = addDays(lastDate, -this.parent.agendaDaysCount);
                this.renderContent(emptyTBody, firstDate, lastDate);
                prepend([].slice.call(emptyTBody.childNodes), tBody);
                if (firstDate <= this.parent.minDate) {
                    break;
                }
            }
        }
        if (tBody.childNodes.length <= 0) {
            this.renderEmptyContent(tBody, agendaDate);
        }
    }
    renderContent(tBody, agendaDate, lastDate) {
        const fieldMapping = this.parent.eventFields;
        const firstDate = new Date(agendaDate.getTime());
        const isObject = this.appointmentFiltering(firstDate, lastDate);
        if (isObject.length > 0 && this.parent.activeViewOptions.allowVirtualScrolling && this.parent.hideEmptyAgendaDays) {
            agendaDate = isObject[0][fieldMapping.startTime];
            agendaDate = new Date(new Date(agendaDate.getTime()).setHours(0, 0, 0, 0));
            this.updateHeaderText(isObject[0][fieldMapping.startTime]);
        }
        let endDate;
        if (!this.parent.hideEmptyAgendaDays || (this.parent.agendaDaysCount > 0 && isObject.length > 0)) {
            if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
                let date = agendaDate;
                if (!this.parent.activeViewOptions.group.byDate) {
                    this.parent.activeViewOptions.allowVirtualScrolling = false;
                    date = firstDate;
                    if (this.parent.headerModule) {
                        this.parent.headerModule.updateDateRange();
                        this.parent.headerModule.updateHeaderItems('remove');
                    }
                }
                this.calculateResourceTableElement(tBody, this.parent.agendaDaysCount, date);
            }
            else {
                for (let day = 0; day < this.parent.agendaDaysCount; day++) {
                    const filterData = this.appointmentFiltering(agendaDate);
                    const nTr = this.createTableRowElement(agendaDate, 'data');
                    if (this.element.querySelector('tr[data-row-index="' + parseInt(nTr.getAttribute('data-row-index'), 10) + '"]')) {
                        agendaDate = addDays(agendaDate, 1);
                        continue;
                    }
                    const dTd = nTr.children[0];
                    const aTd = nTr.children[1];
                    if (filterData.length > 0 || (!this.parent.hideEmptyAgendaDays && filterData.length === 0)) {
                        const elementType = (!this.parent.hideEmptyAgendaDays && filterData.length === 0) ? 'noEvents' : 'data';
                        dTd.appendChild(this.createDateHeaderElement(agendaDate));
                        nTr.appendChild(dTd);
                        const cTd = this.createAgendaContentElement(elementType, filterData, aTd);
                        nTr.appendChild(cTd);
                        if (cTd.querySelectorAll('li').length > 0) {
                            tBody.appendChild(nTr);
                        }
                    }
                    else if (this.parent.activeViewOptions.allowVirtualScrolling) {
                        day--;
                    }
                    if (this.isCurrentDate(new Date(agendaDate.getTime()))) {
                        addClass(dTd.childNodes, AGENDA_CURRENT_DAY_CLASS);
                    }
                    agendaDate = addDays(agendaDate, 1);
                    if (agendaDate.getTime() > lastDate.getTime()) {
                        break;
                    }
                }
            }
            endDate = new Date(agendaDate.getTime() - MS_PER_DAY);
        }
        this.agendaDates = { start: firstDate, end: endDate };
    }
    agendaScrolling(event) {
        if (this.parent.quickPopup) {
            this.parent.quickPopup.quickPopupHide();
        }
        if (this.parent.activeViewOptions.allowVirtualScrolling) {
            this.virtualScrolling(event);
        }
        if (!this.parent.activeViewOptions.allowVirtualScrolling) {
            this.setPersistence();
        }
    }
    virtualScrolling(event) {
        const target = event.target;
        const scrollTop = target.scrollTop;
        const scrollHeight = target.scrollHeight;
        const offsetHeight = target.clientHeight;
        const totalHeight = scrollTop + offsetHeight;
        const direction = (this.virtualScrollTop < scrollTop) ? 'next' : 'previous';
        const tBody = target.querySelector('tbody');
        const emptyTBody = createElement('tbody');
        const topElement = this.getElementFromScrollerPosition(event);
        const scrollDate = this.parent.getDateFromElement(topElement);
        let filterDate;
        let filterData;
        if (scrollTop === 0) {
            filterDate = this.getPreviousNextDate(addDays(scrollDate, -1), direction);
            filterData = this.appointmentFiltering(filterDate.start, filterDate.end);
            if (filterData.length > 0 || !this.parent.hideEmptyAgendaDays) {
                this.renderContent(emptyTBody, filterDate.start, filterDate.end);
                prepend([].slice.call(emptyTBody.childNodes), tBody);
                this.wireEventActions();
                for (let s = 0, element = tBody.children; s < element.length; s++) {
                    if (element[parseInt(s.toString(), 10)].getAttribute('data-row-index') === topElement.getAttribute('data-column-index')) {
                        const scrollToValue = element[parseInt(s.toString(), 10)].offsetTop -
                            this.element.querySelector('.e-agenda-item').offsetHeight;
                        target.scrollTop = scrollToValue;
                        break;
                    }
                }
                this.updateHeaderText(scrollDate);
            }
        }
        else if (totalHeight >= (scrollHeight - 5)) {
            filterDate = this.getPreviousNextDate(addDays(scrollDate, 1), direction);
            filterData = this.appointmentFiltering(filterDate.start, filterDate.end);
            if (filterData.length > 0 || !this.parent.hideEmptyAgendaDays) {
                this.renderContent(emptyTBody, filterDate.start, filterDate.end);
                append([].slice.call(emptyTBody.childNodes), tBody);
                this.wireEventActions();
                this.updateHeaderText(scrollDate);
            }
        }
        else {
            this.updateHeaderText(scrollDate);
        }
        this.virtualScrollTop = scrollTop;
        const selectedElements = this.parent.eventBase.getSelectedAppointments();
        if (selectedElements.length > 0) {
            selectedElements[selectedElements.length - 1].focus();
        }
    }
    getElementFromScrollerPosition(event) {
        let filterElement;
        const target = event.target;
        const scrollTop = target.scrollTop;
        const scrollHeight = target.scrollHeight;
        const offsetHeight = target.clientHeight;
        const totalHeight = scrollTop + offsetHeight;
        const liCollection = [].slice.call(target.querySelectorAll('.e-agenda-item'));
        let li;
        let liDetails;
        if (liCollection.length > 0) {
            if (scrollTop === 0) {
                li = liCollection[0];
                filterElement = closest(li, '.' + AGENDA_CELLS_CLASS);
            }
            else if (totalHeight === scrollHeight) {
                li = liCollection[liCollection.length - 1];
                filterElement = closest(li, '.' + AGENDA_CELLS_CLASS);
            }
            else {
                for (let a = 0, length = liCollection.length; a < length; a++) {
                    li = liCollection[parseInt(a.toString(), 10)];
                    liDetails = li.getBoundingClientRect();
                    if (liDetails.top >= 0) {
                        filterElement = closest(li, '.' + AGENDA_CELLS_CLASS);
                        break;
                    }
                }
            }
        }
        return filterElement;
    }
    updateHeaderText(date) {
        if (this.parent.showHeaderBar) {
            this.parent.headerModule.updateDateRange(date);
        }
    }
    getPreviousNextDate(date, type) {
        let currentDate = new Date(date.getTime());
        const firstDate = this.getStartDateFromEndDate(date);
        const lastDate = this.getEndDateFromStartDate(date);
        let daysCount = 0;
        do {
            const filterData = this.appointmentFiltering(currentDate);
            if (filterData.length > 0 || !this.parent.hideEmptyAgendaDays) {
                daysCount++;
            }
            currentDate = addDays(currentDate, (type === 'next') ? 1 : -1);
            if (currentDate < firstDate || currentDate > lastDate) {
                break;
            }
        } while (daysCount !== this.parent.agendaDaysCount);
        const endDate = addDays(currentDate, (type === 'next') ? -1 : 1);
        return (type === 'next') ? { start: date, end: addDays(endDate, 1) } : { start: endDate, end: addDays(date, 1) };
    }
    appointmentFiltering(startDate, endDate) {
        let dateStart;
        let dateEnd;
        if (!isNullOrUndefined(startDate) && isNullOrUndefined(endDate)) {
            dateStart = resetTime(new Date(startDate.getTime()));
            dateEnd = setTime(new Date(dateStart.getTime()), MS_PER_DAY);
        }
        else {
            dateStart = new Date(startDate.getTime());
            dateEnd = new Date(endDate.getTime());
        }
        let filterData = this.parent.eventBase.filterEvents(dateStart, dateEnd);
        if (filterData.length === 0) {
            this.refreshEvent(startDate);
            filterData = this.parent.eventBase.filterEvents(dateStart, dateEnd);
        }
        return filterData;
    }
    getStartDateFromEndDate(endDate) {
        let filterDate;
        const fields = this.parent.eventFields;
        if (this.parent.eventsProcessed.length > 0) {
            const firstDate = Math.min(...this.parent.eventsProcessed.map((a) => a[fields.startTime].getTime()));
            filterDate = this.parent.hideEmptyAgendaDays ? new Date(firstDate) : this.parent.minDate;
        }
        else {
            filterDate = this.parent.hideEmptyAgendaDays ? addMonths(endDate, -1) : this.parent.minDate;
        }
        return resetTime(filterDate);
    }
    getEndDateFromStartDate(startDate) {
        let filterDate;
        const fieldMapping = this.parent.eventFields;
        if (this.parent.eventsProcessed.length > 0) {
            const lastDate = Math.max(...this.parent.eventsProcessed.map((a) => a[fieldMapping.endTime].getTime()));
            filterDate = this.parent.hideEmptyAgendaDays ? new Date(lastDate) : this.parent.maxDate;
        }
        else {
            filterDate = this.parent.hideEmptyAgendaDays ? addMonths(startDate, 1) : this.parent.maxDate;
        }
        return resetTime(addDays(filterDate, 1));
    }
    getNextPreviousDate(type) {
        const noOfDays = (type === 'next') ? 1 : -1;
        return addDays(this.parent.selectedDate, noOfDays);
    }
    startDate() {
        return resetTime(this.parent.selectedDate);
    }
    endDate() {
        if (this.parent.activeViewOptions.allowVirtualScrolling) {
            return this.getEndDateFromStartDate(this.startDate());
        }
        else {
            return addDays(this.startDate(), this.parent.agendaDaysCount);
        }
    }
    getDateRangeText(date) {
        const formatDate = (this.parent.activeViewOptions.dateFormat) ? this.parent.activeViewOptions.dateFormat : 'MMMM y';
        if (this.parent.activeViewOptions.allowVirtualScrolling || this.parent.isAdaptive) {
            const currentDate = isNullOrUndefined(date) ? this.parent.selectedDate : date;
            return capitalizeFirstWord(this.parent.globalize.formatDate(currentDate, { format: formatDate, calendar: this.parent.getCalendarMode() }), 'multiple');
        }
        else {
            const startDate = this.parent.selectedDate;
            const endDate = addDays(startDate, this.parent.agendaDaysCount - 1);
            return this.formatDateRange(startDate, endDate);
        }
    }
    dayNavigationClick(e) {
        const element = closest(e.currentTarget, '.' + AGENDA_CELLS_CLASS);
        const date = this.parent.getDateFromElement(element);
        if (!isNullOrUndefined(date) && !this.parent.isAdaptive && this.parent.isMinMaxDate(date)) {
            this.parent.setProperties({ selectedDate: date }, true);
            this.parent.changeView('Day', e);
        }
    }
    wireEvents() {
        EventHandler.add(this.element.querySelector('.' + CONTENT_WRAP_CLASS), scroll, this.agendaScrolling, this);
    }
    unWireEvents() {
        EventHandler.remove(this.element.querySelector('.' + CONTENT_WRAP_CLASS), scroll, this.agendaScrolling);
        const dateHeaderElement = [].slice.call(this.element.querySelectorAll('.e-m-date'));
        for (const element of dateHeaderElement) {
            EventHandler.remove(element, 'click', this.dayNavigationClick);
        }
    }
    addEventListener() {
        this.parent.on(scrollUiUpdate, this.onAgendaScrollUiUpdate, this);
        this.parent.on(dataReady, this.eventLoad, this);
    }
    removeEventListener() {
        if (this.parent) {
            this.parent.off(scrollUiUpdate, this.onAgendaScrollUiUpdate);
            this.parent.off(dataReady, this.eventLoad);
        }
    }
    onAgendaScrollUiUpdate() {
        const headerHeight = this.getHeaderBarHeight();
        if (this.parent.headerModule) {
            if (this.parent.activeViewOptions.allowVirtualScrolling) {
                this.parent.headerModule.updateHeaderItems('add');
            }
            else {
                this.parent.headerModule.updateHeaderItems('remove');
            }
        }
        const contentArea = this.element.querySelector('.' + CONTENT_WRAP_CLASS);
        if (this.parent.height !== 'auto') {
            contentArea.style.height = formatUnit(this.parent.element.offsetHeight - headerHeight);
        }
    }
    scrollToDate(scrollDate) {
        const date = new Date(+resetTime(scrollDate));
        if (this.parent.activeViewOptions.allowVirtualScrolling) {
            if (!this.parent.hideEmptyAgendaDays || this.parent.getEvents(date, addDays(date, 1), true).length > 0) {
                this.parent.changeDate(date);
            }
        }
        else {
            const dateElement = this.element.querySelector('.' + AGENDA_CELLS_CLASS + '[data-date="' + date.getTime() + '"]');
            if (dateElement) {
                this.getContentAreaElement().scrollTop = dateElement.offsetTop;
            }
        }
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        if (this.element) {
            this.unWireEvents();
            if (this.parent.resourceBase) {
                this.parent.resourceBase.destroy();
            }
            if (this.parent.headerModule && this.parent.activeViewOptions.allowVirtualScrolling) {
                this.parent.headerModule.updateHeaderItems('remove');
            }
            super.destroy();
        }
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * month agenda view
 */
class MonthAgenda extends Month {
    constructor(parent) {
        super(parent);
        this.dayNameFormat = 'narrow';
        this.viewClass = 'e-month-agenda-view';
        this.monthAgendaDate = new Date('' + parent.selectedDate);
    }
    getModuleName() {
        return 'monthAgenda';
    }
    renderAppointmentContainer() {
        const contentArea = this.getContentAreaElement();
        const wrapperContainer = createElement('div', { className: WRAPPER_CONTAINER_CLASS });
        contentArea.appendChild(wrapperContainer);
        const appWrap = createElement('div', { className: APPOINTMENT_WRAP_CLASS });
        wrapperContainer.appendChild(appWrap);
        this.appendAppContainer(appWrap);
        this.setEventWrapperHeight();
    }
    getDayNameFormat() {
        if (this.parent.isAdaptive) {
            return 'narrow';
        }
        return 'abbreviated';
    }
    updateSelectedCellClass(data) {
        if (resetTime(data.date).getTime() === resetTime(this.monthAgendaDate).getTime()) {
            data.className.push(SELECTED_CELL_CLASS);
        }
    }
    setEventWrapperHeight() {
        let headerHeight = (this.parent.headerModule ? this.parent.headerModule.getHeaderElement().offsetHeight : 0) + 2;
        const resourceWrapper = this.parent.element.querySelector('.' + RESOURCE_HEADER_TOOLBAR);
        if (resourceWrapper) {
            headerHeight += resourceWrapper.offsetHeight;
        }
        const contentArea = this.getContentAreaElement().firstElementChild;
        const dateHeader = this.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);
        const availHeight = this.parent.element.offsetHeight - headerHeight - dateHeader.offsetHeight;
        const contentAreaHeight = (this.parent.activeViewOptions.interval > 1) ?
            Math.round(availHeight * 0.8) : contentArea.offsetHeight;
        const appContainerHeight = availHeight - contentAreaHeight;
        const wrapperContainer = this.element.querySelector('.' + WRAPPER_CONTAINER_CLASS);
        const eventWrapper = this.element.querySelector('.' + APPOINTMENT_WRAP_CLASS);
        if (this.parent.height !== 'auto') {
            if (this.parent.activeViewOptions.interval > 1) {
                contentArea.style.height = formatUnit(contentAreaHeight);
                EventHandler.add(contentArea, 'scroll', this.onContentScroll, this);
            }
            wrapperContainer.style.height = eventWrapper.style.height = formatUnit(appContainerHeight);
        }
    }
    onDataReady(args) {
        this.setEventWrapperHeight();
        this.clearElements();
        let eventCollection = args.processedData;
        if (this.parent.uiStateValues.isGroupAdaptive) {
            const resource = this.parent.resourceBase.lastResourceLevel[this.parent.uiStateValues.groupIndex];
            eventCollection = this.parent.eventBase.filterEventsByResource(resource, eventCollection);
        }
        this.agendaBase = this.getAgendaBase();
        this.parent.eventsProcessed = this.agendaBase.processAgendaEvents(eventCollection);
        let count = 0;
        for (const date of this.renderDates) {
            const filterData = this.appointmentFiltering(date);
            const workCell = this.element.querySelectorAll('.' + WORK_CELLS_CLASS)[parseInt(count.toString(), 10)];
            if (filterData.length > 0) {
                if (!workCell.querySelector('.' + APPOINTMENT_INDICATOR_CLASS)) {
                    workCell.appendChild(createElement('div', { className: APPOINTMENT_INDICATOR_CLASS }));
                }
                if (date.getTime() === resetTime(new Date(this.monthAgendaDate.getTime())).getTime()) {
                    this.onEventRender(filterData, date);
                }
            }
            count++;
        }
        this.parent.notify(eventsLoaded, {});
    }
    onCellClick(event) {
        if (this.parent.quickPopup) {
            this.parent.quickPopup.quickPopupHide();
        }
        const filterData = this.appointmentFiltering(event.startTime);
        this.onEventRender(filterData, event.startTime);
        this.parent.notify(eventsLoaded, {});
        this.monthAgendaDate = new Date('' + event.startTime);
    }
    onEventRender(events, date) {
        this.agendaBase = this.getAgendaBase();
        const appWrap = this.element.querySelector('.' + APPOINTMENT_WRAP_CLASS);
        removeChildren(appWrap);
        if (this.parent.activeViewOptions.group.resources.length === 0 || this.parent.uiStateValues.isGroupAdaptive) {
            if (events.length > 0) {
                const appContainer = createElement('div', { className: APPOINTMENT_CONTAINER_CLASS });
                appWrap.appendChild(this.agendaBase.createAgendaContentElement('data', events, appContainer));
            }
            else {
                this.appendAppContainer(appWrap);
            }
        }
        else {
            if (events.length > 0) {
                const table = this.createTableLayout();
                const tBody = table.querySelector('tbody');
                this.agendaBase.calculateResourceTableElement(tBody, 1, date);
                table.appendChild(tBody);
                appWrap.appendChild(table);
            }
            else {
                this.appendAppContainer(appWrap);
            }
        }
        this.agendaBase.wireEventActions();
    }
    appointmentFiltering(date) {
        const dateStart = resetTime(new Date(date.getTime()));
        const dateEnd = setTime(new Date(dateStart.getTime()), MS_PER_DAY);
        return this.parent.eventBase.filterEvents(dateStart, dateEnd);
    }
    clearElements() {
        const appointmentIndicators = [].slice.call(this.element.querySelectorAll('.' + APPOINTMENT_INDICATOR_CLASS));
        for (const appointmentIndicator of appointmentIndicators) {
            remove(appointmentIndicator);
        }
        this.appendAppContainer(this.element.querySelector('.' + APPOINTMENT_WRAP_CLASS));
    }
    appendAppContainer(appWrap) {
        const app = createElement('div', { className: APPOINTMENT_CONTAINER_CLASS });
        addClass([app], AGENDA_NO_EVENT_CLASS);
        app.innerHTML = this.parent.localeObj.getConstant('noEvents');
        removeChildren(appWrap);
        appWrap.appendChild(app);
    }
    getNextPreviousDate(type) {
        const selectedDate = this.parent.selectedDate;
        const interval = (type === 'next') ? this.parent.activeViewOptions.interval : -this.parent.activeViewOptions.interval;
        const navigateDate = addMonths(this.parent.selectedDate, interval);
        const month = (type === 'next') ? 2 : 0;
        const lastDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + month, 0).getDate();
        const date = (lastDate >= this.monthAgendaDate.getDate()) ? this.monthAgendaDate.getDate() : lastDate;
        this.monthAgendaDate = new Date(navigateDate.getFullYear(), navigateDate.getMonth(), date);
        return this.monthAgendaDate;
    }
    getAgendaBase() {
        return this.agendaBase || new AgendaBase(this.parent);
    }
    destroy() {
        if (this.agendaBase) {
            this.agendaBase.destroy();
            this.agendaBase = null;
        }
        super.destroy();
    }
}

/**
 * timeline header rows
 */
class TimelineHeaderRow {
    constructor(parent, renderDates) {
        this.parent = parent;
        this.renderDates = renderDates;
    }
    groupByYear(dates) {
        const result = {};
        for (const d of dates) {
            const key = d.getFullYear();
            result[parseInt(key.toString(), 10)] = result[parseInt(key.toString(), 10)] || [];
            result[parseInt(key.toString(), 10)].push(d);
        }
        return result;
    }
    groupByMonth(dates) {
        const result = {};
        for (const d of dates) {
            const key = (d.getFullYear() - 1970) * 12 + d.getMonth();
            result[parseInt(key.toString(), 10)] = result[parseInt(key.toString(), 10)] || [];
            result[parseInt(key.toString(), 10)].push(d);
        }
        return result;
    }
    groupByWeek(dates) {
        const result = {};
        for (const d of dates) {
            const jsDate = +new Date(1970, 0, 1);
            const tzOffsetDiff = d.getTimezoneOffset() - new Date(1970, 0, 1).getTimezoneOffset();
            let key = Math.ceil(((((+d - jsDate) - (tzOffsetDiff * 60 * 1000)) / MS_PER_DAY) + new Date(jsDate).getDay() + 1) / 7);
            if (this.parent.firstDayOfWeek && this.parent.firstDayOfWeek > new Date(+d).getDay()) {
                key = key - 1;
            }
            result[parseInt(key.toString(), 10)] = result[parseInt(key.toString(), 10)] || [];
            result[parseInt(key.toString(), 10)].push(d);
        }
        return result;
    }
    generateSlots(data, colspan, row, cls, type) {
        const dateParser = (date, format) => this.parent.globalize.formatDate(date, { format: format, calendar: this.parent.getCalendarMode() });
        const tdDatas = [];
        const keys = Object.keys(data);
        for (let i = 0; i < keys.length; i++) {
            const dates = data[keys[parseInt(i.toString(), 10)]];
            let htmlCol;
            if (row.template) {
                const args = { date: dates[0], type: type };
                const templateId = this.parent.element.id + '_headerRowTemplate';
                htmlCol = [].slice.call(this.parent.templateParser(row.template)(args, this.parent, 'template', templateId, false));
            }
            else {
                let viewTemplate;
                switch (row.option) {
                    case 'Year':
                        viewTemplate = `<span class="e-header-year">${dateParser(dates[0], 'y')}</span>`;
                        break;
                    case 'Month':
                        viewTemplate = `<span class="e-header-month">${capitalizeFirstWord(dateParser(dates[0], 'MMMM'), 'single')}</span>`;
                        break;
                    case 'Week':
                        viewTemplate = `<span class="e-header-week">${this.parent.getWeekNumberContent(dates)}</span>`;
                }
                const headerWrapper = createElement('div', { innerHTML: viewTemplate });
                htmlCol = [].slice.call(headerWrapper.childNodes);
            }
            tdDatas.push({ date: dates[0], type: type, className: [cls], colSpan: dates.length * colspan, template: htmlCol });
        }
        return tdDatas;
    }
    generateColumnLevels(dateSlots, hourSlots) {
        const levels = [];
        const rows = this.parent.activeViewOptions.headerRows;
        let lastLevelColspan = 1;
        if (rows[rows.length - 1].option === 'Hour' && hourSlots.length > 0) {
            lastLevelColspan = hourSlots.length / dateSlots.length;
        }
        let tdDatas = [];
        let byYear;
        let byMonth;
        let byWeek;
        for (const row of rows) {
            switch (row.option) {
                case 'Year':
                    byYear = this.groupByYear(this.renderDates);
                    tdDatas = this.generateSlots(byYear, lastLevelColspan, row, 'e-header-year-cell', 'yearHeader');
                    levels.push(tdDatas);
                    break;
                case 'Month':
                    byMonth = this.groupByMonth(this.renderDates);
                    tdDatas = this.generateSlots(byMonth, lastLevelColspan, row, 'e-header-month-cell', 'monthHeader');
                    levels.push(tdDatas);
                    break;
                case 'Week':
                    byWeek = this.groupByWeek(this.renderDates);
                    tdDatas = this.generateSlots(byWeek, lastLevelColspan, row, 'e-header-week-cell', 'weekHeader');
                    levels.push(tdDatas);
                    break;
                case 'Date':
                    tdDatas = dateSlots;
                    tdDatas = tdDatas.map((value) => {
                        value.colSpan = lastLevelColspan;
                        return value;
                    });
                    levels.push(tdDatas);
                    break;
                case 'Hour':
                    if (hourSlots.length > 0) {
                        levels.push(hourSlots);
                    }
                    break;
            }
        }
        return levels;
    }
}

/**
 * timeline views
 */
class TimelineViews extends VerticalView {
    constructor(parent) {
        super(parent);
        this.timelineAppointment = null;
        this.baseCssClass = 'e-timeline-view';
    }
    getModuleName() {
        return 'timelineViews';
    }
    getLeftPanelElement() {
        return this.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);
    }
    scrollTopPanel(target) {
        super.scrollTopPanel(target);
        this.scrollHeaderLabels(target);
    }
    scrollToWorkHour() {
        const start = this.parent.getStartEndTime(this.parent.workHours.start);
        const currDateTime = this.isWorkDay(this.parent.selectedDate) && this.parent.workHours.highlight &&
            !isNullOrUndefined(start) ? new Date(+this.parent.selectedDate).setHours(start.getHours(), start.getMinutes(), 0, 0)
            : new Date(+this.parent.selectedDate).setHours(0, 0, 0, 0);
        const queryString = '[data-date="' + new Date(currDateTime).getTime().toString() + '"]';
        const firstWorkHourCell = this.element.querySelector(queryString);
        if (firstWorkHourCell) {
            this.getContentAreaElement().scrollLeft = !this.parent.enableRtl ? firstWorkHourCell.offsetLeft :
                -(this.parent.getContentTable().offsetWidth - firstWorkHourCell.offsetLeft - firstWorkHourCell.offsetWidth);
        }
    }
    scrollToHour(hour, scrollDate) {
        let date;
        let index;
        if (scrollDate) {
            index = this.parent.getIndexOfDate(this.renderDates, resetTime(scrollDate));
            if (index >= 0) {
                date = scrollDate;
                if (!isNullOrUndefined(hour)) {
                    const timeString = hour.split(':');
                    if (timeString.length === 2) {
                        date = new Date(scrollDate.setHours(parseInt(timeString[0], 10), parseInt(timeString[1], 10), 0));
                    }
                }
            }
        }
        date = isNullOrUndefined(scrollDate) ? this.parent.getStartEndTime(hour) : date;
        if (isNullOrUndefined(date)) {
            return;
        }
        let scrollLeft;
        if (isNullOrUndefined(hour) || !this.parent.activeViewOptions.timeScale.enable) {
            scrollLeft = index * this.getWorkCellWidth();
        }
        else {
            scrollLeft = isNullOrUndefined(scrollDate) ? this.getLeftFromDateTime(null, date) :
                this.getLeftFromDateTime([index], date);
        }
        this.getScrollableElement().scrollLeft = !this.parent.enableRtl ? scrollLeft : -scrollLeft;
    }
    generateColumnLevels() {
        let levels = [];
        const dateSlots = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);
        levels.push(dateSlots);
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            this.parent.resourceBase.generateResourceLevels(dateSlots, !this.parent.uiStateValues.isGroupAdaptive);
        }
        let hourSlots = [];
        if (this.parent.activeViewOptions.timeScale.enable) {
            hourSlots = this.generateTimeSlots(levels[levels.length - 1]);
            levels.push(hourSlots);
        }
        if (this.parent.activeViewOptions.headerRows.length > 0) {
            const renderGn = new TimelineHeaderRow(this.parent, this.renderDates);
            levels = renderGn.generateColumnLevels(dateSlots, hourSlots);
        }
        return levels;
    }
    generateTimeSlots(dateSlots) {
        const handler = (r) => {
            r.type = r.first ? 'majorSlot' : 'minorSlot';
            r.className = r.first ? [TIME_SLOT_CLASS] : [TIME_SLOT_CLASS, TIME_CELLS_CLASS];
            r.workDays = this.parent.activeViewOptions.workDays;
            return r;
        };
        const timeSlotData = this.getTimeSlotRows(handler);
        const slots = [];
        for (const data of dateSlots) {
            data.colSpan = timeSlotData.length;
            const tempTimeSlots = extend([], timeSlotData, null, true);
            for (const slot of tempTimeSlots) {
                const cellDate = resetTime(new Date('' + data.date));
                slot.date = setTime(cellDate, getDateInMs(slot.date));
                slots.push(slot);
            }
        }
        return slots;
    }
    changeCurrentTimePosition() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.removeCurrentTimeIndicatorElements();
        const currentDateIndex = this.getCurrentTimeIndicatorIndex();
        const left = this.getLeftFromDateTime(currentDateIndex, this.parent.getCurrentTime());
        const height = this.element.querySelector('.' + CONTENT_TABLE_CLASS).offsetHeight;
        const headerWrap = this.element.querySelector('.' + DATE_HEADER_WRAP_CLASS);
        const contentWrap = this.element.querySelector('.' + CONTENT_WRAP_CLASS);
        contentWrap.appendChild(createElement('div', {
            className: CURRENT_TIMELINE_CLASS,
            styles: (this.parent.enableRtl ? 'right' : 'left') + ':' + formatUnit(left) + '; height:' + formatUnit(height)
        }));
        if (this.parent.virtualScrollModule) {
            const timeIndicator = this.parent.element.querySelector('.' + CURRENT_TIMELINE_CLASS);
            const element = this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS + ' table');
            setStyleAttribute(timeIndicator, {
                transform: element.style.transform
            });
        }
        const currentTimeEle = createElement('div', {
            innerHTML: this.parent.getTimeString(this.parent.getCurrentTime()),
            className: CURRENT_TIME_CLASS
        });
        headerWrap.appendChild(currentTimeEle);
        currentTimeEle.style[this.parent.enableRtl ? 'right' : 'left'] = formatUnit(left - (currentTimeEle.offsetWidth / 2));
    }
    getLeftFromDateTime(currentDateIndex, date) {
        const startHour = this.getStartHour();
        const endHour = this.getEndHour();
        let diffInDates = 0;
        let diffInMinutes = ((date.getHours() - startHour.getHours()) * 60) + (date.getMinutes() - startHour.getMinutes());
        if (!isNullOrUndefined(currentDateIndex)) {
            const end = (endHour.getHours() === 0) ? 24 : endHour.getHours();
            if (currentDateIndex[0] !== 0) {
                diffInDates = (currentDateIndex[0]) * ((end - startHour.getHours()) * 60) + (endHour.getMinutes() - startHour.getMinutes());
            }
            diffInMinutes = diffInDates + diffInMinutes;
        }
        return (diffInMinutes * this.getWorkCellWidth() * this.parent.activeViewOptions.timeScale.slotCount) /
            this.parent.activeViewOptions.timeScale.interval;
    }
    getWorkCellWidth() {
        return this.element.querySelector('.e-work-cells').getBoundingClientRect().width;
    }
    renderHeader() {
        const tr = createElement('tr');
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            this.parent.resourceBase.renderResourceHeaderIndent(tr);
        }
        const dateTd = createElement('td');
        dateTd.appendChild(this.renderDatesHeader());
        tr.appendChild(dateTd);
        prepend([tr], this.element.querySelector('tbody'));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    createAllDayRow(table, tdData) { }
    getCurrentTimeIndicatorIndex() {
        const currentDateIndex = [];
        const index = this.parent.getIndexOfDate(this.renderDates, resetTime(this.parent.getCurrentTime()));
        if (index >= 0) {
            currentDateIndex.push(index);
        }
        return currentDateIndex;
    }
    renderContent() {
        const tr = createElement('tr');
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            const resTd = createElement('td');
            resTd.appendChild(this.parent.resourceBase.createResourceColumn());
            tr.appendChild(resTd);
        }
        const workTd = createElement('td');
        const wrap = this.renderContentArea();
        wrap.appendChild(this.createEventTable(this.getRowCount()));
        this.collapseRows(wrap);
        workTd.appendChild(wrap);
        tr.appendChild(workTd);
        if (this.parent.virtualScrollModule) {
            this.parent.virtualScrollModule.renderVirtualTrack(wrap);
        }
        this.element.querySelector('tbody').appendChild(tr);
    }
    getRowCount() {
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            return this.parent.resourceBase.renderedResources.length;
        }
        return 1;
    }
    getResourceTdData(i, tdData) {
        const resLevel = this.parent.resourceBase.renderedResources[parseInt(i.toString(), 10)];
        const resSHr = resLevel.resourceData[resLevel.resource.startHourField] || this.parent.workHours.start;
        const resEHr = resLevel.resourceData[resLevel.resource.endHourField] || this.parent.workHours.end;
        tdData.startHour = this.parent.getStartEndTime(resSHr);
        tdData.endHour = this.parent.getStartEndTime(resEHr);
        tdData.workDays = resLevel.resourceData[resLevel.resource.workDaysField] || this.parent.workDays;
        tdData.className = resLevel.className;
        tdData.groupIndex = resLevel.groupIndex;
        tdData.groupOrder = resLevel.groupOrder;
        return tdData;
    }
    renderContentTable(table) {
        const tBody = table.querySelector('tbody');
        append(this.getContentRows(), tBody);
    }
    getContentRows() {
        const rows = [];
        const tr = createElement('tr');
        const td = createElement('td', { attrs: { 'aria-selected': 'false' } });
        const trCount = this.getRowCount();
        for (let i = 0; i < trCount; i++) {
            const ntr = tr.cloneNode();
            for (let tdData of this.colLevels[this.colLevels.length - 1]) {
                if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
                    tdData = this.getResourceTdData(i, tdData);
                }
                const ntd = this.createContentTd(tdData, tdData, td);
                ntr.appendChild(ntd);
            }
            rows.push(ntr);
        }
        return rows;
    }
    getContentTdClass(r) {
        return (r.first || !this.parent.activeViewOptions.timeScale.enable) ? [WORK_CELLS_CLASS] :
            [WORK_CELLS_CLASS, ALTERNATE_CELLS_CLASS];
    }
    renderEvents() {
        this.timelineAppointment = new TimelineEvent(this.parent, this.parent.activeViewOptions.timeScale.enable ? 'hour' : 'day');
        this.timelineAppointment.renderAppointments();
        this.parent.notify(eventsLoaded, {});
    }
    getAdjustedDate(date) {
        if (!this.parent.activeViewOptions.timeScale.enable) {
            return new Date(date.setHours(0, 0, 0, 0));
        }
        else {
            const timeSlots = this.colLevels[this.colLevels.length - 1];
            for (let i = 0; i < timeSlots.length; i++) {
                if (timeSlots[parseInt(i.toString(), 10)].date.getTime() > date.getTime()) {
                    return timeSlots[i - 1].date;
                }
            }
        }
        return null;
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        if (this.timelineAppointment) {
            this.timelineAppointment.destroy();
            this.timelineAppointment = null;
        }
        super.destroy();
    }
}

/**
 * timeline month view
 */
class TimelineMonth extends Month {
    constructor(parent) {
        super(parent);
        this.viewClass = 'e-timeline-month-view';
        this.isInverseTableSelect = true;
        this.appointment = null;
    }
    getModuleName() {
        return 'timelineMonth';
    }
    onDataReady() {
        this.appointment = new TimelineEvent(this.parent, 'day');
        this.appointment.renderAppointments();
        this.parent.notify(eventsLoaded, {});
    }
    getLeftPanelElement() {
        return this.element.querySelector('.' + RESOURCE_COLUMN_WRAP_CLASS);
    }
    scrollTopPanel(target) {
        super.scrollTopPanel(target);
        this.scrollHeaderLabels(target);
    }
    setContentHeight(content, leftPanelElement, height) {
        if (leftPanelElement) {
            leftPanelElement.style.height = formatUnit(height - this.getScrollXIndent(content));
        }
        content.style.height = formatUnit(height);
    }
    getDateSlots(renderDates, workDays) {
        const dateSlots = [];
        for (const col of renderDates) {
            const classList$$1 = [HEADER_CELLS_CLASS];
            if (this.isCurrentDate(col)) {
                classList$$1.push(CURRENT_DAY_CLASS);
            }
            dateSlots.push({ date: col, type: 'dateHeader', className: classList$$1, colSpan: 1, workDays: workDays });
        }
        return dateSlots;
    }
    renderLeftIndent(tr) {
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            this.parent.resourceBase.renderResourceHeaderIndent(tr);
        }
    }
    renderContent() {
        const contentTr = createElement('tr');
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            const resTd = createElement('td');
            resTd.appendChild(this.parent.resourceBase.createResourceColumn());
            contentTr.appendChild(resTd);
        }
        const contentTd = createElement('td');
        this.element.querySelector('tbody').appendChild(contentTr);
        const wrap = createElement('div', { className: CONTENT_WRAP_CLASS });
        wrap.appendChild(this.renderContentArea());
        wrap.appendChild(this.createEventTable(this.getRowCount()));
        this.collapseRows(wrap);
        EventHandler.add(wrap, 'scroll', this.onContentScroll, this);
        contentTd.appendChild(wrap);
        if (this.parent.virtualScrollModule) {
            this.parent.virtualScrollModule.renderVirtualTrack(wrap);
        }
        contentTr.appendChild(contentTd);
    }
    getRowCount() {
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            return this.parent.resourceBase.renderedResources.length;
        }
        return 1;
    }
    getContentSlots() {
        const slotDatas = [];
        for (let row = 0; row < this.getRowCount(); row++) {
            for (const data of this.colLevels[this.colLevels.length - 1]) {
                data.className = [WORK_CELLS_CLASS];
                if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
                    const resLevel = this.parent.resourceBase.renderedResources[parseInt(row.toString(), 10)];
                    data.workDays = resLevel.resourceData[resLevel.resource.workDaysField] || this.parent.workDays;
                    data.className = data.className.concat(resLevel.className);
                    data.groupIndex = resLevel.groupIndex;
                    data.groupOrder = resLevel.groupOrder;
                }
                const slotData = {
                    date: new Date(+data.date), colSpan: data.colSpan, groupIndex: data.groupIndex, workDays: data.workDays,
                    type: 'monthCells', className: data.className
                };
                if (!slotDatas[parseInt(row.toString(), 10)]) {
                    slotDatas[parseInt(row.toString(), 10)] = [];
                }
                slotDatas[parseInt(row.toString(), 10)].push(slotData);
            }
        }
        return slotDatas;
    }
    updateClassList(data) {
        if (!this.parent.isMinMaxDate(data.date)) {
            data.className.push(DISABLE_DATES);
        }
    }
    unWireEvents() {
        EventHandler.remove(this.getContentAreaElement(), 'scroll', this.onContentScroll);
    }
    getMonthStart(currentDate) {
        const monthStart = this.parent.calendarUtil.firstDateOfMonth(resetTime(currentDate));
        return new Date(monthStart.getFullYear(), monthStart.getMonth(), monthStart.getDate());
    }
    getMonthEnd(currentDate) {
        const monthStart = this.parent.calendarUtil.firstDateOfMonth(resetTime(currentDate));
        return this.parent.calendarUtil.lastDateOfMonth(addMonths(new Date(+monthStart), this.parent.activeViewOptions.interval - 1));
    }
    generateColumnLevels() {
        let colLevels = [];
        const level = this.getDateSlots(this.renderDates, this.parent.activeViewOptions.workDays);
        colLevels.push(level);
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            this.parent.resourceBase.generateResourceLevels(level, !this.parent.uiStateValues.isGroupAdaptive);
        }
        const hourSlots = [];
        if (this.parent.activeViewOptions.headerRows.length > 0) {
            const renderGn = new TimelineHeaderRow(this.parent, this.renderDates);
            colLevels = renderGn.generateColumnLevels(level, hourSlots);
        }
        this.colLevels = colLevels;
        return colLevels;
    }
    getAdjustedDate(startTime) {
        const timeSlots = this.colLevels[this.colLevels.length - 1];
        for (let i = 0; i < timeSlots.length; i++) {
            if (timeSlots[parseInt(i.toString(), 10)].date.getTime() > startTime.getTime()) {
                return timeSlots[i - 1].date;
            }
        }
        return null;
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        if (this.element) {
            const contentScrollableEle = this.element.querySelector('.' + CONTENT_WRAP_CLASS);
            if (contentScrollableEle) {
                EventHandler.remove(contentScrollableEle, 'scroll', this.onContentScroll);
            }
        }
        if (this.appointment) {
            this.appointment.destroy();
            this.appointment = null;
        }
        super.destroy();
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * timeline year view
 */
class TimelineYear extends Year {
    constructor(parent) {
        super(parent);
        this.viewClass = 'e-timeline-year-view';
        this.isInverseTableSelect = true;
    }
    getModuleName() {
        return 'timelineYear';
    }
    renderHeader(headerWrapper) {
        const tr = createElement('tr');
        headerWrapper.appendChild(tr);
        if (this.parent.activeViewOptions.orientation === 'Vertical' && this.parent.activeViewOptions.group.resources.length > 0 &&
            !this.parent.uiStateValues.isGroupAdaptive) {
            this.parent.resourceBase.renderResourceHeaderIndent(tr);
        }
        else {
            const leftHeaderCells = createElement('td', { className: LEFT_INDENT_CLASS });
            tr.appendChild(leftHeaderCells);
            leftHeaderCells.appendChild(this.renderResourceHeader(LEFT_INDENT_WRAP_CLASS));
        }
        const isHorizontal = this.parent.activeViewOptions.orientation === 'Horizontal';
        const isGroup = this.parent.activeViewOptions.group.resources.length > 0;
        this.isInverseTableSelect = isHorizontal && !isGroup ? false : true;
        const td = createElement('td');
        tr.appendChild(td);
        const container = createElement('div', { className: DATE_HEADER_CONTAINER_CLASS });
        td.appendChild(container);
        if (this.parent.activeViewOptions.orientation === 'Horizontal' && this.parent.activeViewOptions.group.resources.length > 0 &&
            !this.parent.uiStateValues.isGroupAdaptive) {
            container.appendChild(this.renderResourceHeader(DATE_HEADER_WRAP_CLASS));
            this.columnCount = this.colLevels.slice(-1)[0].length;
        }
        else {
            const wrapper = createElement('div', { className: DATE_HEADER_WRAP_CLASS });
            container.appendChild(wrapper);
            const table = this.createTableLayout();
            wrapper.appendChild(table);
            table.appendChild(this.createTableColGroup(this.columnCount));
            const innerTr = createElement('tr');
            table.querySelector('tbody').appendChild(innerTr);
            const months = this.getMonths();
            const dayHeaderDates = this.getMonthDates(new Date(this.parent.selectedDate.getFullYear(), months[0], 1));
            for (let column = 0; column < this.columnCount; column++) {
                const date = new Date(this.parent.selectedDate.getFullYear(), months[parseInt(column.toString(), 10)], 1);
                const innerTd = createElement('td', { className: HEADER_CELLS_CLASS });
                if (this.parent.activeViewOptions.orientation === 'Horizontal') {
                    if (this.parent.dayHeaderTemplate) {
                        append(this.renderDayMonthHeaderTemplate(dayHeaderDates[parseInt(column.toString(), 10)], column, 'dayHeaderTemplate'), innerTd);
                    }
                    else {
                        innerTd.innerHTML = `<span>${this.parent.getDayNames('abbreviated')[column % 7]}</span>`;
                    }
                }
                else {
                    if (this.parent.monthHeaderTemplate) {
                        append(this.renderDayMonthHeaderTemplate(date, months[parseInt(column.toString(), 10)], 'monthHeaderTemplate'), innerTd);
                    }
                    else {
                        innerTd.innerHTML = `<span>${this.getMonthName(date)}</span>`;
                    }
                    innerTd.setAttribute('data-date', date.getTime().toString());
                }
                innerTr.appendChild(innerTd);
                this.parent.trigger(renderCell, { elementType: 'headerCells', element: innerTd });
            }
        }
    }
    renderResourceHeader(className) {
        const wrap = createElement('div', { className: className });
        const tbl = this.createTableLayout();
        wrap.appendChild(tbl);
        const trEle = createElement('tr');
        if (this.parent.activeViewOptions.group.resources.length > 0) {
            this.colLevels = this.generateColumnLevels();
        }
        else {
            const colData = [{ className: [HEADER_CELLS_CLASS], type: 'headerCell' }];
            this.colLevels = [colData];
        }
        for (const col of this.colLevels) {
            const ntr = trEle.cloneNode();
            const count = className === DATE_HEADER_WRAP_CLASS ? col : [col[0]];
            for (const c of count) {
                const tdEle = createElement('td');
                if (c.className) {
                    addClass([tdEle], c.className);
                }
                if (className === DATE_HEADER_WRAP_CLASS) {
                    if (c.template) {
                        append(c.template, tdEle);
                    }
                    if (c.colSpan) {
                        tdEle.setAttribute('colspan', c.colSpan.toString());
                    }
                    if (c.groupIndex > -1) {
                        tdEle.setAttribute('data-group-index', c.groupIndex.toString());
                    }
                    this.setResourceHeaderContent(tdEle, c);
                }
                if (className === LEFT_INDENT_WRAP_CLASS) {
                    this.parent.renderHeaderIndentTemplate(c, tdEle);
                }
                const args = { elementType: c.type, element: tdEle, date: c.date, groupIndex: c.groupIndex };
                this.parent.trigger(renderCell, args);
                ntr.appendChild(tdEle);
            }
            tbl.querySelector('tbody').appendChild(ntr);
        }
        if (className === DATE_HEADER_WRAP_CLASS) {
            tbl.appendChild(this.createTableColGroup(this.colLevels.slice(-1)[0].length));
        }
        return wrap;
    }
    renderContent(contentWrapper) {
        const tr = createElement('tr');
        contentWrapper.appendChild(tr);
        const firstTd = createElement('td');
        const lastTd = createElement('td');
        const tdCollection = [];
        let monthTBody;
        if (this.parent.activeViewOptions.orientation === 'Vertical' && this.parent.activeViewOptions.group.resources.length > 0 &&
            !this.parent.uiStateValues.isGroupAdaptive) {
            tdCollection.push(firstTd);
            firstTd.appendChild(this.parent.resourceBase.createResourceColumn());
            this.rowCount = this.parent.resourceBase.renderedResources.length;
        }
        else {
            tdCollection.push(firstTd);
            const monthWrapper = createElement('div', { className: MONTH_HEADER_WRAPPER });
            firstTd.appendChild(monthWrapper);
            monthWrapper.appendChild(this.createTableLayout());
            monthTBody = monthWrapper.querySelector('tbody');
        }
        tdCollection.push(lastTd);
        append(tdCollection, tr);
        const content = createElement('div', { className: CONTENT_WRAP_CLASS });
        lastTd.appendChild(content);
        const contentTable = this.createTableLayout(CONTENT_TABLE_CLASS);
        this.setAriaAttributes(contentTable);
        content.appendChild(contentTable);
        const eventWrapper = createElement('div', { className: EVENT_TABLE_CLASS });
        content.appendChild(eventWrapper);
        if (this.parent.virtualScrollModule) {
            this.parent.virtualScrollModule.renderVirtualTrack(content);
        }
        const contentTBody = contentTable.querySelector('tbody');
        if (this.parent.rowAutoHeight) {
            const addClassTable = [contentTable];
            const monthHeader = this.parent.element.querySelector('.' + MONTH_HEADER_WRAPPER + ' .' + SCHEDULE_TABLE_CLASS);
            if (monthHeader) {
                addClassTable.push(monthHeader);
            }
            addClass(addClassTable, AUTO_HEIGHT);
        }
        if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
            const colCount = this.parent.activeViewOptions.orientation === 'Horizontal' ? this.colLevels.slice(-1)[0].length : this.columnCount;
            contentTable.appendChild(this.createTableColGroup(colCount));
            this.renderResourceContent(eventWrapper, monthTBody, contentTBody);
        }
        else {
            contentTable.appendChild(this.createTableColGroup(this.columnCount));
            this.renderDefaultContent(eventWrapper, monthTBody, contentTBody);
        }
    }
    renderDefaultContent(wrapper, monthBody, contentBody) {
        const months = this.getMonths();
        const dayHeaderDates = this.getMonthDates(new Date(this.parent.selectedDate.getFullYear(), months[0], 1));
        for (let month = 0; month < this.rowCount; month++) {
            wrapper.appendChild(createElement('div', { className: APPOINTMENT_CONTAINER_CLASS }));
            let monthDate = new Date(this.parent.selectedDate.getFullYear(), months[parseInt(month.toString(), 10)], 1);
            let monthStart = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));
            let monthEnd = this.parent.calendarUtil.getMonthEndDate(new Date(monthDate.getTime()));
            const tr = createElement('tr');
            const monthTr = tr.cloneNode();
            monthBody.appendChild(monthTr);
            const contentTr = tr.cloneNode();
            contentBody.appendChild(contentTr);
            const monthTd = createElement('td', { className: MONTH_HEADER_CLASS });
            if (this.parent.activeViewOptions.orientation === 'Horizontal') {
                if (this.parent.monthHeaderTemplate) {
                    append(this.renderDayMonthHeaderTemplate(monthStart, month, 'monthHeaderTemplate'), monthTd);
                }
                else {
                    monthTd.innerHTML = `<span>${this.getMonthName(monthDate)}</span>`;
                }
                monthTd.setAttribute('data-date', monthDate.getTime().toString());
            }
            else {
                if (this.parent.dayHeaderTemplate) {
                    append(this.renderDayMonthHeaderTemplate(dayHeaderDates[parseInt(month.toString(), 10)], month, 'dayHeaderTemplate'), monthTd);
                }
                else {
                    monthTd.innerHTML = `<span>${this.parent.getDayNames('abbreviated')[month % 7]}</span>`;
                }
            }
            monthTr.appendChild(monthTd);
            this.parent.trigger(renderCell, { elementType: 'leftHeaderCells', element: monthTd });
            let date = new Date(monthStart.getTime());
            for (let column = 0; column < this.columnCount; column++) {
                let isDateAvail;
                if (this.parent.activeViewOptions.orientation === 'Vertical') {
                    monthDate = new Date(this.parent.selectedDate.getFullYear(), months[parseInt(column.toString(), 10)], 1);
                    monthStart = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));
                    monthEnd = this.parent.calendarUtil.getMonthEndDate(new Date(monthDate.getTime()));
                    const dayDate = (month - monthStart.getDay()) + 1;
                    date = new Date(this.parent.selectedDate.getFullYear(), months[parseInt(column.toString(), 10)], dayDate);
                    isDateAvail = dayDate > 0 && date.getTime() < monthEnd.getTime();
                }
                else {
                    isDateAvail = column >= monthStart.getDay() && date.getTime() < monthEnd.getTime();
                }
                const announcementText = this.parent.globalize.formatDate(date, {
                    skeleton: 'full', calendar: this.parent.getCalendarMode()
                });
                const td = createElement('td', {
                    className: WORK_CELLS_CLASS, attrs: { 'aria-selected': 'false', 'aria-label': announcementText }
                });
                contentTr.appendChild(td);
                const dateHeader = createElement('div', {
                    className: DATE_HEADER_CLASS + ' ' + NAVIGATE_CLASS,
                    innerHTML: (isDateAvail) ?
                        this.parent.globalize.formatDate(date, { skeleton: 'd', calendar: this.parent.getCalendarMode() }) : ''
                });
                if (isDateAvail) {
                    const tds = [td];
                    const classList$$1 = [];
                    if (this.parent.activeViewOptions.workDays.indexOf(date.getDay()) > -1) {
                        classList$$1.push(WORKDAY_CLASS);
                    }
                    if (!this.parent.isMinMaxDate(date)) {
                        addClass([td], DISABLE_DATES);
                    }
                    if (this.isCurrentDate(date)) {
                        classList$$1.push(CURRENT_DAY_CLASS);
                        if (this.parent.activeViewOptions.orientation === 'Horizontal') {
                            tds.push(this.element.querySelector('.' + HEADER_CELLS_CLASS + `:nth-child(${column + 1})`));
                        }
                        else {
                            tds.push(this.element.querySelectorAll('.' + MONTH_HEADER_CLASS).item(month));
                        }
                    }
                    if (classList$$1.length > 0) {
                        addClass(tds, classList$$1);
                    }
                }
                else {
                    addClass([td], OTHERMONTH_CLASS);
                    if (!this.parent.isMinMaxDate(date)) {
                        addClass([td], DISABLE_DATES);
                    }
                }
                if (td.classList.contains(OTHERMONTH_CLASS)) {
                    continue;
                }
                else {
                    this.renderDates.push(new Date(date));
                }
                td.appendChild(dateHeader);
                if (isDateAvail) {
                    td.setAttribute('data-date', date.getTime().toString());
                    this.wireEvents(td);
                }
                this.renderCellTemplate({ date: date, type: 'workCells' }, td);
                this.parent.trigger(renderCell, { elementType: 'workCells', element: td, date: date });
                if (isDateAvail) {
                    if (this.parent.activeViewOptions.orientation === 'Horizontal') {
                        date = addDays(new Date(date.getTime()), 1);
                    }
                }
            }
        }
        this.renderDates.splice(0, 1);
    }
    getContentRows() {
        const tRow = [];
        const monthCells = this.getMonths();
        for (let row = 0; row < this.parent.resourceBase.renderedResources.length; row++) {
            const tr = createElement('tr');
            tRow.push(tr);
            let resData;
            if (this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
                resData = this.parent.resourceBase.renderedResources[parseInt(row.toString(), 10)];
            }
            let monthDate = new Date(this.parent.selectedDate.getFullYear(), monthCells[parseInt(row.toString(), 10)], 1);
            let date = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));
            for (let month = 0; month < this.columnCount; month++) {
                let classList$$1 = [];
                const groupIndex = resData.groupIndex;
                classList$$1 = classList$$1.concat(resData.className);
                if (classList$$1.indexOf(RESOURCE_PARENT_CLASS) > -1) {
                    classList$$1.push(RESOURCE_GROUP_CELLS_CLASS);
                }
                else {
                    classList$$1.push(WORKDAY_CLASS);
                }
                monthDate = new Date(this.parent.selectedDate.getFullYear(), monthCells[parseInt(month.toString(), 10)], 1);
                date = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));
                const tdELe = createElement('td', {
                    className: WORK_CELLS_CLASS,
                    attrs: {
                        'aria-selected': 'false',
                        'data-date': date.getTime().toString()
                    }
                });
                addClass([tdELe], classList$$1);
                tdELe.setAttribute('data-group-index', groupIndex.toString());
                this.renderCellTemplate({ date: date, type: 'resourceGroupCells', groupIndex: groupIndex }, tdELe);
                this.wireEvents(tdELe);
                this.parent.trigger(renderCell, { elementType: 'resourceGroupCells', element: tdELe, date: date });
                tr.appendChild(tdELe);
            }
        }
        return tRow;
    }
    renderResourceContent(wrapper, monthBody, contentBody) {
        const months = this.getMonths();
        for (let row = 0; row < this.rowCount; row++) {
            wrapper.appendChild(createElement('div', { className: APPOINTMENT_CONTAINER_CLASS }));
            const tr = createElement('tr');
            contentBody.appendChild(tr);
            let resData;
            if (this.parent.activeViewOptions.orientation === 'Vertical' && this.parent.activeViewOptions.group.resources.length > 0 && !this.parent.uiStateValues.isGroupAdaptive) {
                resData = this.parent.resourceBase.renderedResources[parseInt(row.toString(), 10)];
            }
            let monthDate = new Date(this.parent.selectedDate.getFullYear(), months[parseInt(row.toString(), 10)], 1);
            let date = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));
            if (this.parent.activeViewOptions.orientation === 'Horizontal') {
                const monthTr = tr.cloneNode();
                monthBody.appendChild(monthTr);
                const monthTd = createElement('td', {
                    className: MONTH_HEADER_CLASS,
                    attrs: { 'data-date': date.getTime().toString() }
                });
                if (this.parent.monthHeaderTemplate) {
                    append(this.renderDayMonthHeaderTemplate(monthDate, row, 'monthHeaderTemplate'), monthTd);
                }
                else {
                    monthTd.innerHTML = `<span>${this.getMonthName(monthDate)}</span>`;
                }
                monthTr.appendChild(monthTd);
            }
            for (let month = 0; month < this.columnCount; month++) {
                let classList$$1 = [];
                let groupIndex;
                if (this.parent.activeViewOptions.orientation === 'Vertical') {
                    groupIndex = resData.groupIndex;
                    classList$$1 = classList$$1.concat(resData.className);
                    if (classList$$1.indexOf(RESOURCE_PARENT_CLASS) > -1) {
                        classList$$1.push(RESOURCE_GROUP_CELLS_CLASS);
                    }
                    else {
                        classList$$1.push(WORKDAY_CLASS);
                    }
                    monthDate = new Date(this.parent.selectedDate.getFullYear(), months[parseInt(month.toString(), 10)], 1);
                    date = this.parent.calendarUtil.getMonthStartDate(new Date(monthDate.getTime()));
                }
                else {
                    groupIndex = this.colLevels.slice(-1)[0][parseInt(month.toString(), 10)].groupIndex;
                    classList$$1.push(WORKDAY_CLASS);
                }
                const td = createElement('td', {
                    className: WORK_CELLS_CLASS,
                    attrs: {
                        'aria-selected': 'false',
                        'data-date': date.getTime().toString()
                    }
                });
                addClass([td], classList$$1);
                td.setAttribute('data-group-index', groupIndex.toString());
                this.renderCellTemplate({ date: date, type: 'resourceGroupCells', groupIndex: groupIndex }, td);
                this.wireEvents(td);
                tr.appendChild(td);
                this.parent.trigger(renderCell, { elementType: 'resourceGroupCells', element: td, date: date });
            }
        }
        if (this.parent.activeViewOptions.orientation === 'Vertical') {
            this.collapseRows(this.parent.element.querySelector('.' + CONTENT_WRAP_CLASS));
        }
    }
    renderDayMonthHeaderTemplate(date, column, type) {
        const args = { date: date, type: type === 'dayHeaderTemplate' ? 'dayHeader' : 'monthHeader' };
        const dayId = `schedule_${this.parent.activeViewOptions.dayHeaderTemplateName}dayHeaderTemplate`;
        const monthId = `schedule_${this.parent.activeViewOptions.dayHeaderTemplateName}monthHeaderTemplate`;
        if (type === 'dayHeaderTemplate') {
            args.day = this.parent.getDayNames('wide')[column % 7];
            return [].slice.call(this.parent.getDayHeaderTemplate()(args, this.parent, 'dayHeaderTemplate', dayId, false));
        }
        else {
            return [].slice.call(this.parent.getMonthHeaderTemplate()(args, this.parent, 'monthHeaderTemplate', monthId, false));
        }
    }
    renderCellTemplate(data, td) {
        if (!this.parent.activeViewOptions.cellTemplate || td.classList.contains(OTHERMONTH_CLASS)) {
            return;
        }
        const args = { date: data.date, type: data.type };
        if (data.groupIndex) {
            args.groupIndex = data.groupIndex;
        }
        const scheduleId = this.parent.element.id + '_';
        const viewName = this.parent.activeViewOptions.cellTemplateName;
        const templateId = scheduleId + viewName + 'cellTemplate';
        const cellTemplate = [].slice.call(this.parent.getCellTemplate()(args, this.parent, 'cellTemplate', templateId, false));
        append(cellTemplate, td);
    }
    scrollToDate(scrollDate) {
        let date;
        if (this.parent.activeViewOptions.group.resources !== null && this.parent.activeViewOptions.group.resources.length > 0 &&
            !this.parent.uiStateValues.isGroupAdaptive) {
            date = +new Date(resetTime(firstDateOfMonth(scrollDate)));
        }
        else {
            date = +new Date(resetTime(scrollDate));
        }
        const element = this.element.querySelector('[data-date="' + date + '"]');
        if (element) {
            const wrap = this.getScrollableElement();
            if (this.parent.enableRtl) {
                const conTable = this.element.querySelector('.' + CONTENT_TABLE_CLASS);
                wrap.scrollLeft = -(conTable.offsetWidth - element.offsetLeft - element.offsetWidth);
            }
            else {
                wrap.scrollLeft = element.offsetLeft;
            }
            wrap.scrollTop = element.offsetTop;
        }
    }
    getScrollableElement() {
        if (this.parent.isAdaptive && !this.isTimelineView()) {
            return this.element.querySelector('.' + SCROLL_CONTAINER_CLASS);
        }
        else {
            return this.getContentAreaElement();
        }
    }
    wireEvents(element) {
        EventHandler.add(element, 'mousedown', this.parent.workCellAction.cellMouseDown, this.parent.workCellAction);
        EventHandler.add(element, 'click', this.parent.workCellAction.cellClick, this.parent.workCellAction);
        if (!this.parent.isAdaptive) {
            EventHandler.add(element, 'dblclick', this.parent.workCellAction.cellDblClick, this.parent.workCellAction);
        }
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * ICalendar Export Module
 */
class ICalendarExport {
    constructor(parent) {
        this.parent = parent;
    }
    initializeCalendarExport(fileName, customData) {
        const icsString = this.getCalendarString(fileName, customData);
        this.download(icsString, fileName);
    }
    getCalendarString(fileName, customData) {
        let eventsData = (customData) ? customData :
            extend([], this.parent.eventsData, null, true);
        eventsData = this.parent.eventBase.sortByTime(eventsData);
        const SEPARATOR = (navigator.appVersion.indexOf('Win') !== -1) ? '\r\n' : '\n';
        const iCalendarEvents = [];
        const filterCollection = [];
        const timeZone = this.parent.timezone || this.parent.tzModule.getLocalTimezoneName();
        const fields = this.parent.eventFields;
        eventsData.forEach((eventObj) => {
            let uId = eventObj[fields.id] || eventObj.Guid || this.parent.eventBase.generateGuid();
            const editedExDate = [];
            if (eventObj[fields.recurrenceID]) {
                const filter = this.filterEvents(filterCollection, fields.id, eventObj[fields.recurrenceID]);
                uId = filter.length > 0 ? filter[0].UID : uId;
            }
            if (!eventObj[fields.recurrenceID] && eventObj[fields.recurrenceRule] && eventObj[fields.recurrenceException]) {
                const exDate = (eventObj[fields.recurrenceException]).split(',');
                const editedObj = this.filterEvents(eventsData, fields.recurrenceID, eventObj[fields.id]);
                editedObj.forEach((edited) => {
                    editedExDate.push(getRecurrenceStringFromDate(edited[fields.startTime]));
                });
                const exceptionDateList = exDate.filter((value) => editedExDate.indexOf(value) === -1);
                eventObj[fields.recurrenceException] = (exceptionDateList.length > 0) ? (exceptionDateList.join(',') + ',') : '';
            }
            const startZone = (eventObj[fields.startTimezone] || timeZone);
            const endZone = (eventObj[fields.endTimezone] || timeZone);
            const readonly = (eventObj[fields.isReadonly]) ? (eventObj[fields.isReadonly]) : false;
            const calendarEvent = [
                'BEGIN:VEVENT',
                'LOCATION:' + (eventObj[fields.location] || ''),
                'SUMMARY:' + (eventObj[fields.subject] || ''),
                'UID:' + uId,
                'DESCRIPTION:' + (eventObj[fields.description] || ''),
                'ISREADONLY:' + readonly,
                'END:VEVENT'
            ];
            if (eventObj[fields.isAllDay]) {
                calendarEvent.splice(4, 0, 'DTEND;VALUE=DATE:' + this.convertDateToString(eventObj[fields.endTime], true));
                calendarEvent.splice(4, 0, 'DTSTART;VALUE=DATE:' + this.convertDateToString(eventObj[fields.startTime], true));
            }
            else if (!eventObj[fields.isAllDay] && !eventObj[fields.recurrenceRule]) {
                calendarEvent.splice(4, 0, 'DTEND:' + this.convertDateToString(eventObj[fields.endTime]));
                calendarEvent.splice(4, 0, 'DTSTART:' + this.convertDateToString(eventObj[fields.startTime]));
            }
            else {
                calendarEvent.splice(4, 0, 'DTEND;TZID="' + endZone + '":' + this.convertDateToString(eventObj[fields.endTime]));
                calendarEvent.splice(4, 0, 'DTSTART;TZID="' + startZone + '":'
                    + this.convertDateToString(eventObj[fields.startTime]));
            }
            if (eventObj[fields.recurrenceRule]) {
                calendarEvent.splice(4, 0, 'RRULE:' + eventObj[fields.recurrenceRule]);
            }
            if (eventObj[fields.recurrenceException]) {
                const exDate = eventObj[fields.recurrenceException].split(',');
                for (let i = 0; i < exDate.length - 1; i++) {
                    calendarEvent.splice(5, 0, 'EXDATE:' +
                        this.convertDateToString(getDateFromRecurrenceDateString(exDate[parseInt(i.toString(), 10)]), eventObj[fields.isAllDay]));
                }
            }
            if (eventObj[fields.recurrenceID]) {
                calendarEvent.splice(4, 0, 'RECURRENCE-ID;TZID="' + startZone + '":'
                    + this.convertDateToString(eventObj[fields.startTime], eventObj[fields.isAllDay]));
            }
            const customFields = this.customFieldFilter(eventObj, fields);
            if (customFields.length > 0) {
                customFields.forEach((customField) => calendarEvent.splice(4, 0, customField + ':' + (eventObj[`${customField}`] || '')));
            }
            const app = extend({}, eventObj);
            app.UID = uId;
            filterCollection.push(app);
            iCalendarEvents.push(calendarEvent.join(SEPARATOR));
        });
        const iCalendar = [
            'BEGIN:VCALENDAR',
            'PRODID:-//Syncfusion Inc//Scheduler//EN',
            'VERSION:2.0',
            'CALSCALE:GREGORIAN',
            'METHOD:PUBLISH',
            'X-WR-CALNAME:' + (fileName || 'Calendar'),
            'X-WR-TIMEZONE:' + timeZone
        ].join(SEPARATOR);
        const icsString = iCalendar + SEPARATOR + iCalendarEvents.join(SEPARATOR) + SEPARATOR + 'END:VCALENDAR';
        return icsString;
    }
    customFieldFilter(eventObj, fields) {
        const defaultFields = Object.keys(fields).map((key) => fields[`${key}`]);
        const eventFields = Object.keys(eventObj);
        return eventFields.filter((value) => (defaultFields.indexOf(value) === -1) && (value !== 'Guid'));
    }
    convertDateToString(eventDate, allDay) {
        const year = ('0000' + (eventDate.getFullYear().toString())).slice(-4);
        const month = ('00' + ((eventDate.getMonth() + 1).toString())).slice(-2);
        const date = ('00' + ((eventDate.getDate()).toString())).slice(-2);
        const hours = ('00' + (eventDate.getHours().toString())).slice(-2);
        const minutes = ('00' + (eventDate.getMinutes().toString())).slice(-2);
        const seconds = ('00' + (eventDate.getSeconds().toString())).slice(-2);
        const timeString = (allDay) ? year + month + date : year + month + date + 'T' + hours + minutes + seconds;
        return timeString;
    }
    download(icsString, fileName) {
        const buffer = new Blob([icsString], { type: 'data:text/calendar;charset=utf8' });
        fileName = (fileName || 'Calendar') + '.ics';
        if (navigator.msSaveBlob) {
            navigator.msSaveBlob(buffer, fileName);
        }
        else {
            const downloadLink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
            downloadLink.download = fileName;
            downloadLink.href = URL.createObjectURL(buffer);
            const event = document.createEvent('MouseEvent');
            event.initEvent('click', true, true);
            downloadLink.dispatchEvent(event);
            setTimeout(() => {
                URL.revokeObjectURL(downloadLink.href);
                downloadLink.href = undefined;
            });
        }
    }
    filterEvents(data, field, value) {
        return data.filter((e) => e[`${field}`] === value);
    }
    getModuleName() {
        return 'iCalendarExport';
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
        this.parent = null;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * ICalendar Import Module
 */
class ICalendarImport {
    constructor(parent) {
        this.allDay = false;
        this.parent = parent;
    }
    initializeCalendarImport(fileContent) {
        if (fileContent && fileContent instanceof Blob) {
            const fileReader = new FileReader();
            fileReader.onload = () => {
                const iCalString = fileReader.result;
                this.iCalendarParser(iCalString);
            };
            fileReader.readAsText(fileContent, 'UTF-8');
        }
        else if (fileContent && typeof fileContent === 'string') {
            this.iCalendarParser(fileContent);
        }
    }
    iCalendarParser(iCalString) {
        const fields = this.parent.eventFields;
        const events = [];
        const uId = 'UID';
        const calArray = iCalString.replace(new RegExp('\\r', 'g'), '').split('\n');
        let isEvent = false;
        let curEvent;
        // eslint-disable-next-line prefer-const
        let id = this.parent.eventBase.getEventMaxID();
        let count = 0;
        calArray.forEach((element) => {
            let index;
            let type;
            let value;
            if (!isEvent && element === 'BEGIN:VEVENT') {
                isEvent = true;
                curEvent = {};
            }
            if (isEvent && element === 'END:VEVENT') {
                isEvent = false;
                events.push(curEvent);
                curEvent = null;
            }
            if (isEvent) {
                index = element.indexOf(':');
                type = element.substr(0, index).replace(/^\s\s*/, '').replace(/\s\s*$/, '');
                value = element.substr(index + 1, element.length - (index + 1)).replace(/^\s\s*/, '').replace(/\s\s*$/, '');
                if (element.indexOf('SUMMARY') !== -1) {
                    type = 'SUMMARY';
                }
                if (element.indexOf('DTSTART') !== -1) {
                    curEvent[fields.startTime] = this.dateParsing(element);
                    curEvent[fields.isAllDay] = this.allDay;
                    this.allDay = false;
                }
                else if (element.indexOf('DTEND') !== -1) {
                    curEvent[fields.endTime] = this.dateParsing(element);
                }
                else if (element.indexOf('EXDATE') !== -1) {
                    value = getRecurrenceStringFromDate(this.dateParsing(element));
                    curEvent[fields.recurrenceException] = (isNullOrUndefined(curEvent[fields.recurrenceException])) ?
                        value : curEvent[fields.recurrenceException] + ',' + value;
                }
                else if (element.indexOf('RECURRENCE-ID') !== -1) {
                    value = getRecurrenceStringFromDate(this.dateParsing(element));
                    curEvent[fields.recurrenceException] = value;
                    curEvent[fields.recurrenceID] = value;
                }
                else {
                    switch (type) {
                        case 'BEGIN':
                            break;
                        case 'UID':
                            curEvent[`${uId}`] = value;
                            if (typeof (id) == 'number') {
                                curEvent[fields.id] = parseInt(value, 10);
                                if (isNaN(curEvent[fields.id])) {
                                    curEvent[fields.id] = id + count;
                                    count++;
                                }
                            }
                            else {
                                curEvent[fields.id] = value;
                            }
                            break;
                        case 'SUMMARY':
                            curEvent[fields.subject] = value;
                            break;
                        case 'LOCATION':
                            curEvent[fields.location] = value;
                            break;
                        case 'DESCRIPTION':
                            curEvent[fields.description] = value;
                            break;
                        case 'ISREADONLY':
                            curEvent[fields.isReadonly] = (value.indexOf('true') > -1);
                            break;
                        case 'RRULE':
                            curEvent[fields.recurrenceRule] = value;
                            break;
                        default:
                            if (this.parent.resourceCollection.length > 0) {
                                const resData = this.parent.resourceCollection.filter((data) => data.field === type);
                                curEvent[`${type}`] = (resData.length > 0 && (typeof (resData[0].dataSource[0][resData[0].idField]) == 'number')) ? parseInt(value, 10) : value;
                            }
                            else {
                                curEvent[`${type}`] = value;
                            }
                    }
                }
            }
        });
        const app = extend([], events, null, true);
        this.parent.addEvent(this.processOccurrence(app, id));
    }
    processOccurrence(app, maxId) {
        const appoint = [];
        const uId = 'UID';
        const fields = this.parent.eventFields;
        const appointmentIds = [];
        this.parent.eventsData.forEach((eventObj) => {
            appointmentIds.push(eventObj[fields.id]);
        });
        app.forEach((eventObj) => {
            let parentObj;
            let id;
            // eslint-disable-next-line no-prototype-builtins
            if (!eventObj.hasOwnProperty(fields.recurrenceID)) {
                parentObj = eventObj;
                id = eventObj[fields.id];
            }
            if (appointmentIds.indexOf(eventObj[fields.id]) < 0) {
                const data = app.filter((data) => data.UID === eventObj[`${uId}`]);
                if (data.length > 1 && isNullOrUndefined(eventObj[fields.recurrenceID])) {
                    id = typeof (maxId) === 'number' ? maxId++ : id;
                    for (let i = 0; i < data.length; i++) {
                        // eslint-disable-next-line no-prototype-builtins
                        if (data[parseInt(i.toString(), 10)].hasOwnProperty(fields.recurrenceID)) {
                            const exdate = data[parseInt(i.toString(), 10)][fields.recurrenceID];
                            data[parseInt(i.toString(), 10)][fields.id] = typeof (maxId) === 'number' ? maxId++ : this.parent.eventBase.generateGuid();
                            data[parseInt(i.toString(), 10)][fields.recurrenceID] = id;
                            data[parseInt(i.toString(), 10)][fields.recurrenceException] = null;
                            parentObj[fields.recurrenceException] =
                                this.getExcludeDateString(parentObj[fields.recurrenceException], exdate);
                            delete data[parseInt(i.toString(), 10)][`${uId}`];
                            appoint.push(data[parseInt(i.toString(), 10)]);
                        }
                    }
                    delete parentObj[`${uId}`];
                    parentObj[fields.id] = id;
                    appoint.push(parentObj);
                    // eslint-disable-next-line no-prototype-builtins
                }
                else if (!eventObj.hasOwnProperty(fields.recurrenceID)) {
                    delete eventObj[`${uId}`];
                    eventObj[fields.id] = typeof (maxId) === 'number' ? maxId++ : id;
                    appoint.push(eventObj);
                }
            }
        });
        return appoint;
    }
    getExcludeDateString(parentException, occurrenceException) {
        if (isNullOrUndefined(parentException)) {
            return occurrenceException;
        }
        else if (isNullOrUndefined(occurrenceException)) {
            return parentException;
        }
        const parentExDate = parentException.split(',').map((x) => x.split('T')[0]);
        const childExDate = occurrenceException.split(',').map((x) => x.split('T')[0]);
        const exDate = parentExDate.filter((x) => childExDate.indexOf(x) > -1);
        if (exDate.length > 0) {
            return parentException;
        }
        return parentException + ',' + occurrenceException;
    }
    getDateString(value) {
        value = value || '';
        // eslint-disable-next-line no-useless-escape
        return (value.replace(/\\\,/g, ',').replace(/\\\;/g, ';').replace(/\\[nN]/g, '\n').replace(/\\\\/g, '\\'));
    }
    dateParsing(element) {
        const split = element.split(':');
        const value = split[split.length - 1];
        let newDate = new Date(this.getDateString(value));
        if (element && (element.indexOf('VALUE=DATE') > -1 || element.indexOf('RECURRENCE-ID;TZID') > -1)) {
            const data = /^(\d{4})(\d{2})(\d{2})$/.exec(value);
            if (data !== null) {
                newDate = new Date(parseInt(data[1], 10), parseInt(data[2], 10) - 1, parseInt(data[3], 10));
            }
            if (element.indexOf('DTSTART') > -1) {
                this.allDay = true;
            }
        }
        const data = /^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(Z)?$/.exec(value);
        if (data !== null) {
            if (data[7] === 'Z') {
                newDate = new Date(Date.UTC(parseInt(data[1], 10), parseInt(data[2], 10) - 1, parseInt(data[3], 10), parseInt(data[4], 10), parseInt(data[5], 10), parseInt(data[6], 10)));
            }
            else {
                newDate = new Date(parseInt(data[1], 10), parseInt(data[2], 10) - 1, parseInt(data[3], 10), parseInt(data[4], 10), parseInt(data[5], 10), parseInt(data[6], 10));
            }
        }
        return newDate;
    }
    getModuleName() {
        return 'iCalendarImport';
    }
    destroy() {
        if (!this.parent || this.parent && this.parent.isDestroyed) {
            return;
        }
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Excel Export Module
 */
class ExcelExport {
    constructor(parent) {
        this.parent = parent;
    }
    initializeExcelExport(excelExportOptions = {}) {
        const exportColumns = this.getExportColumns(excelExportOptions);
        const exportName = excelExportOptions.fileName || 'Schedule';
        const exportType = excelExportOptions.exportType || 'xlsx';
        const isIncludeOccurrences = excelExportOptions.includeOccurrences || false;
        let separator;
        if (!isNullOrUndefined(excelExportOptions.separator) && excelExportOptions.separator !== ',') {
            separator = excelExportOptions.separator;
        }
        let eventCollection;
        if (excelExportOptions.customData) {
            eventCollection = !isIncludeOccurrences ? excelExportOptions.customData :
                this.parent.eventBase.getProcessedEvents(excelExportOptions.customData);
        }
        else {
            eventCollection = !isIncludeOccurrences ? this.parent.eventsData : this.parent.eventsProcessed;
        }
        this.processWorkbook(exportColumns, exportName, exportType, eventCollection, separator);
    }
    processWorkbook(fields, name, type, eventCollection, separator) {
        const columns = [];
        const rows = [];
        const columnHeader = [];
        fields.forEach((field, i) => { columns.push({ index: i + 1, width: (field.name === 'Id' ? 50 : 150) }); });
        const style = { fontSize: 12, borders: { color: '#E0E0E0' }, bold: true };
        fields.forEach((field, i) => { columnHeader.push({ index: i + 1, value: field.text, style: style }); });
        rows.push({ index: 1, cells: columnHeader });
        eventCollection.forEach((event, i) => {
            const columnData = [];
            fields.forEach((field, n) => {
                let columnRule = { index: n + 1, value: event[field.name] || '' };
                if (field.name === this.parent.eventFields.startTime || field.name === this.parent.eventFields.endTime) {
                    const styleRule = { fontSize: 12, numberFormat: 'm/d/yyyy h:mm AM/PM' };
                    columnRule = extend({}, columnRule, { style: styleRule }, true);
                }
                columnData.push(columnRule);
            });
            rows.push({ index: i + 2, cells: columnData });
        });
        const workSheet = [{ columns: columns, rows: rows }];
        const book = new Workbook({ worksheets: workSheet }, type, this.parent.locale, undefined, separator);
        book.save(name + '.' + type);
    }
    getExportColumns(exportOptions) {
        const exportColumns = exportOptions.fieldsInfo || [];
        if (exportColumns.length === 0) {
            const fields = exportOptions.fields || Object.keys(this.parent.eventFields).map((field) => this.parent.eventFields[`${field}`]);
            fields.forEach((field) => { exportColumns.push({ name: field, text: field }); });
        }
        return exportColumns;
    }
    getModuleName() {
        return 'excelExport';
    }
    destroy() {
        this.parent = null;
    }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Print Module
 */
class Print {
    constructor(parent) {
        this.parent = parent;
    }
    print(printOptions) {
        if (isNullOrUndefined(printOptions)) {
            this.printScheduler();
        }
        else {
            this.printSchedulerWithModel(printOptions);
        }
    }
    printScheduler() {
        const clone = this.parent.element.cloneNode(true);
        clone.id = this.parent.element.id + '_print';
        document.body.appendChild(clone);
        const className = this.parent.currentView === 'MonthAgenda' ? '.e-appointment-wrap' : '.e-content-wrap';
        const scrollableEle = this.parent.element.querySelector(className);
        const links = [].slice.call(document.getElementsByTagName('head')[0].querySelectorAll('link, style'));
        let reference = '';
        for (const link of links) {
            reference += link.outerHTML;
        }
        const div = createElement('div');
        clone.style.width = this.parent.element.offsetWidth + 'px';
        const elementWidth = Math.round((parseInt(clone.style.width, 10)) / 100) * 100;
        div.appendChild(clone);
        const printWindow = window.open('', 'print', 'height=550,width=' + elementWidth + ',tabbar=no');
        printWindow.document.write('<!DOCTYPE html><html><head>' + reference + '</head><body>' + div.innerHTML +
            '<script>(function() { window.ready = true; })();</script></body></html>');
        printWindow.document.close();
        printWindow.focus();
        setTimeout(() => {
            if (printWindow.ready && scrollableEle) {
                // eslint-disable-next-line no-self-assign
                scrollableEle.scrollLeft = scrollableEle.scrollLeft;
                // eslint-disable-next-line no-self-assign
                scrollableEle.scrollTop = scrollableEle.scrollTop;
                const headerTimeCellsScroll = printWindow.document.querySelector('.e-date-header-wrap');
                if (headerTimeCellsScroll) {
                    headerTimeCellsScroll.scrollLeft = scrollableEle.scrollLeft;
                }
                const timeCellsScroll = printWindow.document.querySelector('.e-time-cells-wrap');
                if (timeCellsScroll) {
                    timeCellsScroll.scrollTop = scrollableEle.scrollTop;
                }
                printWindow.print();
                printWindow.close();
            }
        }, 500);
    }
    printSchedulerWithModel(printOptions) {
        const element = createElement('div', { id: this.parent.element.id + '_print', className: 'e-print-schedule' });
        document.body.appendChild(element);
        Schedule.Inject(Day, Week, WorkWeek, Month, Agenda, MonthAgenda, TimelineViews, TimelineMonth, Year, TimelineYear);
        this.printInstance = new Schedule(this.getPrintScheduleModel(printOptions));
        this.printInstance.isPrinting = true;
        this.printInstance.appendTo(element);
        this.printInstance.on(print$1, this.contentReady, this);
        this.printWindow = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');
        this.printWindow.moveTo(0, 0);
        this.printWindow.resizeTo(screen.availWidth, screen.availHeight);
    }
    getPrintScheduleModel(printOptions) {
        const printModel = {};
        const scheduleProps = ['agendaDaysCount', 'calendarMode', 'cssClass', 'currentView',
            'dateFormat', 'enableRtl', 'endHour', 'eventSettings', 'firstDayOfWeek',
            'firstMonthOfYear', 'group', 'height', 'locale', 'maxDate', 'minDate', 'readonly',
            'resources', 'rowAutoHeight', 'selectedDate', 'showHeaderBar', 'showTimeIndicator', 'showWeekNumber',
            'showWeekend', 'startHour', 'timeFormat', 'timeScale', 'timezone', 'views', 'width', 'workDays', 'workHours',
            'dateHeaderTemplate', 'dateRangeTemplate', 'cellHeaderTemplate', 'dayHeaderTemplate', 'monthHeaderTemplate',
            'cellTemplate', 'resourceHeaderTemplate', 'headerIndentTemplate', 'actionBegin', 'actionComplete', 'actionFailure',
            'created', 'dataBinding', 'dataBound', 'destroyed', 'eventRendered', 'moreEventsClick', 'navigating', 'popupOpen', 'popupClose', 'renderCell'
        ];
        const scheduleTemplates = ['cellHeaderTemplate', 'dayHeaderTemplate', 'monthHeaderTemplate', 'cellTemplate',
            'dateHeaderTemplate', 'dateRangeTemplate', 'eventTemplate', 'resourceHeaderTemplate', 'headerIndentTemplate'];
        const scheduleEvents = ['actionBegin', 'actionComplete', 'actionFailure', 'created', 'dataBinding', 'dataBound',
            'destroyed', 'eventRendered', 'moreEventsClick', 'navigating', 'popupOpen', 'popupClose', 'renderCell'];
        let eventSettings;
        let group;
        let timeScale;
        let views;
        for (const key of scheduleProps) {
            switch (key) {
                case 'eventSettings': {
                    eventSettings = Object.assign({}, this.parent.eventSettings.properties);
                    eventSettings.dataSource = this.parent.eventsData;
                    const eventTemplate = !isNullOrUndefined(printOptions.eventSettings) &&
                        !isNullOrUndefined(printOptions.eventSettings.template) ? printOptions.eventSettings.template : eventSettings.template;
                    eventSettings.template = typeof (eventTemplate) === 'function' ? null : eventTemplate;
                    printModel.eventSettings = eventSettings;
                    break;
                }
                case 'group':
                    group = isNullOrUndefined(printOptions.group) ? this.parent.group : printOptions.group;
                    group.headerTooltipTemplate = null;
                    printModel.group = group;
                    break;
                case 'timeScale':
                    timeScale = isNullOrUndefined(printOptions.timeScale) ? this.parent.timeScale : printOptions.timeScale;
                    timeScale.majorSlotTemplate = typeof (timeScale.majorSlotTemplate) === 'function' ? null : timeScale.majorSlotTemplate;
                    timeScale.minorSlotTemplate = typeof (timeScale.minorSlotTemplate) === 'function' ? null : timeScale.minorSlotTemplate;
                    printOptions.timeScale = timeScale;
                    break;
                case 'views':
                    views = isNullOrUndefined(printOptions.views) ? this.parent.views : printOptions.views;
                    if (views && views.length > 0 && typeof (views[0]) === 'object') {
                        for (const view of views) {
                            scheduleTemplates.forEach((x) => {
                                if (!isNullOrUndefined(view[`${x}`])) {
                                    view[`${x}`] = typeof (view[`${x}`]) === 'function' ? null : view[`${x}`];
                                }
                            });
                        }
                    }
                    printModel.views = views;
                    break;
                default:
                    if (scheduleTemplates.indexOf(key) > -1) {
                        printModel[`${key}`] = isNullOrUndefined(printOptions[`${key}`]) ?
                            (typeof (this.parent[`${key}`]) === 'function' ? null : this.parent[`${key}`]) :
                            (typeof (printOptions[`${key}`]) === 'function' ? null : printOptions[`${key}`]);
                        break;
                    }
                    if (scheduleEvents.indexOf(key) > -1) {
                        printModel[`${key}`] = printOptions[`${key}`];
                        break;
                    }
                    printModel[`${key}`] = isNullOrUndefined(printOptions[`${key}`]) ?
                        this.parent[`${key}`] : printOptions[`${key}`];
                    break;
            }
        }
        return printModel;
    }
    contentReady() {
        this.printWindow = print(this.printInstance.element, this.printWindow);
        this.printWindow.onbeforeunload = () => {
            this.printInstance.off(print$1, this.contentReady);
            this.printInstance.element.remove();
            this.printInstance.destroy();
            this.printInstance = null;
            this.printWindow = null;
        };
    }
    getModuleName() {
        return 'print';
    }
    destroy() {
        this.parent = null;
    }
}

/**
 * Exporting modules
 */

/**
 * Schedule component exported items
 */

/**
 * Recurrence-Editor component exported items
 */

/**
 * Calendar util exported items
 */

/**
 * Export Schedule components
 */

export { Schedule, cellClick, cellDoubleClick, moreEventsClick, select, hover, actionBegin, actionComplete, actionFailure, navigating, renderCell, eventClick, eventRendered, dataBinding, dataBound, popupOpen, popupClose, dragStart, drag, dragStop, resizeStart, resizing, resizeStop, inlineClick, cellSelect, initialLoad, initialEnd, print$1 as print, dataReady, eventsLoaded, contentReady, scroll, virtualScroll, scrollUiUpdate, uiUpdate, documentClick, cellMouseDown, WEEK_LENGTH, DEFAULT_WEEKS, MS_PER_DAY, MS_PER_MINUTE, getElementHeightFromClass, getElementWidthFromClass, getTranslateY, getTranslateX, getWeekFirstDate, getWeekLastDate, firstDateOfMonth, lastDateOfMonth, getWeekNumber, getWeekMiddleDate, setTime, resetTime, getDateInMs, getDateCount, addDays, addMonths, addYears, getStartEndHours, getMaxDays, getDaysCount, getDateFromString, getScrollBarWidth, findIndexInData, getOuterHeight, removeChildren, isDaylightSavingTime, getUniversalTime, isMobile, isIPadDevice, capitalizeFirstWord, Resize, DragAndDrop, HeaderRenderer, ViewBase, Day, Week, WorkWeek, Month, Year, Agenda, MonthAgenda, TimelineViews, TimelineMonth, TimelineYear, Timezone, timezoneData, ICalendarExport, ICalendarImport, ExcelExport, Print, RecurrenceEditor, generateSummary, generate, getDateFromRecurrenceDateString, extractObjectFromRule, getCalendarUtil, getRecurrenceStringFromDate, Gregorian, Islamic };
//# sourceMappingURL=ej2-schedule.es2015.js.map
